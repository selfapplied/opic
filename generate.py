#!/usr/bin/env python3
"""Opic code generation â€” Metal and Swift"""

from pathlib import Path
import re

def parse_ops(text):
    """Parse .ops file into defs and voices"""
    defs, voices = {}, {}
    for line in text.splitlines():
        line = line.strip()
        if not line or line.startswith(";"):
            continue
        if line.startswith("def "):
            parts = line[4:].split()
            name = parts[0]
            defs[name] = {}
        elif line.startswith("voice "):
            l, _, r = line.partition("/")
            name = l.split()[1].strip()
            body = r.strip().strip('" ')
            voices[name] = body
    return defs, voices

def compose(voices, src="main", dst="str"):
    """Compose voices - get voice body or default transformation"""
    return voices.get(src, f"{src}->{dst}")

def generate_metal_shader(defs, voices, entry_point="main"):
    """Generate Metal compute shader from opic defs and voices"""
    lines = [
        "#include <metal_stdlib>",
        "using namespace metal;",
        "",
        "// Generated by Opic",
        "",
    ]
    
    # Generate structs from defs
    for name, fields in defs.items():
        if name in ["str", "int", "file", "error", "error.template"]:
            continue
        struct_name = name.replace(".", "_").title()
        lines.append(f"struct {struct_name} {{")
        lines.append("    float placeholder;")
        lines.append("};")
        lines.append("")
    
    # Track kernels to avoid duplicates
    seen_kernels = set()
    
    # Generate kernel functions from voices
    kernel_id = 0
    for name, body in voices.items():
        if name in ["void", "stoichiometry", "balance"]:
            continue
        
        kernel_name = name.replace(".", "_").replace("/", "_")
        full_kernel_name = f"{kernel_name}_kernel"
        
        # Skip if already generated (e.g., main_kernel)
        if full_kernel_name in seen_kernels:
            continue
        
        seen_kernels.add(full_kernel_name)
        lines.append(f"kernel void {full_kernel_name}(")
        lines.append("    device float* input [[buffer(0)]],")
        lines.append("    device float* output [[buffer(1)]],")
        lines.append("    uint id [[thread_position_in_grid]]")
        lines.append(") {")
        lines.append(f"    // {body}")
        lines.append("    output[id] = input[id];")
        lines.append("}")
        lines.append("")
        kernel_id += 1
    
    # Entry point kernel (only if not already generated)
    entry_kernel_name = f"{entry_point}_kernel"
    if entry_kernel_name not in seen_kernels:
        lines.append(f"kernel void {entry_kernel_name}(")
        lines.append("    device float* input [[buffer(0)]],")
        lines.append("    device float* output [[buffer(1)]],")
        lines.append("    uint id [[thread_position_in_grid]]")
        lines.append(") {")
        if entry_point in voices:
            body = voices[entry_point]
            lines.append(f"    // {body}")
        lines.append("    output[id] = input[id];")
        lines.append("}")
    
    return "\n".join(lines)

def load_implementations():
    """Load implementation definitions from opic"""
    impl_files = [
        Path(__file__).parent / "implementations.ops",
        Path(__file__).parent / "generate_logic.ops",
        Path(__file__).parent / "signature.ops",
        Path(__file__).parent / "alias.ops",
        Path(__file__).parent / "reconcile.ops",
        Path(__file__).parent / "generate_impl.ops",
    ]
    all_voices = {}
    for impl_file in impl_files:
        if impl_file.exists():
            defs, voices = parse_ops(impl_file.read_text())
            all_voices.update(voices)
    return {}, all_voices

def parse_voice_signature(body):
    """Parse voice body to extract parameter list and return type - from opic signature.ops"""
    # Use opic definition: voice parse.voice.body / {body -> parameters + return_type}
    if "->" not in body:
        return [], None
    
    # Use opic: voice split.arrow / {body -> input + output}
    parts = body.split("->")
    input_part = parts[0].strip().strip("{}")
    output_part = parts[1].strip().strip("{}")
    
    # Use opic: voice split.plus / {input -> param.list}
    params = []
    for param in input_part.split("+"):
        param = param.strip()
        if param:
            params.append(param)
    
    return params, output_part

def canonicalize_parameter(param):
    """Canonicalize parameter names using alias mapping - entirely from opic alias.ops"""
    # Load aliases from opic definitions
    impl_defs, impl_voices = load_implementations()
    
    # Check opic alias.ops definitions first (voice map.*)
    param_lower = param.lower()
    for key, value in impl_voices.items():
        if key.startswith("map.") or key.startswith("alias."):
            # Extract from opic: voice map.grad / "grad -> gradient"
            if "->" in value:
                parts = value.split("->")
                from_name = parts[0].strip().strip('"')
                to_name = parts[1].strip().strip('"')
                if from_name.lower() == param_lower:
                    param = to_name
                    break
    
    canonical = param
    
    # Use opic generate_impl.ops: voice convert.snake_case / {snake_case -> camelCase}
    if "_" in canonical:
        parts = canonical.split("_")
        canonical = parts[0] + "".join(p.capitalize() for p in parts[1:])
    return canonical

def find_implementation(voice_name, impl_voices):
    """Find implementation for a voice from opic definitions"""
    # Direct match
    if voice_name + ".impl" in impl_voices:
        return impl_voices[voice_name + ".impl"]
    # Pattern match
    for impl_key, impl_code in impl_voices.items():
        if impl_key.startswith("implement.") and voice_name.lower() in impl_key.lower():
            return impl_code
        if impl_key.startswith("compute.") and voice_name.lower() in impl_key.lower():
            return impl_code
    return None

def translate_implementation_to_swift(impl_code, func_name, voice_name, body):
    """Translate opic implementation to Swift code - uses opic generate_impl.ops translation rules"""
    # Parse voice signature to extract parameters
    params, output_type = parse_voice_signature(body)
    
    # Canonicalize parameter names
    canonical_params = [canonicalize_parameter(p) for p in params]
    
    if not impl_code:
        # Generate from signature using opic reconciliation patterns
        if canonical_params:
            param_list = ", ".join([f"{p}: Double" for p in canonical_params])
            
            # Apply opic reconciliation patterns from reconcile.ops
            # voice reconcile.optimize / {weight + gradient + learning_rate -> weight - learningRate * gradient}
            # voice reconcile.update.weight / {weight + gradient + learning_rate -> weight - gradient}
            if "update" in voice_name.lower() and len(canonical_params) >= 3:
                # For update.weight, gradient is already scaled: weight - gradient
                return f"""func {func_name}({param_list}) -> Double {{
    // From opic reconcile.update.weight: {body}
    return {canonical_params[0]} - {canonical_params[1]}
}}"""
            elif "optimize" in voice_name.lower() and len(canonical_params) >= 3:
                # For optimize, scale gradient: weight - learningRate * gradient
                return f"""func {func_name}({param_list}) -> Double {{
    // From opic reconcile.optimize: {body}
    return {canonical_params[0]} - {canonical_params[2]} * {canonical_params[1]}
}}"""
            # voice reconcile.gradient / {loss + learning_rate -> loss * learningRate}
            elif "gradient" in voice_name.lower() and len(canonical_params) >= 2:
                return f"""func {func_name}({param_list}) -> Double {{
    // From opic reconcile.gradient: {body}
    return {canonical_params[0]} * {canonical_params[1]}
}}"""
            # voice reconcile.synthesize / {a + b -> (a, b)}
            elif ("synthesize" in voice_name.lower() or "combine" in voice_name.lower()) and len(canonical_params) >= 2:
                param_list_any = ", ".join([f"{p}: Any" for p in canonical_params])
                return f"""func {func_name}({param_list_any}) -> Any {{
    // From opic reconcile.synthesize: {body}
    return ({canonical_params[0]}, {canonical_params[1]})
}}"""
            else:
                return f"""func {func_name}({param_list}) -> Double {{
    // {body}
    return {canonical_params[0] if canonical_params else "0.0"}
}}"""
        return None
    
    # Load translation rules from opic generate_impl.ops
    _, impl_voices = load_implementations()
    
    # Check opic pattern matching rules (entirely from generate_impl.ops)
    impl_lower = impl_code.lower()
    voice_lower = voice_name.lower()
    
    # Find matching pattern from opic generate_impl.ops
    # Check all match.*.pattern and match.*.voice rules
    translation_key = None
    for key in impl_voices:
        if key.startswith("match.") and key.endswith(".pattern"):
            pattern = impl_voices[key].strip('"')
            if pattern in impl_code:
                # Found pattern match, get corresponding translation
                base_name = key.replace("match.", "").replace(".pattern", "")
                translation_key = f"translate.{base_name}.to.swift"
                break
        elif key.startswith("match.") and key.endswith(".voice"):
            voice_pattern = impl_voices[key].strip('"')
            import re
            if re.search(voice_pattern, voice_lower):
                base_name = key.replace("match.", "").replace(".voice", "")
                translation_key = f"translate.{base_name}.to.swift"
                break
    
    # If found translation rule, use it
    if translation_key and translation_key in impl_voices:
        swift_body = impl_voices[translation_key].strip('"')
        # Determine parameter types from opic default types
        default_type = impl_voices.get("default.param.type", "Double").strip('"')
        array_type = impl_voices.get("default.array.type", "[Double]").strip('"')
        
        # Determine types from opic generate_impl.ops - check if this is an array operation
        # Check opic array.operation.* rules
        base_name = translation_key.replace("translate.", "").replace(".to.swift", "")
        is_array_op = impl_voices.get(f"array.operation.{base_name}", "false").strip('"').lower() == "true"
        
        if is_array_op:
            # Array operations - use opic default.array.type
            if canonical_params:
                param_list = ", ".join([f"{p}: {array_type}" for p in canonical_params])
                return_type = array_type
            else:
                param_list = f"input: {array_type}"
                return_type = array_type
        else:
            # Scalar operations - use opic default.param.type
            if canonical_params:
                param_list = ", ".join([f"{p}: {default_type}" for p in canonical_params])
                return_type = default_type
            else:
                param_list = f"input: {default_type}"
                return_type = default_type
        
        return f"""func {func_name}({param_list}) -> {return_type} {{
    // From opic {translation_key}
    {swift_body}
}}"""
    
    # Synthesis pattern - use opic reconcile.ops: voice reconcile.synthesize
    if "synthesize" in voice_name.lower() or "combine" in voice_name.lower():
        # Use opic: voice reconcile.synthesize / {a + b -> (a, b)}
        if canonical_params and len(canonical_params) >= 2:
            param_list = ", ".join([f"{p}: Any" for p in canonical_params])
            return f"""func {func_name}({param_list}) -> Any {{
    // Hybrid composition: {body}
    // From opic reconcile.synthesize: {canonical_params[0]} + {canonical_params[1]} -> ({canonical_params[0]}, {canonical_params[1]})
    return ({canonical_params[0]}, {canonical_params[1]})
}}"""
        return f"""func {func_name}(a: Any, b: Any) -> Any {{
    // {body}
    return (a, b)
}}"""
    
    # All pattern matching now handled above via opic generate_impl.ops rules
    # No hardcoded checks here - everything comes from opic
    
    # Generic implementation with parsed signature - use opic default types
    default_type = impl_voices.get("default.param.type", "Double").strip('"')
    default_return = impl_voices.get("default.return.type", "Double").strip('"')
    
    if canonical_params:
        param_list = ", ".join([f"{p}: {default_type}" for p in canonical_params])
        return f"""func {func_name}({param_list}) -> {default_return} {{
    // From opic: {impl_code}
    return {canonical_params[0] if canonical_params else "0.0"}
}}"""
    
    return f"""func {func_name}(input: {default_type}) -> {default_return} {{
    // From opic: {impl_code}
    return input
}}"""

def generate_swift_code(defs, voices, entry_point="main"):
    """Generate Swift code from opic defs and voices - all from opic definitions"""
    # Load implementation definitions from opic
    impl_defs, impl_voices = load_implementations()
    
    lines = [
        "// Generated by Opic - all implementations from opic definitions",
        "import Foundation",
        "import Accelerate",
        "",
    ]
    
    # Generate structs from defs (from opic)
    for name, fields in defs.items():
        if name in ["str", "int", "file", "error", "error.template"]:
            continue
        # Sanitize struct name using opic generate_impl.ops rules
        struct_name = name
        # Apply opic struct name generation rules
        if "struct.remove.dots" in impl_voices:
            struct_name = struct_name.replace(".", "_")
        if "struct.split.on" in impl_voices:
            split_char = impl_voices["struct.split.on"].strip('"')
            words = struct_name.split(split_char)
            if "struct.capitalize.words" in impl_voices and impl_voices["struct.capitalize.words"].strip('"').lower() == "true":
                struct_name = "".join(word.capitalize() for word in words)
            else:
                struct_name = "".join(words)
        lines.append(f"struct {struct_name} {{")
        lines.append("    // fields from opic def")
        lines.append("}")
        lines.append("")
    
    # Generate functions from voices with implementations from opic
    for name, body in voices.items():
        if name in ["void", "stoichiometry", "balance", "target"]:
            continue
        
        # Sanitize function name using opic generate_impl.ops rules
        func_name = name
        # Apply opic sanitization rules
        if "sanitize.remove.dots" in impl_voices:
            func_name = func_name.replace(".", "")
        if "sanitize.remove.slashes" in impl_voices:
            func_name = func_name.replace("/", "")
        # Remove invalid Swift characters (from opic sanitize.remove.special)
        func_name = "".join(c if c.isalnum() else "_" for c in func_name)
        
        # Find implementation from opic definitions
        impl_code = find_implementation(name, impl_voices)
        swift_impl = translate_implementation_to_swift(impl_code, func_name, name, body)
        
        if swift_impl:
            lines.append(swift_impl)
        else:
            # Infer from voice signature (from opic)
            if "->" in body:
                parts = body.split("->")
                if len(parts) == 2:
                    input_part = parts[0].strip().strip("{}")
                    output_part = parts[1].strip().strip("{}")
                    # Parse parameters from opic voice body
                    inputs = [p.strip() for p in input_part.split("+") if p.strip()]
                    if inputs:
                        param_list = ", ".join([f"{p}: Double" for p in inputs])
                        lines.append(f"func {func_name}({param_list}) -> Double {{")
                        lines.append(f"    // From opic: {body}")
                        lines.append(f"    return {inputs[0]}")
                        lines.append("}")
                    else:
                        lines.append(f"func {func_name}() -> Double {{")
                        lines.append(f"    // From opic: {body}")
                        lines.append("    return 0.0")
                        lines.append("}")
                else:
                    lines.append(f"func {func_name}(input: Double) -> Double {{")
                    lines.append(f"    // From opic: {body}")
                    lines.append("    return input")
                    lines.append("}")
            else:
                lines.append(f"func {func_name}(input: Double) -> Double {{")
                lines.append(f"    // From opic: {body}")
                lines.append("    return input")
                lines.append("}")
        lines.append("")
    
    # Entry point from opic
    entry_func = entry_point.replace(".", "").replace("/", "")
    entry_func = "".join(c if c.isalnum() else "_" for c in entry_func)
    lines.append(f"func {entry_func}() {{")
    if entry_point in voices:
        body = voices[entry_point]
        lines.append(f"    // From opic: {body}")
    lines.append(f"    print(\"opic: {entry_point}\")")
    lines.append("}")
    lines.append("")
    lines.append(f"{entry_func}()")
    
    return "\n".join(lines)

def generate_metal(ops_file, output_file=None):
    """Generate Metal code from .ops file"""
    ops_path = Path(ops_file)
    if not ops_path.exists():
        raise FileNotFoundError(f"File not found: {ops_file}")
    
    defs, voices = parse_ops(ops_path.read_text())
    metal_code = generate_metal_shader(defs, voices)
    
    if output_file:
        Path(output_file).write_text(metal_code)
        print(f"Generated Metal shader: {output_file}")
    else:
        print(metal_code)
    
    return metal_code

def generate_swift(ops_file, output_file=None):
    """Generate Swift code from .ops file"""
    ops_path = Path(ops_file)
    if not ops_path.exists():
        raise FileNotFoundError(f"File not found: {ops_file}")
    
    defs, voices = parse_ops(ops_path.read_text())
    swift_code = generate_swift_code(defs, voices)
    
    if output_file:
        Path(output_file).write_text(swift_code)
        print(f"Generated Swift code: {output_file}")
    else:
        print(swift_code)
    
    return swift_code

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 3:
        print("Usage: generate.py <metal|swift> <ops_file> [output_file]")
        sys.exit(1)
    
    target = sys.argv[1]
    ops_file = sys.argv[2]
    output_file = sys.argv[3] if len(sys.argv) > 3 else None
    
    if target == "metal":
        generate_metal(ops_file, output_file)
    elif target == "swift":
        generate_swift(ops_file, output_file)
    else:
        print(f"Unknown target: {target}", file=sys.stderr)
        sys.exit(1)

