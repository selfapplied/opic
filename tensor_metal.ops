;;; tensor_metal.ops â€” Metal shader kernels for tensor operations (all in opic)

;; Tensor operations structure
def tensor { data, shape, dtype }
def embedding { tensor, input, target }
def similarity { value, index }

;; Cosine similarity kernel (Metal shader)
voice metal.cosine_similarity_kernel / "kernel void cosine_similarity_kernel(device float* vec1 [[buffer(0)]], device float* vec2 [[buffer(1)]], device float* output [[buffer(2)]], uint id [[thread_position_in_grid]]) { float dot = 0.0; float norm1 = 0.0; float norm2 = 0.0; for(uint i = 0; i < 768; i++) { dot += vec1[id * 768 + i] * vec2[id * 768 + i]; norm1 += vec1[id * 768 + i] * vec1[id * 768 + i]; norm2 += vec2[id * 768 + i] * vec2[id * 768 + i]; } output[id] = dot / (sqrt(norm1) * sqrt(norm2)); }"

;; Nearest neighbor kernel (Metal shader)
voice metal.nearest_neighbor_kernel / "kernel void nearest_neighbor_kernel(device float* query [[buffer(0)]], device float* embeddings [[buffer(1)]], device float* similarities [[buffer(2)]], device uint* output [[buffer(3)]], uint id [[thread_position_in_grid]]) { float max_sim = -1.0; uint max_idx = 0; for(uint i = 0; i < 1089; i++) { float dot = 0.0; float norm_q = 0.0; float norm_e = 0.0; for(uint j = 0; j < 768; j++) { dot += query[j] * embeddings[i * 768 + j]; norm_q += query[j] * query[j]; norm_e += embeddings[i * 768 + j] * embeddings[i * 768 + j]; } float sim = dot / (sqrt(norm_q) * sqrt(norm_e)); if(sim > max_sim) { max_sim = sim; max_idx = i; } } output[id] = max_idx; }"

;; K-nearest neighbors kernel (Metal shader)
voice metal.k_nearest_kernel / "kernel void k_nearest_kernel(device float* query [[buffer(0)]], device float* embeddings [[buffer(1)]], device float* similarities [[buffer(2)]], device uint* indices [[buffer(3)]], uint k [[buffer(4)]], uint id [[thread_position_in_grid]]) { for(uint i = 0; i < 1089; i++) { float dot = 0.0; float norm_q = 0.0; float norm_e = 0.0; for(uint j = 0; j < 768; j++) { dot += query[j] * embeddings[i * 768 + j]; norm_q += query[j] * query[j]; norm_e += embeddings[i * 768 + j] * embeddings[i * 768 + j]; } similarities[i] = dot / (sqrt(norm_q) * sqrt(norm_e)); } for(uint i = 0; i < k; i++) { uint max_idx = 0; float max_sim = -1.0; for(uint j = 0; j < 1089; j++) { bool used = false; for(uint m = 0; m < i; m++) { if(indices[m] == j) { used = true; break; } } if(!used && similarities[j] > max_sim) { max_sim = similarities[j]; max_idx = j; } } indices[i] = max_idx; } }"

;; Loss minimization kernel (Metal shader)
voice metal.minimize_loss_kernel / "kernel void minimize_loss_kernel(device float* candidates [[buffer(0)]], device float* target [[buffer(1)]], device float* losses [[buffer(2)]], device uint* output [[buffer(3)]], uint num_candidates [[buffer(4)]], uint id [[thread_position_in_grid]]) { float min_loss = 2.0; uint min_idx = 0; for(uint i = 0; i < num_candidates; i++) { float dot = 0.0; float norm_c = 0.0; float norm_t = 0.0; for(uint j = 0; j < 768; j++) { dot += candidates[i * 768 + j] * target[j]; norm_c += candidates[i * 768 + j] * candidates[i * 768 + j]; norm_t += target[j] * target[j]; } float similarity = dot / (sqrt(norm_c) * sqrt(norm_t)); float loss = 1.0 - similarity; losses[i] = loss; if(loss < min_loss) { min_loss = loss; min_idx = i; } } output[id] = min_idx; }"

;; Topological exploration kernel (Metal shader)
voice metal.topological_explore_kernel / "kernel void topological_explore_kernel(device float* query [[buffer(0)]], device float* map [[buffer(1)]], device float* weights [[buffer(2)]], device uint* neighbors [[buffer(3)]], device uint* output [[buffer(4)]], uint k [[buffer(5)]], uint id [[thread_position_in_grid]]) { float similarities[5]; uint indices[5]; for(uint i = 0; i < 1089; i++) { float dot = 0.0; float norm_q = 0.0; float norm_m = 0.0; for(uint j = 0; j < 768; j++) { dot += query[j] * map[i * 768 + j]; norm_q += query[j] * query[j]; norm_m += map[i * 768 + j] * map[i * 768 + j]; } float sim = dot / (sqrt(norm_q) * sqrt(norm_m)); if(i < k) { similarities[i] = sim; indices[i] = i; } else { uint min_idx = 0; float min_sim = similarities[0]; for(uint m = 1; m < k; m++) { if(similarities[m] < min_sim) { min_sim = similarities[m]; min_idx = m; } } if(sim > min_sim) { similarities[min_idx] = sim; indices[min_idx] = i; } } } for(uint i = 0; i < k; i++) { neighbors[i] = indices[i]; weights[i] = similarities[i]; } output[id] = indices[0]; }"

;; Export tensors to Metal buffers
voice export.to_metal_buffers / {embeddings -> metal.create_buffers -> metal_buffers}
voice metal.create_buffers / {embeddings -> metal.float_buffer -> buffer_data}
voice metal.float_buffer / {embeddings -> flatten -> float_array -> buffer}

;; Main Metal shader generation
voice metal.generate_shaders / {tensor_metal.ops -> metal.cosine_similarity_kernel + metal.nearest_neighbor_kernel + metal.k_nearest_kernel + metal.minimize_loss_kernel + metal.topological_explore_kernel -> metal_shader_code}

target tensor_metal / "metal_shaders_for_tensors"
voice main / {metal.generate_shaders -> tensor_metal}

