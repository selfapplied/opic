#!/usr/bin/env python3
"""
Compile Binary — Create self-contained opic binary with all .ops files embedded
Implements opic_compile_binary.ops
"""

import sys
import json
from pathlib import Path
from typing import Dict, List

def collect_all_ops_files(project_root: Path) -> Dict[str, str]:
    """Collect all .ops files and embed them as strings"""
    embedded_files = {}
    
    # Root .ops files
    for ops_file in project_root.glob("*.ops"):
        if ops_file.name.startswith("."):
            continue
        content = ops_file.read_text()
        embedded_files[f"root/{ops_file.name}"] = content
    
    # Core .ops files
    core_dir = project_root / "core"
    if core_dir.exists():
        for ops_file in core_dir.glob("*.ops"):
            content = ops_file.read_text()
            embedded_files[f"core/{ops_file.name}"] = content
    
    # Systems .ops files
    systems_dir = project_root / "systems"
    if systems_dir.exists():
        for ops_file in systems_dir.glob("*.ops"):
            content = ops_file.read_text()
            embedded_files[f"systems/{ops_file.name}"] = content
    
    return embedded_files

def create_standalone_binary(project_root: Path, output_path: Path):
    """Create standalone binary with all .ops files embedded"""
    
    # Collect all files
    ops_files = collect_all_ops_files(project_root)
    generate_py = (project_root / "generate.py").read_text()
    executor_py = (project_root / "scripts" / "opic_executor.py").read_text()
    
    # Create embedded data structure
    embedded_data = {
        "ops_files": ops_files,
        "generate_py": generate_py,
        "executor_py": executor_py,
    }
    
    # Generate binary code
    binary_code = f'''#!/usr/bin/env python3
"""
opic Standalone Binary — Self-contained opic with all .ops files embedded
Generated by opic_compile_binary.ops
"""

import sys
import json
from pathlib import Path
from typing import Dict, Any, Optional, List
import importlib.util
import io

# Embedded .ops files
EMBEDDED_OPS_FILES = {json.dumps(ops_files, indent=2)}

# Embedded generate.py
EMBEDDED_GENERATE_PY = {repr(generate_py)}

# Embedded opic_executor.py  
EMBEDDED_EXECUTOR_PY = {repr(executor_py)}

class EmbeddedOpicExecutor:
    """Opic executor using embedded .ops files"""
    
    def __init__(self):
        self.project_root = Path(__file__).parent
        self.ops_files = EMBEDDED_OPS_FILES
        self._init_parser()
        self._init_executor()
        self.voices = {{}}
        self.defs = {{}}
        self._load_all_ops()
    
    def _init_parser(self):
        """Initialize parser from embedded generate.py"""
        # Create a module from embedded generate.py
        spec = importlib.util.spec_from_loader("generate", loader=None)
        generate_module = importlib.util.module_from_spec(spec)
        exec(EMBEDDED_GENERATE_PY, generate_module.__dict__)
        self.parse_ops = generate_module.parse_ops
    
    def _init_executor(self):
        """Initialize executor from embedded opic_executor.py"""
        # Create executor module
        spec = importlib.util.spec_from_loader("opic_executor", loader=None)
        executor_module = importlib.util.module_from_spec(spec)
        # Replace project_root logic with embedded version
        executor_code = EMBEDDED_EXECUTOR_PY.replace(
            'self.project_root = Path(project_root).resolve()',
            'self.project_root = Path(__file__).parent  # Embedded mode'
        )
        executor_code = executor_code.replace(
            'def _init_parser(self):',
            'def _init_parser_original(self):'
        )
        # Add embedded parser init
        executor_code += '''
    def _init_parser(self):
        """Initialize parser from embedded generate.py"""
        global parse_ops
        spec = importlib.util.spec_from_loader("generate", loader=None)
        generate_module = importlib.util.module_from_spec(spec)
        exec(EMBEDDED_GENERATE_PY, generate_module.__dict__)
        parse_ops = generate_module.parse_ops
'''
        exec(executor_code, executor_module.__dict__)
        self.OpicExecutor = executor_module.OpicExecutor
    
    def _load_all_ops(self):
        """Load all embedded .ops files"""
        executor = self.OpicExecutor(self.project_root)
        # Load ops files from embedded data
        for path, content in self.ops_files.items():
            # Create a virtual file path
            virtual_path = self.project_root / path
            executor._load_ops_file_from_content(virtual_path, content)
        self.voices = executor.voices
        self.defs = executor.defs
        self.executor = executor
    
    def execute_voice(self, voice_name: str, inputs: Dict[str, Any] = None):
        """Execute a voice"""
        return self.executor.execute_voice(voice_name, inputs)
    
    def _load_ops_file_from_content(self, path: Path, content: str):
        """Load .ops file from content string"""
        # This would need to be added to OpicExecutor
        pass

def main():
    """CLI entry point"""
    executor = EmbeddedOpicExecutor()
    
    if len(sys.argv) < 2:
        executor.execute_voice("main")
        return
    
    command = sys.argv[1]
    
    # Route commands
    if command == "execute" and len(sys.argv) > 2:
        ops_file = sys.argv[2]
        executor._load_ops_file_from_content(Path(ops_file), EMBEDDED_OPS_FILES.get(ops_file, ""))
        executor.execute_voice("main")
    elif command in executor.voices:
        executor.execute_voice(command)
    else:
        print(f"Unknown command: {{command}}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
'''
    
    # Write binary
    output_path.write_text(binary_code)
    output_path.chmod(0o755)
    
    print(f"✓ Created standalone binary: {output_path}")
    print(f"  Embedded {len(ops_files)} .ops files")
    print(f"  Size: {len(binary_code) / 1024 / 1024:.2f} MB")

if __name__ == "__main__":
    project_root = Path(__file__).parent.parent
    output_path = project_root / "opic_binary"
    
    create_standalone_binary(project_root, output_path)
    print(f"\n✓ Standalone binary created: {output_path}")
    print(f"  Run: ./opic_binary hello")

