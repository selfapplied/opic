#!/usr/bin/env python3
"""
Create Standalone Binary — Embed all .ops files into a single executable
Implements opic_compile_binary.ops: compile all .ops files into binary
"""

import sys
import json
import base64
from pathlib import Path
from typing import Dict

def collect_all_ops_files(project_root: Path) -> Dict[str, str]:
    """Collect all .ops files"""
    embedded_files = {}
    
    # Root .ops files
    for ops_file in sorted(project_root.glob("*.ops")):
        if ops_file.name.startswith("."):
            continue
        content = ops_file.read_text()
        embedded_files[f"root/{ops_file.name}"] = content
    
    # Core .ops files
    core_dir = project_root / "core"
    if core_dir.exists():
        for ops_file in sorted(core_dir.glob("*.ops")):
            content = ops_file.read_text()
            embedded_files[f"core/{ops_file.name}"] = content
    
    # Systems .ops files
    systems_dir = project_root / "systems"
    if systems_dir.exists():
        for ops_file in sorted(systems_dir.glob("*.ops")):
            content = ops_file.read_text()
            embedded_files[f"systems/{ops_file.name}"] = content
    
    return embedded_files

def create_standalone_binary(project_root: Path, output_path: Path):
    """Create standalone binary with all .ops files embedded"""
    
    print("Collecting all .ops files...")
    ops_files = collect_all_ops_files(project_root)
    print(f"  Found {len(ops_files)} .ops files")
    
    print("Reading generate.py and opic_executor.py...")
    # generate.py might be in scripts/ or root
    generate_path = project_root / "scripts" / "generate.py"
    if not generate_path.exists():
        generate_path = project_root / "generate.py"
    if generate_path.exists():
        generate_py = generate_path.read_text()
    else:
        # Create minimal generate.py if missing
        generate_py = '''def parse_ops(text):
    """Parse .ops file"""
    defs, voices, includes = {}, {}, []
    for line in text.splitlines():
        line = line.strip()
        if not line or line.startswith(";"):
            continue
        if line.startswith("include "):
            include_file = line[8:].strip()
            includes.append(include_file)
        elif line.startswith("def "):
            parts = line[4:].split()
            name = parts[0]
            defs[name] = {}
        elif line.startswith("voice "):
            l, _, r = line.partition("/")
            name = l.split()[1].strip()
            body = r.strip().strip('" ')
            voices[name] = body
    return defs, voices, includes
'''
    
    executor_py = (project_root / "scripts" / "opic_executor.py").read_text()
    
    # Create embedded data (use base64 for binary safety)
    ops_files_b64 = base64.b64encode(json.dumps(ops_files).encode()).decode()
    generate_py_b64 = base64.b64encode(generate_py.encode()).decode()
    executor_py_b64 = base64.b64encode(executor_py.encode()).decode()
    
    # Generate binary code
    binary_code = f'''#!/usr/bin/env python3
"""
opic Standalone Binary — Self-contained opic with all .ops files embedded
Generated by opic_compile_binary.ops
All .ops files are embedded in this binary - no external files needed!
"""

import sys
import json
import base64
from pathlib import Path
from typing import Dict, Any, Optional, List
import importlib.util
import tempfile
import os

# Embedded .ops files (base64 encoded)
EMBEDDED_OPS_FILES_B64 = {repr(ops_files_b64)}

# Embedded generate.py (base64 encoded)
EMBEDDED_GENERATE_PY_B64 = {repr(generate_py_b64)}

# Embedded opic_executor.py (base64 encoded)
EMBEDDED_EXECUTOR_PY_B64 = {repr(executor_py_b64)}

def decode_embedded_data(b64_data: str) -> str:
    """Decode base64 embedded data"""
    return base64.b64decode(b64_data).decode('utf-8')

class EmbeddedOpicExecutor:
    """Opic executor using embedded .ops files - fully self-contained"""
    
    def __init__(self):
        # Decode embedded data
        self.ops_files = json.loads(decode_embedded_data(EMBEDDED_OPS_FILES_B64))
        self.generate_py = decode_embedded_data(EMBEDDED_GENERATE_PY_B64)
        self.executor_py = decode_embedded_data(EMBEDDED_EXECUTOR_PY_B64)
        
        # Create temporary project root for executor
        self.temp_root = Path(tempfile.mkdtemp(prefix="opic_embedded_"))
        self.project_root = self.temp_root
        
        # Write embedded files to temp directory
        self._write_embedded_files()
        
        # Initialize executor
        self._init_executor()
    
    def _write_embedded_files(self):
        """Write embedded .ops files to temp directory"""
        # Create directory structure
        (self.temp_root / "core").mkdir(exist_ok=True)
        (self.temp_root / "systems").mkdir(exist_ok=True)
        
        # Write all .ops files
        for path, content in self.ops_files.items():
            file_path = self.temp_root / path
            file_path.parent.mkdir(parents=True, exist_ok=True)
            file_path.write_text(content)
        
        # Write generate.py
        (self.temp_root / "generate.py").write_text(self.generate_py)
        
        # Write opic_executor.py
        (self.temp_root / "scripts").mkdir(exist_ok=True)
        (self.temp_root / "scripts" / "opic_executor.py").write_text(self.executor_py)
    
    def _init_executor(self):
        """Initialize OpicExecutor from embedded code"""
        sys.path.insert(0, str(self.temp_root))
        sys.path.insert(0, str(self.temp_root / "scripts"))
        
        # Load executor module
        import importlib.util
        executor_path = self.temp_root / "scripts" / "opic_executor.py"
        spec = importlib.util.spec_from_file_location("opic_executor", executor_path)
        executor_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(executor_module)
        
        self.OpicExecutor = executor_module.OpicExecutor
        self.executor = self.OpicExecutor(self.temp_root)
    
    def execute_voice(self, voice_name: str, inputs: Dict[str, Any] = None):
        """Execute a voice"""
        return self.executor.execute_voice(voice_name, inputs)
    
    def _load_ops_file(self, ops_file: str):
        """Load an .ops file"""
        # Find file in embedded data
        for path, content in self.ops_files.items():
            if path.endswith(ops_file) or path == ops_file:
                file_path = self.temp_root / path
                self.executor._load_ops_file(file_path)
                return
        # Try loading from temp directory
        file_path = self.temp_root / ops_file
        if file_path.exists():
            self.executor._load_ops_file(file_path)
    
    def cleanup(self):
        """Clean up temporary files"""
        import shutil
        if self.temp_root.exists():
            shutil.rmtree(self.temp_root)

def main():
    """CLI entry point"""
    executor = EmbeddedOpicExecutor()
    
    try:
        if len(sys.argv) < 2:
            # Try to execute help or default
            executor.execute_voice("main")
            return
        
        command = sys.argv[1]
        
        # Route commands
        if command == "execute" and len(sys.argv) > 2:
            ops_file = sys.argv[2]
            executor._load_ops_file(ops_file)
            executor.execute_voice("main")
        elif command.endswith(".ops"):
            executor._load_ops_file(command)
            executor.execute_voice("main")
        elif command in executor.executor.voices:
            result = executor.execute_voice(command)
            if result:
                print(result)
        else:
            # Try loading as .ops file
            ops_file = f"{{command}}.ops"
            executor._load_ops_file(ops_file)
            if "main" in executor.executor.voices:
                executor.execute_voice("main")
            else:
                print(f"Unknown command: {{command}}", file=sys.stderr)
                sys.exit(1)
    finally:
        executor.cleanup()

if __name__ == "__main__":
    main()
'''
    
    # Write binary
    output_path.write_text(binary_code)
    output_path.chmod(0o755)
    
    size_mb = len(binary_code) / 1024 / 1024
    print(f"\n✓ Created standalone binary: {output_path}")
    print(f"  Embedded {len(ops_files)} .ops files")
    print(f"  Size: {size_mb:.2f} MB")
    print(f"\n  Run: ./opic_binary hello")

if __name__ == "__main__":
    project_root = Path(__file__).parent.parent
    output_path = project_root / "opic_binary"
    
    create_standalone_binary(project_root, output_path)

