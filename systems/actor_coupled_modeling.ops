;;; actor_coupled_modeling.ops — Actor Coupled Modeling: The Base Abstraction
;;; 
;;; Layer 0: Actor Coupled Modeling 
;;; Actors • state • morphisms • consequences • iteration
;;;
;;; This is the primordial OPIC layer—the foundation under everything.
;;; TON, git, zeta, Feigenbaum are all witness systems layered on top.
;;;
;;; Actor Coupled Modeling (ACM) is defined by:
;;;   1. A state S_t
;;;   2. An actor A with a morphism F_A: S_t → S_{t+1}
;;;   3. A consequence graph tracking causal edges
;;;   4. A control parameter r shaping behavior
;;;   5. A metric functional M(S_t) observing outcomes
;;;   6. Iteration: S_{t+1} = F_A(S_t; r)
;;;   7. Regime classification (fixed, periodic, chaotic)
;;;   8. Critical geometry (α–δ scaling)
;;;   9. Universality embedding (zeta-trace or field curvature)
;;;  10. Version-evolution (git or equivalent DAG)

include systems/00_core/compositor.ops

;; ============================================================================
;; ACTOR COUPLED MODELING: The Primitive
;; ============================================================================

;; Actor Coupled Model: the base abstraction
;; An actor that:
;;   • has state
;;   • receives inputs
;;   • emits outputs
;;   • transforms itself through time
;;   • participates in a network of consequences
def actor_coupled_model {
  actor,              ;; Actor A with morphism F_A: S_t → S_{t+1}
  state,              ;; Current state S_t
  causal_graph,  ;; Causal edges tracking consequences
  control_parameter, ;; Parameter r (scalar or vector) shaping behavior
  metric_functional, ;; Metric M(S_t) observing outcomes
  iteration_count,   ;; Time step t
  mass: 10           ;; Ionic mass (conservation in reactions)
}

;; Actor: the primitive unit of behavior
;; This is OPIC's "voice", Smalltalk's "object", Erlang's "actor", TON's "contract"
def actor {
  morphism,          ;; F_A: S_t → S_{t+1} (state transformer)
  signature,        ;; Invariant signature (domain/codomain)
  energy_coupling,  ;; Connection to other actors
  behavior,         ;; Compositional behavior
  charge: 0         ;; Ionic charge (+ emit, - absorb, 0 neutral)
}

;; Actor morphism: F_A(S_t; r) → S_{t+1}
;; The core transformation: state + control parameter → new state
voice actor.morphism / {
  actor + state + control_parameter ->
  apply_morphism ->
  new_state
}

;; Iteration: S_{t+1} = F_A(S_t; r)
voice actor_coupled_model.iterate / {
  actor_coupled_model ->
  extract_actor ->
  extract_state ->
  extract_control_parameter ->
  actor.morphism ->
  update_state ->
  update_causal_graph ->
  increment_iteration ->
  updated_model
}

;; Time as first-class: extract iteration count
voice actor_coupled_model.time / {
  actor_coupled_model ->
  extract_iteration_count ->
  iteration_count
}

;; Extract iteration count
voice extract_iteration_count / {
  actor_coupled_model ->
  get_iteration_count ->
  iteration_count
}

;; ============================================================================
;; CAUSAL GRAPH: Tracking Causal Edges
;; ============================================================================

;; Causal graph: tracks causal relationships between states
;; Each edge represents: state_t → state_{t+1} (caused by actor morphism)
def causal_graph {
  nodes,             ;; States S_t
  edges,            ;; Causal edges (state_t, actor, state_{t+1})
  causal_chain,     ;; Full causal history
  mass: 5           ;; Ionic mass (graph structure weight)
}

;; Add causal edge: state_t → state_{t+1}
voice causal_graph.add_edge / {
  causal_graph + state_t + actor + state_t_plus_1 ->
  create_edge ->
  add_to_graph ->
  updated_graph
}

;; Extract causal chain: full history of causal relationships
voice causal_graph.extract_chain / {
  causal_graph ->
  traverse_edges ->
  build_causal_chain ->
  causal_chain
}

;; ============================================================================
;; METRIC FUNCTIONAL: Observing Outcomes
;; ============================================================================

;; Metric functional: M(S_t) → scalar
;; Observes outcomes, produces measurable scalar
voice metric_functional.apply / {
  metric_functional + state ->
  observe_state ->
  compute_scalar ->
  observable
}

;; Common metrics
voice metric.total_supply / {
  state ->
  extract_total_supply ->
  total_supply
}

voice metric.entropy / {
  state ->
  compute_entropy ->
  entropy_value
}

voice metric.curvature / {
  state ->
  compute_field_curvature ->
  curvature_value
}

;; ============================================================================
;; REGIME: The Shape of Being
;; ============================================================================

;; Regime: the geometric identity of an observable sequence
;; Not what it does, but what it is—the manifold shape it occupies
;; A regime is a property that exists, not something we detect
def regime {
  type,              ;; "fixed" | "period_2" | "period_4" | ... | "chaotic" | "unknown"
  period,           ;; Period if periodic (the cycle's geometric structure)
  values,           ;; Cycle values if periodic (the attractor's position)
  fixed_value,      ;; Fixed point value if type == "fixed" (the equilibrium's location)
  width,            ;; Attractor width if periodic (the basin's geometry)
  variance,         ;; Variance of observable sequence (the spread's measure)
  lyapunov_exponent, ;; Lyapunov exponent (the curvature's sign: positive → chaos)
  mass: 3,          ;; Ionic mass (regime stability weight)
  charge: 0         ;; Ionic charge (neutral - regime is observed, not emitted)
}

;; Regime is not classified—it is revealed
;; The observable sequence already contains its regime identity
;; We uncover what already is by computing the sequence's geometric properties
voice regime.reveal / {
  observable_sequence + epsilon ->
  variance_of_sequence ->
  autocorrelation_of_sequence ->
  period_of_sequence ->
  lyapunov_of_sequence ->
  regime_from_properties ->
  regime
}

;; Variance: the spread property of the sequence
;; Not computed—it is a property that exists in the sequence's structure
voice variance_of_sequence / {
  observable_sequence ->
  mean_of_sequence ->
  squared_deviations_from_mean ->
  average_of_deviations ->
  variance
}

;; Autocorrelation: the self-similarity property of the sequence
;; The sequence's relationship to itself across time
voice autocorrelation_of_sequence / {
  observable_sequence ->
  centered_sequence ->
  self_correlation_at_lags ->
  autocorrelation
}

;; Period: the cycle structure property
;; Not detected—it is the geometric repetition already present
voice period_of_sequence / {
  autocorrelation ->
  peaks_in_correlation ->
  distance_between_peaks ->
  period
}

;; Lyapunov exponent: the curvature property
;; The sequence's sensitivity is a geometric feature, not a behavior
voice lyapunov_of_sequence / {
  observable_sequence ->
  divergence_rate_in_sequence ->
  lyapunov_exponent
}

;; Regime from properties: the shape emerges from what is
;; The regime type is not chosen—it is the identity revealed by the properties
;; Priority: chaos (positive curvature) > periodic (cycle structure) > fixed (equilibrium) > unknown
voice regime_from_properties / {
  variance + period + lyapunov_exponent + observable_sequence + epsilon ->
  type_from_geometric_properties ->
  properties_from_type ->
  regime
}

;; Type from geometric properties: the identity is already present
;; The type is not determined—it is the shape the properties reveal
voice type_from_geometric_properties / {
  variance + period + lyapunov_exponent + epsilon ->
  chaos_from_curvature ->
  periodic_from_cycle ->
  fixed_from_equilibrium ->
  type_by_priority ->
  regime_type
}

;; Chaos from curvature: positive Lyapunov is the geometric identity
voice chaos_from_curvature / {
  lyapunov_exponent ->
  curvature_is_positive ->
  type_chaotic
}

;; Periodic from cycle: period structure is the geometric identity
voice periodic_from_cycle / {
  period ->
  cycle_structure_exists ->
  type_periodic
}

;; Fixed from equilibrium: low variance is the geometric identity
voice fixed_from_equilibrium / {
  variance + epsilon ->
  spread_is_below_threshold ->
  type_fixed
}

;; Select type by priority: chaos > periodic > fixed > unknown
;; Declarative: type determined by boolean flags with priority ordering
voice select_type_by_priority / {
  type_chaotic + type_periodic + type_fixed + period ->
  extract_priority_flags ->
  select_by_priority_flags ->
  regime_type
}

;; Extract priority flags as booleans
voice extract_priority_flags / {
  type_chaotic + type_periodic + type_fixed ->
  chaos_flag ->
  periodic_flag ->
  fixed_flag ->
  priority_flags
}

;; Chaos flag: true if type_chaotic is determined
voice chaos_flag / {
  type_chaotic ->
  is_chaotic_flag
}

;; Periodic flag: true if type_periodic is determined
voice periodic_flag / {
  type_periodic ->
  is_periodic_flag
}

;; Fixed flag: true if type_fixed is determined
voice fixed_flag / {
  type_fixed ->
  is_fixed_flag
}

;; Select by priority flags: chaos > periodic > fixed > unknown
voice select_by_priority_flags / {
  is_chaotic_flag + is_periodic_flag + is_fixed_flag + period ->
  select_chaos_if_true ->
  select_periodic_if_true ->
  select_fixed_if_true ->
  select_unknown_otherwise ->
  regime_type
}

;; Select chaos type if flag is true
voice select_chaos_if_true / {
  is_chaotic_flag ->
  "chaotic"
}

;; Select periodic type if flag is true
voice select_periodic_if_true / {
  is_periodic_flag + period ->
  "period_" + period
}

;; Select fixed type if flag is true
voice select_fixed_if_true / {
  is_fixed_flag ->
  "fixed"
}

;; Select unknown type if no flags are true
voice select_unknown_otherwise / {
  is_chaotic_flag + is_periodic_flag + is_fixed_flag ->
  all_flags_false ->
  "unknown"
}

;; Properties from type: the geometric features that exist
;; Not extracted—they are the structure already present in the sequence
voice properties_from_type / {
  regime_type + observable_sequence + period + type_fixed + type_periodic ->
  equilibrium_position ->
  cycle_structure ->
  attractor_geometry ->
  regime_properties
}

;; Equilibrium position: the fixed point's location in state space
;; Not computed—it is where the sequence naturally rests
voice equilibrium_position / {
  observable_sequence + type_fixed ->
  mean_of_sequence ->
  fixed_value
}

;; Cycle structure: the periodic orbit's values
;; Not extracted—they are the cycle's geometric positions
voice cycle_structure / {
  observable_sequence + period + type_periodic ->
  sequence_partitioned_by_period ->
  unique_values_in_cycle ->
  values
}

;; Attractor geometry: the basin's width
;; Not computed—it is the attractor's spatial extent
voice attractor_geometry / {
  values ->
  maximum_in_cycle ->
  minimum_in_cycle ->
  difference_between_extrema ->
  width
}

;; ============================================================================
;; CRITICAL GEOMETRY: α–δ Scaling
;; ============================================================================

;; Critical geometry: Feigenbaum α–δ scaling
;; Characterizes universality class of actor behavior
def critical_geometry {
  alpha,             ;; Domain scaling factor (state space)
  delta,             ;; Parameter-space convergence rate
  universality_class, ;; Universality class identifier
  mass: 7            ;; Ionic mass (critical point weight - Feigenbaum trace7)
}

;; Extract critical geometry from regime sequence
voice critical_geometry.extract / {
  regime_sequence ->
  extract_bifurcation_points ->
  estimate_delta ->
  estimate_alpha ->
  classify_universality ->
  critical_geometry
}

;; ============================================================================
;; WITNESS SYSTEMS: Different Ways the Universe Remembers
;; ============================================================================

;; Witness system: a way of recording consequences
;; Different instantiations:
;;   • Git DAG (historical witness)
;;   • Ledger (like TON, global witness)
;;   • Semantic webs (tiddlers, semantic witness)
;;   • OPIC field (compositional witness)
;;   • Zeta curvature (harmonic witness)
;;   • Feigenbaum scaling (critical witness)

;; Witness interface: record consequence
voice witness.record / {
  witness_system + actor_coupled_model + state ->
  encode_consequence ->
  store_witness ->
  witness_record
}

;; Git witness: historical DAG
voice witness.git / {
  actor_coupled_model + state ->
  create_commit ->
  add_to_dag ->
  git_witness
}

;; Ledger witness: global chain (like TON)
voice witness.ledger / {
  actor_coupled_model + state ->
  create_transaction ->
  add_to_chain ->
  ledger_witness
}

;; Semantic witness: tiddler web
voice witness.semantic / {
  actor_coupled_model + state ->
  create_tiddler ->
  add_to_web ->
  semantic_witness
}

;; Compositional witness: OPIC field
voice witness.compositional / {
  actor_coupled_model + state ->
  create_voice ->
  add_to_field ->
  compositional_witness
}

;; Harmonic witness: zeta curvature
voice witness.harmonic / {
  actor_coupled_model + state ->
  compute_zeta_curvature ->
  add_to_spectrum ->
  harmonic_witness
}

;; Critical witness: Feigenbaum scaling
voice witness.critical / {
  actor_coupled_model + state ->
  compute_feigenbaum_coordinates ->
  add_to_atlas ->
  critical_witness
}

;; ============================================================================
;; VERSION EVOLUTION: DAG of Actor States
;; ============================================================================

;; Version: a snapshot of actor state at a point in time
def version {
  state,             ;; State S_t
  actor,             ;; Actor A
  control_parameter, ;; Parameter r (scalar or vector)
  timestamp,         ;; Time t
  parent_versions,   ;; Previous versions (DAG structure)
  critical_geometry, ;; Critical geometry (α–δ coordinates, zeta curvature, etc.)
  mass: 4,           ;; Ionic mass (version weight)
  charge: -1         ;; Ionic charge (negative - absorbs/records state)
}

;; Evolve version: create new version from parent
voice version.evolve / {
  version + new_actor_morphism + new_control_parameter ->
  apply_morphism ->
  create_new_version ->
  link_to_parent ->
  new_version
}

;; Merge versions: compose two version histories
;; Declarative: compatibility is a property, not a conditional
voice version.merge / {
  version1 + version2 ->
  compute_compatibility ->
  compatibility_property ->
  compose_histories ->
  merged_version
}

;; Compute compatibility property
;; Declarative: compatibility is a measured property, not a conditional
voice compute_compatibility / {
  version1 + version2 ->
  compare_actors ->
  compare_states ->
  compare_control_parameters ->
  compute_compatibility_score ->
  compute_critical_distance ->
  construct_compatibility_property ->
  compatibility_property
}

;; Compute critical distance (Feigenbaum-space or other geometry)
voice compute_critical_distance / {
  version1 + version2 ->
  extract_critical_geometry1 ->
  extract_critical_geometry2 ->
  compute_geometry_distance ->
  critical_distance
}

;; Construct compatibility property from computed values
voice construct_compatibility_property / {
  score + compatible + conflicts + critical_distance ->
  create_compatibility_property ->
  compatibility_property
}

;; Compatibility property: score indicating merge feasibility
;; Declarative: mergeability is a measured property of two histories, not a yes/no imperative
def compatibility_property {
  score,             ;; Compatibility score (0-1)
  compatible,        ;; Boolean: compatible if score > threshold
  conflicts,         ;; List of conflicts if not compatible
  critical_distance, ;; Distance in α–δ or other critical geometry (Feigenbaum-space)
  mass: 2,           ;; Ionic mass (property weight)
  charge: 0          ;; Ionic charge (neutral - property is measured, not emitted)
}

;; ============================================================================
;; IONIC STOICHIOMETRY: Conservation of Mass×Charge
;; ============================================================================

;; Stoichiometry: conservation rule for ionic types
;; Σ(input.mass × input.charge) = Σ(output.mass × output.charge)
voice stoichiometry.check / {
  inputs + outputs ->
  compute_input_mass_charge ->
  compute_output_mass_charge ->
  compare_mass_charge ->
  balanced
}

;; Compute input mass×charge product
voice compute_input_mass_charge / {
  inputs ->
  extract_mass ->
  extract_charge ->
  multiply_mass_charge ->
  sum_products ->
  total_input_mass_charge
}

;; Compute output mass×charge product
voice compute_output_mass_charge / {
  outputs ->
  extract_mass ->
  extract_charge ->
  multiply_mass_charge ->
  sum_products ->
  total_output_mass_charge
}

;; Compare mass×charge totals
voice compare_mass_charge / {
  total_input_mass_charge + total_output_mass_charge ->
  compute_difference ->
  within_tolerance ->
  balanced
}

;; ============================================================================
;; ACTOR COUPLED CALCULUS: OPIC's True Foundation
;; ============================================================================

;; OPIC is literally an actor coupled calculus:
;; voices transforming voices through composition,
;; preserving invariants while transmitting energy and meaning

;; Compose actor coupled models
voice actor_coupled_model.compose / {
  acm1 + acm2 ->
  compose_actors ->
  merge_states ->
  combine_causal_graphs ->
  stoichiometry.check ->
  composed_model
}

;; Preserve invariants during composition
voice actor_coupled_model.preserve_invariants / {
  acm1 + acm2 ->
  extract_invariants ->
  verify_compatibility ->
  preserve_structure ->
  invariant_preserved
}

;; Transmit energy between models
voice actor_coupled_model.transmit_energy / {
  acm1 + acm2 ->
  extract_energy ->
  compute_coupling ->
  transmit ->
  energy_transmitted
}

target actor_coupled_modeling / "actor_coupled_modeling_base"
voice main / {
  actor.morphism +
  actor_coupled_model.iterate +
  regime.reveal +
  critical_geometry.extract +
  witness.record +
  version.evolve +
  actor_coupled_model.compose ->
  actor_coupled_modeling
}

