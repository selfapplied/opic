;;; opic_phase_flux.ops — Angular velocity as radian emission: phase flux

include systems/opic_mode7_lab.ops

;; Angular velocity ω = dθ/dt: radian emission
;; Measures how quickly system broadcasts orientation state into world
voice compute.angular.velocity / {
  theta + time -> 
  compute.dtheta.dt -> 
  angular_velocity
}

;; Constant ω: uniform angular "light"
voice detect.uniform.emission / {
  angular_velocity + time -> 
  check.constant -> 
  compute.uniformity -> 
  uniform_emission
}

;; Varying ω: modulated phase-coded signal
voice detect.modulated.emission / {
  angular_velocity + time -> 
  check.variation -> 
  compute.modulation -> 
  modulated_signal
}

;; Integrating ω over time recovers total angle
;; Just as integrating frequency gives total phase shift
voice integrate.angular.velocity / {
  angular_velocity + time -> 
  integrate.over.time -> 
  total_angle
}

;; Angular velocity as flux of phase: local derivative of rotation
voice compute.phase.flux / {
  rotation_field + time -> 
  compute.local.derivative -> 
  phase_flux
}

;; Three fluxes in OPIC framework:
;; linear velocity → translation (energy flux)
;; angular velocity → rotation (phase flux)
;; voice rate → informational flux
voice compute.three.fluxes / {
  linear_velocity + angular_velocity + voice_rate -> 
  compute.energy.flux -> 
  compute.phase.flux -> 
  compute.informational.flux -> 
  three_fluxes
}

;; Distributed intelligence: constellation of emitters
;; Each spinning out local phase
voice compute.emitter.constellation / {
  emitters + angular_velocities + phases -> 
  compute.local.phases -> 
  compute.constellation -> 
  emitter_constellation
}

;; Coherence: keeping angular velocities locked in ratio
;; That's how the dance stays visible
voice detect.coherence / {
  angular_velocities + ratios -> 
  check.locked.ratios -> 
  compute.coherence -> 
  coherence
}

;; Angular velocity feels like "radian emission"
;; Measures how quickly system broadcasts orientation state
voice compute.radian.emission / {
  angular_velocity + orientation_state -> 
  compute.emission.rate -> 
  radian_emission
}

target opic_phase_flux / "phase_flux"
voice main / { compute.angular.velocity + compute.phase.flux + compute.three.fluxes + detect.coherence + compute.radian.emission -> opic_phase_flux }

