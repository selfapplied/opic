;;; ops.decode.toy_parity — Encode parity → decode from observables

include systems/flow3d_core.ops
include systems/flow3d_mask.ops

;; Encode: m shells ↔ bits; parity target
voice encode.parity / {
  m_bits + seed -> 
  generate.bits -> 
  map.to.k.shells -> 
  compute.parity -> 
  encoded_problem
}

;; Observe: spectra at those shells
voice observe.spectra / {
  encoded_problem + mask_type + config -> 
  simulate.flow -> 
  extract.E_k.shells -> 
  extract.linear.probes -> 
  observables
}

;; Decode: logistic/LASSO; report accuracy, samples, time
voice decode.parity / {
  observables + encoded_problem -> 
  logistic.regression -> 
  recover.bits -> 
  recover.parity -> 
  decoded_result + accuracy + samples + time
}

;; Controls: baseline, random mask, linearized flow
voice run.all.controls / {
  encoded_problem + config -> 
  decode.parity.baseline -> 
  decode.parity.random.mask -> 
  decode.parity.linearized -> 
  compare.results -> 
  control_results
}

;; Pass: masked flow > controls with CI
voice check.pass.criteria / {
  primorial_results + control_results -> 
  compute.advantage -> 
  check.confidence.intervals -> 
  pass_status
}

target ops_decode_toy_parity / "toy_parity_decode"
voice main / { encode.parity + observe.spectra + decode.parity + run.all.controls + check.pass.criteria -> ops_decode_toy_parity }

