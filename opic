#!.venv/bin/python
"""Opic CLI â€” Minimal Python shim - opic executes itself via .ops files"""

import sys
from pathlib import Path

def find_project_root():
    """Find opic installation root"""
    script_dir = Path(__file__).parent
    
    # Check if we're in development mode (script is in project root)
    if (script_dir / "generate.py").exists() and (script_dir / "scripts" / "opic_executor.py").exists():
        return script_dir
    
    # Check system installation locations (installed mode)
    for path in [
        Path("/usr/local/share/opic"),
        Path("/usr/share/opic"),
        Path.home() / ".local" / "share" / "opic",
    ]:
        if (path / "scripts" / "opic_executor.py").exists():
            return path
    
    # Fallback: try script directory even if generate.py missing
    if (script_dir / "scripts" / "opic_executor.py").exists():
        return script_dir
    
    # Last resort: return script directory
    return script_dir

def execute_opic(ops_file):
    """Execute opic file - delegates to opic_executor"""
    project_root = find_project_root()
    sys.path.insert(0, str(project_root))
    sys.path.insert(0, str(project_root / "scripts"))
    
    import importlib.util
    # Try scripts directory first, then fallback to project root
    executor_path = project_root / "scripts" / "opic_executor.py"
    if not executor_path.exists():
        executor_path = Path(__file__).parent / "scripts" / "opic_executor.py"
    if not executor_path.exists():
        print(f"Error: opic_executor.py not found", file=sys.stderr)
        sys.exit(1)
    
    spec = importlib.util.spec_from_file_location("opic_executor", executor_path)
    opic_executor = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(opic_executor)
    OpicExecutor = opic_executor.OpicExecutor
    
    executor = OpicExecutor(project_root)
    
    # Resolve ops file path
    ops_path = Path(ops_file)
    if not ops_path.is_absolute():
        if (Path.cwd() / ops_file).exists():
            ops_path = Path.cwd() / ops_file
        else:
            ops_path = project_root / ops_file
    
    if not ops_path.exists():
        print(f"Error: File not found: {ops_file}", file=sys.stderr)
        sys.exit(1)
    
    # Load the ops file
    executor._load_ops_file(ops_path)
    
    # Execute main voice if it exists
    if "main" in executor.voices:
        main_voice = executor.voices["main"]
        if isinstance(main_voice, str) and main_voice.startswith("{") and main_voice.endswith("}"):
            result = executor._execute_opic_chain(main_voice)
            if result:
                print(result)
        else:
            print(main_voice)
    else:
        print(f"Loaded {len(executor.voices)} voices from {ops_path.name}")

def main():
    """CLI entry point"""
    if len(sys.argv) < 2:
        execute_opic("opic_help.ops")
        return
    
    command = sys.argv[1]
    project_root = find_project_root()
    
    # Route commands to .ops files
    command_map = {
        "execute": sys.argv[2] if len(sys.argv) > 2 else None,
        "eval": sys.argv[2] if len(sys.argv) > 2 else None,
        "repos": "repos.ops",
        "test": "runtime_test.ops",
        "compile": "opic_compile.ops",
        "plan": "opic_plan.ops",
        "bootstrap": "bootstrap.ops",
        "help": "opic_help.ops",
    }
    
    if command in command_map:
        ops_file = command_map[command]
        if not ops_file:
            print(f"Error: {command} requires an argument", file=sys.stderr)
            sys.exit(1)
        execute_opic(ops_file)
    else:
        # Try <command>.ops file
        ops_file = project_root / f"{command}.ops"
        if ops_file.exists():
            execute_opic(str(ops_file))
        else:
            print(f"Unknown command: {command}", file=sys.stderr)
            execute_opic("opic_help.ops")
            sys.exit(1)

if __name__ == "__main__":
    main()
