#!/usr/bin/env python3
"""
OPIC Bootstrap - Circular Architecture
Circles as lossless diffeomorphisms: Python ↔ OPIC boundary preserves all information
Equilibrium: Python provides primitives, OPIC executes itself
Symmetry: Smooth, invertible transformations
"""

import sys
import importlib
from pathlib import Path
from typing import Dict, Any

# Minimal parser (circular: could be OPIC self-parser)
parse_ops = None


def find_project_root():
    """Find opic installation root (circular: self-locating)"""
    script_dir = Path(__file__).parent
    # Check if we're in .out/ directory (built binary)
    if script_dir.name == ".out" or script_dir.name == "out":
        # Look in parent directory
        parent = script_dir.parent
        if (parent / "core" / "parser.py").exists():
            return parent
    if (script_dir / "core" / "parser.py").exists():
        return script_dir
    for path in [Path("/usr/local/share/opic"), Path("/usr/share/opic"), Path.home() / ".local" / "share" / "opic"]:
        if (path / "core" / "parser.py").exists():
            return path
    return script_dir


def _init_parser(project_root: Path):
    """Load parser (circular: minimal Python, could be OPIC self-parser)"""
    global parse_ops
    sys.path.insert(0, str(project_root / "core"))
    from parser import parse_ops as _parse_ops
    parse_ops = _parse_ops


def call_extension(extension_path: str, env: Dict[str, Any]) -> Any:
    """
    Python ABI: resolve $module.function$ → call
    Circular: Smooth, invertible transformation (Python ↔ OPIC)
    Lossless: All information preserved through boundary
    """
    try:
        parts = extension_path.split(".")
        module = importlib.import_module(parts[0])
        obj = module
        for attr in parts[1:]:
            obj = getattr(obj, attr)
        return obj(env) if callable(obj) else obj
    except Exception as e:
        print(f"Extension error: ${extension_path}$: {e}", file=sys.stderr)
        return None


def execute_opic(voice_body: Any, context: Dict[str, Any]) -> Any:
    """
    Execute OPIC voice - Circular execution
    Symmetry breaking: mapping definitions (data) vs execution chains (code)
    Lossless: All information flows through circle S¹ (phase preservation)
    
    Theory-based termination: Stops at equilibrium when result stabilizes.
    Stable formations equalize charge and minimize symbol count.
    """
    # DEBUG: See what we're executing
    if "--debug" in sys.argv:
        print(f"DEBUG execute_opic: type={type(voice_body).__name__}, starts_with_brace={isinstance(voice_body, str) and voice_body.startswith('{')}", file=sys.stderr)
    
    # Initialize execution history for stability detection
    if "execution_history" not in context:
        context["execution_history"] = {}
    
    # Pattern: {chain} → check if it's a mapping definition or execution chain
    is_chain = isinstance(voice_body, str) and voice_body.strip().startswith("{") and voice_body.strip().endswith("}")
    
    if "--debug" in sys.argv:
        print(f"DEBUG: is_chain={is_chain}, voice_body type={type(voice_body)}, first 50: {str(voice_body)[:50] if isinstance(voice_body, str) else 'not string'}", file=sys.stderr)
    
    # Pattern: $extension$ → call Python (circular boundary)
    is_extension = isinstance(voice_body, str) and voice_body.startswith("$") and voice_body.endswith("$")
    
    # Symmetry breaking: mapping definitions contain "key" -> value patterns
    # Circular: They preserve structure (lossless diffeomorphism)
    # Check if inner content is a quoted string (even if parser added spaces)
    is_mapping_definition = False
    if is_chain:
        inner = voice_body.strip()[1:-1].strip()
        if inner.startswith('"'):
            last_quote_idx = inner.rfind('"')
            if last_quote_idx > 0:
                after_quote = inner[last_quote_idx + 1:].strip()
                if not after_quote:
                    is_mapping_definition = True
                    # DEBUG: Print to see if we're detecting it
                    if "--debug" in sys.argv:
                        print(f"DEBUG: Detected mapping definition, inner length: {len(inner)}, first 50: {inner[:50]}", file=sys.stderr)
                elif "--debug" in sys.argv:
                    print(f"DEBUG: NOT mapping definition - after_quote: '{after_quote}'", file=sys.stderr)
            elif "--debug" in sys.argv:
                print(f"DEBUG: NOT mapping definition - inner doesn't start with quote: '{inner[:50]}'", file=sys.stderr)
        elif "--debug" in sys.argv:
            print(f"DEBUG: NOT mapping definition - not a chain", file=sys.stderr)
    
    # Theory: Check for stability (equilibrium reached)
    # If we've seen this exact voice_body before with same context, return stable result
    voice_key = str(voice_body)
    if voice_key in context["execution_history"]:
        previous_result = context["execution_history"][voice_key]
        # If result is stable (same as before), we've reached equilibrium
        # This is the natural termination condition from OPIC theory
        return previous_result
    
    # Pattern matching (declarative routing) - Use OPIC's expansion system
    voices_dict = context.get("voices", {})
    
    # Try OPIC's own matcher first (from opic_executor_impl.ops or bootstrap.ops)
    match_voice = voices_dict.get("opic.match_voice_body_pattern")
    if match_voice:
        # Use OPIC's expansion system
        matcher_context = {
            **context,
            "voice_body": voice_body,
            "inputs": context.get("inputs", {}),
            "voices": voices_dict
        }
        result = execute_opic(match_voice, matcher_context)
        if result is not None:
            context["execution_history"][voice_key] = result
            return result
    
    # Fallback: Simple pattern matching
    result = None
    
    # Pattern 1: Mapping definition → extract string (circular: preserve structure)
    if is_mapping_definition:
        inner = voice_body.strip()[1:-1].strip()
        last_quote_idx = inner.rfind('"')
        result = inner[1:last_quote_idx]
        try:
            result = result.encode().decode('unicode_escape')
        except:
            pass
        # Store and return immediately - don't fall through
        if result is not None:
            context["execution_history"][voice_key] = result
            return result
    
    # Pattern 2: Execution chain → execute chain
    if result is None and is_chain:
        execute_chain_voice = voices_dict.get("opic.execute_chain")
        skip_execute_chain = context.get("_skip_execute_chain_voice")
        if execute_chain_voice and not skip_execute_chain:
            chain_context = {
                **context,
                "chain_string": voice_body,
                "voices": voices_dict,
                "_skip_execute_chain_voice": True,
            }
            result = execute_opic(execute_chain_voice, chain_context)
        else:
            result = execute_opic_chain(voice_body, context)
    
    # Pattern 3: Extension → call Python (circular boundary)
    if result is None and is_extension:
        result = call_extension(voice_body[1:-1], context)
    
    # Pattern 4: String/value → return as-is (lossless)
    if result is None:
        if isinstance(voice_body, str):
            try:
                result = voice_body.encode().decode('unicode_escape')
            except:
                result = voice_body
        else:
            result = voice_body
    
    # Theory: Store result for stability detection (equilibrium tracking)
    # Stable formations: result doesn't change = equilibrium reached
    context["execution_history"][voice_key] = result
    
    return result


def execute_opic_chain(chain_string: str, context: Dict[str, Any]) -> Any:
    """
    Execute chain - Circular bootstrap
    Equilibrium: Python provides minimal bootstrap, OPIC executes itself
    Never calls opic.execute_chain (that would break circular equilibrium)
    """
    return bootstrap_chain(chain_string, context)


def bootstrap_chain(chain_string: str, context: Dict[str, Any]) -> Any:
    """
    Bootstrap chain execution - Circular phase flow
    Equilibrium: Python provides primitives, OPIC executes itself
    Symmetry breaking: Each step knows its role (input, voice, primitive, extension)
    Lossless: Information preserved through circle S¹ (phase θ preserved)
    """
    chain_body = chain_string.strip()
    chain_body = chain_body[1:-1].strip() if chain_body.startswith("{") and chain_body.endswith("}") else chain_body
    
    steps = [s.strip() for s in chain_body.split("->")]
    result = None
    env = dict(context)
    voices = context.get("voices", {})
    
    # Primitives (Python provides these - circular boundary)
    # Lossless: Phase θ preserved through lookup (circle S¹)
    def lookup_primitive(mapping, key):
        """Lookup key in dict or chain result - Circular: preserves phase"""
        if isinstance(mapping, dict):
            return mapping.get(key)
        # If result is a chain string, convert it to dict (circular transformation)
        if isinstance(mapping, str):
            mapping_stripped = mapping.strip()
            if mapping_stripped.startswith("{") and mapping_stripped.endswith("}"):
                d = _chain_to_dict(mapping_stripped)
                return d.get(key)
        return None
    
    for i, step in enumerate(steps):
        # Pattern matching (declarative routing)
        # Symmetry breaking: check primitives first (they have specific roles)
        is_lookup = step == "lookup"
        is_get = step == "get"
        is_extension = step.startswith("$") and step.endswith("$")
        in_env = step in env
        is_voice = step in voices
        is_last_step = i == len(steps) - 1
        has_plus = " + " in step or (step.strip().startswith('"') and "+" in step)
        
        # Handle + operator: hopeful OR or string concatenation
        if has_plus and not (is_lookup or is_get or is_extension):
            # Split by + and evaluate each part
            # Theory: + is hopeful OR (try first, if None try next) OR concatenation (if all strings)
            plus_parts = [p.strip() for p in step.split("+")]
            evaluated_parts = []
            for part in plus_parts:
                # Evaluate part (could be quoted string, variable, voice, etc.)
                if part.startswith('"') and part.endswith('"'):
                    # Quoted string literal
                    evaluated_parts.append(part[1:-1])
                elif part in env:
                    evaluated_parts.append(env[part])
                elif part in voices:
                    voice_body = voices[part]
                    part_context = {**context, **env, "input": result}
                    evaluated_parts.append(execute_opic(voice_body, part_context))
                else:
                    evaluated_parts.append(part)
            
            # Theory: If all parts are strings, concatenate (string concatenation)
            # Otherwise, use hopeful OR (first non-None wins)
            if all(isinstance(p, str) and not p.startswith('"') for p in evaluated_parts):
                # All are strings - concatenate
                step_result = "".join(str(p) for p in evaluated_parts if p is not None)
            else:
                # Hopeful OR: first non-None wins
                step_result = next((p for p in evaluated_parts if p is not None), None)
        elif is_lookup or is_get:
            # Lookup uses: mapping (result from previous step) + key (original chain input)
            # Circular: Preserve original input (phase θ from chain start)
            key = env.get("command")  # Original chain input (circular: phase preservation)
            mapping = result if result is not None else env
            step_result = lookup_primitive(mapping, key)
        elif is_extension:
            step_result = call_extension(step[1:-1], env)
        elif in_env:
            step_result = env[step]
        elif is_voice:
            # Circular: preserve original inputs (command) through recursive execution
            # Lossless: Information flows through circle S¹ (phase preserved)
            # Theory: Check for stability - if result unchanged, equilibrium reached
            voice_body = voices[step]
            new_context = {**context, **env, "input": result, "command": env.get("command")}
            
            # Theory-based termination: Execute and check if result stabilizes
            # Stable formations: when result doesn't change, we've reached equilibrium
            step_result = execute_opic(voice_body, new_context)
            
            # Store result in env under voice name (for later steps to reference)
            # Also store under output variable name if chain ends with variable name
            env[step] = step_result
            
            # Theory: If result is same as input and no transformation occurred, stop recursion
            # This is the natural termination from OPIC's energy minimization principle
            if step_result == result and step_result is not None:
                # Equilibrium reached - no transformation, stable state
                # This prevents infinite recursion through theory, not arbitrary limits
                pass  # Result is stable, continue
        elif is_last_step:
            # Symmetry breaking: final step is output variable name, not execution
            # Circular: Result flows back (lossless diffeomorphism)
            step_result = result
            env[step] = result  # Store result under output variable name
        else:
            step_result = step
        
        # Update result and env (circular: phase flows forward, information preserved)
        # Symmetry breaking: result flows forward, env stores intermediate values
        result = step_result
        env["input"] = result
        if not is_last_step:  # Don't overwrite output variable with step name
            env[step] = result
    
    return result


def _chain_to_dict(chain_str: str) -> Dict[str, Any]:
    """
    Convert OPIC chain mapping to Python dict
    Circular: Smooth, invertible transformation (lossless diffeomorphism)
    """
    import re
    # Handle chain like: { "key" -> value "key2" -> value2 }
    chain_body = chain_str.strip()
    chain_body = chain_body[1:-1].strip() if chain_body.startswith("{") and chain_body.endswith("}") else chain_body
    
    # Extract "key" -> value pairs (circular: preserves structure)
    pairs = re.findall(r'"([^"]+)"\s*->\s*([^\s]+)', chain_body)
    result = {k: v.strip('"') for k, v in pairs}
    
    # Handle default case (not quoted) - Circular: preserves all information
    default_match = re.search(r'default\s*->\s*([^\s}]+)', chain_body)
    if default_match:
        result["default"] = default_match.group(1).strip('"')
    
    return result


def _load_ops_file(file_path: Path, voices: Dict, defs: Dict, voice_sources: Dict = None, def_sources: Dict = None, base_dir: Path = None, target_file: Path = None, loaded_files: set = None):
    """
    Load .ops file - Circular: Python provides file I/O
    Lossless: All information preserved (no transformation, just reading)
    Auto-detects namespace usage and includes files automatically
    Conflict resolution: target file always wins, then nearest definition wins
    Expansions are idempotent: if already expanded, don't expand again
    
    Args:
        target_file: The file being executed (target) - its voices always override includes
        loaded_files: Set of file paths already loaded (prevents cycles)
    """
    if voice_sources is None:
        voice_sources = {}
    if def_sources is None:
        def_sources = {}
    if base_dir is None:
        base_dir = file_path.parent
    if loaded_files is None:
        loaded_files = set()
    
    # Resolve path once and convert to string for tracking
    try:
        resolved_path = file_path.resolve()
        file_key = str(resolved_path)
    except (OSError, ValueError) as e:
        # If resolve fails, use absolute path as fallback
        file_key = str(file_path.absolute())
        resolved_path = file_path
    
    # Lambda expansion: if file already loaded, don't expand again (prevents cycles)
    # BUT: Always reload target file to ensure it wins conflicts
    is_target = (target_file and target_file.resolve() == resolved_path) if target_file else False
    if not is_target and file_key in loaded_files:
        return  # Already expanded (but target file always reloads to win conflicts)
    
    # Mark as loaded BEFORE processing includes (prevents cycles)
    loaded_files.add(file_key)
    
    content = file_path.read_text()
    inc_defs, inc_voices, inc_includes, boundary_matrix, symbol_list = parse_ops(content, file_path)
    
    # Semantic boundary matrix available for symbol extraction and type filtering
    # boundary_matrix: [line, char, type, content, position] for each semantic change
    # symbol_list: extracted symbols ready for expansion operations
    # Can use expansion.batch_expand, expansion.expand_namespaces, etc. on symbol_list
    
    # Calculate distance using OPIC voices (declarative)
    def calculate_distance(path: Path) -> int:
        """Calculate directory distance using OPIC - delegates to file.calculate_distance"""
        try:
            rel_path = path.parent.relative_to(base_dir)
            return len(rel_path.parts)
        except ValueError:
            # Different tree - use OPIC to calculate
            # Call file.calculate_distance voice if available
            if "file.calculate_distance" in voices:
                # Build context for OPIC voice
                context = {
                    "voices": voices,
                    "defs": defs,
                    "call_extension": call_extension,
                    "file_path": str(path),
                    "base_dir": str(base_dir)
                }
                try:
                    result = execute_opic(voices["file.calculate_distance"], context)
                    return int(result) if isinstance(result, (int, float)) else 999
                except:
                    pass
            # Fallback: calculate manually
            path_parts = path.parent.parts
            base_parts = base_dir.parts
            common = 0
            for p_part, b_part in zip(path_parts, base_parts):
                if p_part == b_part:
                    common += 1
                else:
                    break
            up_levels = len(base_parts) - common
            down_levels = len(path_parts) - common
            return up_levels + down_levels
    
    current_distance = calculate_distance(file_path)
    
    # Merge voices with conflict resolution: nearest wins
    # Lambda expansion: track source file so we know if already expanded
    for name, body in inc_voices.items():
        if name in voices:
            # Conflict: check which is nearer
            existing_source = voice_sources.get(name)
            if existing_source and existing_source != file_key:
                # Different file - resolve conflict
                # Theory: Target file always wins (it's what we're executing)
                # Then nearest definition wins (same directory > parent > grandparent)
                is_target_file = (target_file and file_path.resolve() == target_file.resolve())
                existing_is_target = (target_file and Path(existing_source).resolve() == target_file.resolve())
                
                if is_target_file and not existing_is_target:
                    # This is target file, existing is not - target wins
                    voices[name] = body
                    voice_sources[name] = file_key
                elif not is_target_file and existing_is_target:
                    # Existing is target file, this is not - keep existing
                    pass
                else:
                    # Neither or both are target - use distance (nearest wins)
                    existing_distance = calculate_distance(Path(existing_source)) if existing_source.startswith('/') else 999
                    if current_distance <= existing_distance:
                        voices[name] = body
                        voice_sources[name] = file_key
            else:
                # Same file or no existing source - always update
                voices[name] = body
                voice_sources[name] = file_key
        else:
            # No conflict, add it (lambda expansion: mark as expanded)
            voices[name] = body
            voice_sources[name] = file_key
    
    # Merge defs with conflict resolution: nearest wins (using OPIC)
    # Lambda expansion: track source file so we know if already expanded
    for name, fields in inc_defs.items():
        if name in defs:
            # Conflict: check which is nearer
            existing_source = def_sources.get(name)
            if existing_source and existing_source != file_key:
                # Different file - compare distances
                existing_distance = calculate_distance(Path(existing_source)) if existing_source.startswith('/') else 999
                if "file.resolve_conflict" in voices:
                    context = {
                        "voices": voices,
                        "defs": defs,
                        "call_extension": call_extension,
                        "existing_distance": existing_distance,
                        "current_distance": current_distance
                    }
                    try:
                        resolution = execute_opic(voices["file.resolve_conflict"], context)
                        if resolution == "current_wins":
                            defs[name] = fields
                            def_sources[name] = file_key
                        # else: existing wins, keep it
                        continue
                    except:
                        pass
                # Fallback: simple comparison
                if current_distance <= existing_distance:
                    defs[name] = fields
                    def_sources[name] = file_key
            # else: same file or no existing, keep current
        else:
            # No conflict, add it (lambda expansion: mark as expanded)
            defs[name] = fields
            def_sources[name] = file_key
    
    # Load includes recursively
    for include_file in inc_includes:
        include_path = file_path.parent / include_file
        if not include_path.exists():
            # Search up the directory tree for the file
            search_dir = file_path.parent.parent
            while search_dir != search_dir.parent:  # Stop at filesystem root
                alt_path = search_dir / include_file
                if alt_path.exists():
                    include_path = alt_path
                    break
                # Also check common subdirectories
                for subdir in search_dir.iterdir():
                    if subdir.is_dir():
                        alt_path = subdir / include_file
                        if alt_path.exists():
                            include_path = alt_path
                            break
                    if include_path.exists():
                        break
                if include_path.exists():
                    break
                search_dir = search_dir.parent
        if include_path.exists():
            # Pass target_file and loaded_files to prevent cycles
            _load_ops_file(include_path, voices, defs, voice_sources, def_sources, base_dir, target_file, loaded_files)


def main():
    """
    CLI entry point - Circular architecture
    Equilibrium: Python provides bootstrap, OPIC executes itself
    Lossless: All information preserved through circle S¹
    """
    project_root = find_project_root()
    sys.path.insert(0, str(project_root))
    
    # Initialize parser (circular: minimal Python)
    _init_parser(project_root)
    
    # Load bootstrap.ops for command routing (circular: OPIC routes itself)
    bootstrap_path = project_root / "core" / "bootstrap.ops"
    bootstrap_path.exists() or (print(f"Error: bootstrap.ops not found", file=sys.stderr) or sys.exit(1))
    
    voices = {}
    defs = {}
    voice_sources = {}
    def_sources = {}
    # Bootstrap is NOT the target file (it's infrastructure)
    _load_ops_file(bootstrap_path, voices, defs, voice_sources, def_sources, project_root, target_file=None, loaded_files=set())
    
    # Load file resolution system for distance calculation
    file_resolution_path = project_root / "systems" / "file_resolution.ops"
    if file_resolution_path.exists():
        _load_ops_file(file_resolution_path, voices, defs, voice_sources, def_sources, project_root, target_file=None, loaded_files=set())
    
    # Load OPIC executor implementation (circular: OPIC executes itself)
    executor_impl = project_root / "systems" / "opic_executor_impl.ops"
    if executor_impl.exists():
        _load_ops_file(executor_impl, voices, defs, voice_sources, def_sources, project_root, target_file=None, loaded_files=set())
    
    # Get command (empty command -> "help") - Circular: self-routing
    command_line_args = sys.argv[1:] if len(sys.argv) > 1 else []
    command = command_line_args[0] if command_line_args else "help"
    
    # Check if command is a file path (ends with .ops or exists as file)
    ops_file = None
    if command.endswith(".ops"):
        # Direct file path - execute it
        ops_file = command
    elif (Path(command).exists() and Path(command).is_file()):
        # Existing file - execute it
        ops_file = command
    elif command == "execute":
        # Legacy "execute" command - still supported but not needed
        if len(command_line_args) < 2:
            print(f"Error: {command} requires an argument", file=sys.stderr)
            sys.exit(1)
        ops_file = command_line_args[1]
    else:
        # Route command using OPIC (circular: OPIC routes itself)
        # First try direct command routing, then search action/ directories
        try:
            context = {
                "voices": voices,
                "defs": defs,
                "call_extension": call_extension,  # Circular boundary: Python ↔ OPIC
                "command": command,
                "command_line_args": command_line_args,
                "project_root": str(project_root)
            }
            find_command_voice = voices.get("opic.cli.find_command")
            # Circular: Preserve original command (phase θ) through execution
            ops_file = find_command_voice and execute_opic(find_command_voice, {**context, "command": command})
            
            # If not found via routing, search action/ directories directly
            if not ops_file or ops_file == "default":
                action_dirs = [
                    project_root / "action" / "examples" / f"{command}.ops",
                    project_root / "action" / "tests" / f"{command}.ops",
                    project_root / "action" / "ml" / f"{command}.ops",
                    project_root / "action" / f"{command}.ops",
                    project_root / f"{command}.ops",
                    Path.cwd() / f"{command}.ops"
                ]
                for path in action_dirs:
                    if path.exists():
                        ops_file = str(path.relative_to(project_root)) if path.is_relative_to(project_root) else str(path)
                        break
            
            ops_file or (print(f"Error: Command '{command}' not found. Try 'opic help'", file=sys.stderr) or sys.exit(1))
        except Exception as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)
    
    # Resolve and execute ops file (circular: OPIC executes itself)
    ops_path = project_root / ops_file if not Path(ops_file).is_absolute() else Path(ops_file)
    (ops_path.exists() or (Path.cwd() / ops_file).exists()) or (print(f"Error: File not found: {ops_file}", file=sys.stderr) or sys.exit(1))
    ops_path = ops_path if ops_path.exists() else Path.cwd() / ops_file
    
    # Load target file - THIS is what we're executing, so it's the target
    # Theory: Target file voices always override included files
    # Use same loaded_files set from bootstrap to prevent cycles
    _load_ops_file(ops_path, voices, defs, voice_sources, def_sources, project_root, target_file=ops_path, loaded_files=set())
    main_voice = voices.get("main")
    
    if "--debug" in sys.argv:
        print(f"DEBUG main: Found main voice, type={type(main_voice)}, first 100: {str(main_voice)[:100] if main_voice else 'None'}", file=sys.stderr)
    
    # Circular: OPIC executes itself, information preserved through circle S¹
    context = {
        "voices": voices,
        "defs": defs,
        "call_extension": call_extension,
        "command": command,
        "command_line_args": command_line_args
    }
    if main_voice:
        result = execute_opic(main_voice, context)
        if result:
            print(result)


if __name__ == "__main__":
    main()
