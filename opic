#!/usr/bin/env python3
"""
OPIC Bootstrap - Circular Architecture
Circles as lossless diffeomorphisms: Python ↔ OPIC boundary preserves all information
Equilibrium: Python provides primitives, OPIC executes itself
Symmetry: Smooth, invertible transformations
"""

import sys
import importlib
import importlib.util
from pathlib import Path
from typing import Dict, Any

# Minimal parser (circular: could be OPIC self-parser)
parse_ops = None


def find_project_root():
    """Find opic installation root (circular: self-locating)"""
    script_dir = Path(__file__).parent
    # Check if we're in .out/ directory (built binary)
    if script_dir.name == ".out" or script_dir.name == "out":
        # Look in parent directory
        parent = script_dir.parent
        if (parent / "core" / "parser.py").exists():
            return parent
    if (script_dir / "core" / "parser.py").exists():
        return script_dir
    for path in [Path("/usr/local/share/opic"), Path("/usr/share/opic"), Path.home() / ".local" / "share" / "opic"]:
        if (path / "core" / "parser.py").exists():
            return path
    return script_dir


def _init_parser(project_root: Path):
    """Load parser (circular: minimal Python, could be OPIC self-parser)"""
    global parse_ops
    sys.path.insert(0, str(project_root / "core"))
    from parser import parse_ops as _parse_ops
    parse_ops = _parse_ops


def call_extension(extension_path: str, env: Dict[str, Any]) -> Any:
    """
    Python ABI: resolve $module.function$ → call
    Circular: Smooth, invertible transformation (Python ↔ OPIC)
    Lossless: All information preserved through boundary
    
    Supports both absolute module paths (e.g., "sys.path") and repository-relative
    paths (e.g., "build.scripts.bi_l_ops") by adding project root to sys.path.
    """
    try:
        project_root = env.get("project_root")
        if project_root:
            project_root_path = Path(project_root)
            if str(project_root_path) not in sys.path:
                sys.path.insert(0, str(project_root_path))
        
        parts = extension_path.split(".")
        # Try repository-relative path first (e.g., "build/scripts/bi_l_ops.py")
        # For "build.scripts.bi_l_ops.run_sim", parts = ["build", "scripts", "bi_l_ops", "run_sim"]
        # We want: module_path = "build/scripts/bi_l_ops.py", func_name = "run_sim"
        if len(parts) >= 2:
            try:
                # Convert "build.scripts.bi_l_ops" -> "build/scripts/bi_l_ops.py"
                # Last part is function name, rest is module path
                func_name = parts[-1]
                module_parts = parts[:-1]
                
                # Try with project_root first if available
                if project_root:
                    rel_path = "/".join(module_parts) + ".py"
                    module_path = project_root_path / rel_path
                else:
                    # Fallback: try relative to current working directory
                    rel_path = "/".join(module_parts) + ".py"
                    module_path = Path.cwd() / rel_path
                
                if "--debug" in sys.argv:
                    print(f"DEBUG extension: trying path={module_path}, exists={module_path.exists()}", file=sys.stderr)
                
                if module_path.exists():
                    # Load as module from file
                    module_name = module_parts[-1]  # Use last part as module name
                    spec = importlib.util.spec_from_file_location(module_name, module_path)
                    if spec and spec.loader:
                        module = importlib.util.module_from_spec(spec)
                        spec.loader.exec_module(module)
                        # Get function from module
                        obj = getattr(module, func_name, None)
                        if obj and callable(obj):
                            if "--debug" in sys.argv:
                                print(f"DEBUG extension: found function {func_name} in {module_path}", file=sys.stderr)
                            return obj(env)
            except Exception as e:
                if "--debug" in sys.argv:
                    import traceback
                    print(f"DEBUG extension path resolution failed: {e}", file=sys.stderr)
                    traceback.print_exc(file=sys.stderr)
                pass
        
        # Fallback: try standard import
        module = importlib.import_module(parts[0])
        obj = module
        for attr in parts[1:]:
            obj = getattr(obj, attr)
        return obj(env) if callable(obj) else obj
    except Exception as e:
        print(f"Extension error: ${extension_path}$: {e}", file=sys.stderr)
        return None


def execute_opic(voice_body: Any, context: Dict[str, Any]) -> Any:
    """
    Execute OPIC voice - Expansion-based energetic coupled solver
    Symmetry breaking: mapping definitions (data) vs execution chains (code)
    Lossless: All information flows through circle S¹ (phase preservation)
    
    Theory-based termination: Stops at equilibrium when result stabilizes.
    Stable formations equalize charge and minimize symbol count.
    
    Energetic coupling: Only expand if free energy decreases.
    F(k) = E(k) + λ_comp·C(k); expand if F(k+1) < F(k) - ε
    """
    # DEBUG: See what we're executing
    if "--debug" in sys.argv:
        print(f"DEBUG execute_opic: type={type(voice_body).__name__}, starts_with_brace={isinstance(voice_body, str) and voice_body.startswith('{')}", file=sys.stderr)
    
    # Initialize execution history for stability detection
    if "execution_history" not in context:
        context["execution_history"] = {}
    
    # Initialize expansion depth/complexity tracking
    if "expansion_depth" not in context:
        context["expansion_depth"] = 0
    if "expansion_complexity" not in context:
        context["expansion_complexity"] = 0.0
    
    # Pattern: {chain} → check if it's a mapping definition or execution chain
    is_chain = isinstance(voice_body, str) and voice_body.strip().startswith("{") and voice_body.strip().endswith("}")
    
    if "--debug" in sys.argv:
        print(f"DEBUG: is_chain={is_chain}, voice_body type={type(voice_body)}, first 50: {str(voice_body)[:50] if isinstance(voice_body, str) else 'not string'}", file=sys.stderr)
    
    # Pattern: $extension$ → call Python (circular boundary)
    # Use default prefix without config lookup (avoid recursion)
    ext_prefix = "$"  # Default fallback
    # Check if voice_body is an extension string (starts and ends with prefix)
    is_extension = isinstance(voice_body, str) and len(voice_body) > 1 and voice_body.startswith(ext_prefix) and voice_body.endswith(ext_prefix)
    
    # Energetic coupling: If extension, execute immediately (no expansion cost)
    if is_extension:
        result = call_extension(voice_body[len(ext_prefix):-len(ext_prefix)], context)
        if result is not None:
            voice_key = str(voice_body)
            context["execution_history"][voice_key] = result
            return result
    
    # Symmetry breaking: mapping definitions contain "key" -> value patterns
    # Circular: They preserve structure (lossless diffeomorphism)
    # Check if inner content is a quoted string (even if parser added spaces)
    is_mapping_definition = False
    if is_chain:
        inner = voice_body.strip()[1:-1].strip()
        if inner.startswith('"'):
            last_quote_idx = inner.rfind('"')
            if last_quote_idx > 0:
                after_quote = inner[last_quote_idx + 1:].strip()
                if not after_quote:
                    is_mapping_definition = True
                    # DEBUG: Print to see if we're detecting it
                    if "--debug" in sys.argv:
                        print(f"DEBUG: Detected mapping definition, inner length: {len(inner)}, first 50: {inner[:50]}", file=sys.stderr)
                elif "--debug" in sys.argv:
                    print(f"DEBUG: NOT mapping definition - after_quote: '{after_quote}'", file=sys.stderr)
            elif "--debug" in sys.argv:
                print(f"DEBUG: NOT mapping definition - inner doesn't start with quote: '{inner[:50]}'", file=sys.stderr)
        elif "--debug" in sys.argv:
            print(f"DEBUG: NOT mapping definition - not a chain", file=sys.stderr)
    
    # Theory: Check for stability (equilibrium reached)
    # If we've seen this exact voice_body before with same context, return stable result
    voice_key = str(voice_body)
    if voice_key in context["execution_history"]:
        previous_result = context["execution_history"][voice_key]
        # If result is stable (same as before), we've reached equilibrium
        # This is the natural termination condition from OPIC theory
        return previous_result
    
    # Pattern matching (declarative routing) - Use OPIC's expansion system
    voices_dict = context.get("voices", {})
    
    # Energetic coupling: Calculate current free energy before expansion
    current_depth = context["expansion_depth"]
    current_complexity = context["expansion_complexity"]
    # E(k) = expansion depth (proxy for energy)
    # C(k) = complexity (symbol count, voice count, etc.)
    energy_k = float(current_depth)
    complexity_k = current_complexity + (len(str(voice_body)) * 0.001)  # Symbol count cost
    lambda_comp = context.get("opic.config.lambda_comp", 0.01)  # Complexity temperature
    epsilon = context.get("opic.config.epsilon", 0.001)  # Acceptance threshold
    free_energy_k = energy_k + lambda_comp * complexity_k
    
    # Calculate projected free energy if we expand
    projected_depth = current_depth + 1
    projected_complexity = complexity_k + (len(str(voice_body)) * 0.002)  # Expansion adds cost
    free_energy_k1 = float(projected_depth) + lambda_comp * projected_complexity
    
    # Metastable band check: don't expand past max depth
    max_depth = context.get("opic.config.max_expansion_depth", 100)
    in_metastable_band = current_depth < max_depth
    
    # Only expand if free energy decreases AND we're in metastable band
    should_expand = (free_energy_k1 < free_energy_k - epsilon) and in_metastable_band
    
    if "--debug" in sys.argv:
        print(f"DEBUG: depth={current_depth}, F(k)={free_energy_k:.6f}, F(k+1)={free_energy_k1:.6f}, expand={should_expand}", file=sys.stderr)
    
    # Get match voice name from config (discoverable, not hardcoded)
    match_voice_name = "opic.match_voice_body_pattern"  # Default fallback
    if "opic.config.match_voice_name" in voices_dict and should_expand:
        try:
            config_ctx = {**context, "project_root": context.get("project_root", "")}
            match_voice_name = execute_opic(voices_dict["opic.config.match_voice_name"], config_ctx) or match_voice_name
        except:
            pass
    match_voice = voices_dict.get(match_voice_name) if should_expand else None
    if match_voice and should_expand:
        # Use OPIC's expansion system (only if energetically favorable)
        matcher_context = {
            **context,
            "voice_body": voice_body,
            "inputs": context.get("inputs", {}),
            "voices": voices_dict,
            "expansion_depth": projected_depth,
            "expansion_complexity": projected_complexity
        }
        result = execute_opic(match_voice, matcher_context)
        if result is not None:
            context["execution_history"][voice_key] = result
            return result
    
    # Fallback: Simple pattern matching
    result = None
    
    # Pattern 1: Mapping definition → extract string (circular: preserve structure)
    if is_mapping_definition:
        inner = voice_body.strip()[1:-1].strip()
        last_quote_idx = inner.rfind('"')
        result = inner[1:last_quote_idx]
        try:
            result = result.encode().decode('unicode_escape')
        except:
            pass
        # Store and return immediately - don't fall through
        if result is not None:
            context["execution_history"][voice_key] = result
            return result
    
    # Pattern 2: Execution chain → execute chain
    if result is None and is_chain:
        # Get execute chain voice name from config (discoverable, not hardcoded)
        execute_chain_voice_name = "opic.execute_chain"  # Default fallback
        skip_flag_name = "_skip_execute_chain_voice"  # Default fallback
        if "opic.config.execute_chain_voice_name" in voices_dict:
            try:
                config_ctx = {**context, "project_root": context.get("project_root", "")}
                execute_chain_voice_name = execute_opic(voices_dict["opic.config.execute_chain_voice_name"], config_ctx) or execute_chain_voice_name
            except:
                pass
        if "opic.config.skip_execute_chain_flag" in voices_dict:
            try:
                config_ctx = {**context, "project_root": context.get("project_root", "")}
                skip_flag_name = execute_opic(voices_dict["opic.config.skip_execute_chain_flag"], config_ctx) or skip_flag_name
            except:
                pass
        execute_chain_voice = voices_dict.get(execute_chain_voice_name)
        skip_execute_chain = context.get(skip_flag_name)
        if execute_chain_voice and not skip_execute_chain:
            chain_context = {
                **context,
                "chain_string": voice_body,
                "voices": voices_dict,
                "_skip_execute_chain_voice": True,
            }
            result = execute_opic(execute_chain_voice, chain_context)
        else:
            result = execute_opic_chain(voice_body, context)
    
    # Pattern 3: String/value → return as-is (lossless)
    # (Extension already handled early via energetic coupling)
    if result is None:
        if isinstance(voice_body, str):
            try:
                result = voice_body.encode().decode('unicode_escape')
            except:
                result = voice_body
        else:
            result = voice_body
    
    # Theory: Store result for stability detection (equilibrium tracking)
    # Stable formations: result doesn't change = equilibrium reached
    context["execution_history"][voice_key] = result
    
    return result


def execute_opic_chain(chain_string: str, context: Dict[str, Any]) -> Any:
    """
    Execute chain - Circular bootstrap
    Equilibrium: Python provides minimal bootstrap, OPIC executes itself
    Never calls opic.execute_chain (that would break circular equilibrium)
    """
    return bootstrap_chain(chain_string, context)


def bootstrap_chain(chain_string: str, context: Dict[str, Any]) -> Any:
    """
    Bootstrap chain execution - Circular phase flow
    Equilibrium: Python provides primitives, OPIC executes itself
    Symmetry breaking: Each step knows its role (input, voice, primitive, extension)
    Lossless: Information preserved through circle S¹ (phase θ preserved)
    """
    chain_body = chain_string.strip()
    chain_body = chain_body[1:-1].strip() if chain_body.startswith("{") and chain_body.endswith("}") else chain_body
    
    # Get configurable operators from config (discoverable, not hardcoded)
    voices = context.get("voices", {})
    chain_op = "->"  # Default fallback
    plus_op = "+"  # Default fallback
    ext_prefix = "$"  # Default fallback
    lookup_name = "lookup"  # Default fallback
    get_name = "get"  # Default fallback
    
    # Try to get from config (discoverable)
    if "opic.config.chain_operator" in voices:
        try:
            config_ctx = {**context, "project_root": context.get("project_root", "")}
            chain_op = execute_opic(voices["opic.config.chain_operator"], config_ctx) or chain_op
        except:
            pass
    if "opic.config.plus_operator" in voices:
        try:
            config_ctx = {**context, "project_root": context.get("project_root", "")}
            plus_op = execute_opic(voices["opic.config.plus_operator"], config_ctx) or plus_op
        except:
            pass
    if "opic.config.extension_prefix" in voices:
        try:
            config_ctx = {**context, "project_root": context.get("project_root", "")}
            ext_prefix = execute_opic(voices["opic.config.extension_prefix"], config_ctx) or ext_prefix
        except:
            pass
    if "opic.config.lookup_primitive_name" in voices:
        try:
            config_ctx = {**context, "project_root": context.get("project_root", "")}
            lookup_name = execute_opic(voices["opic.config.lookup_primitive_name"], config_ctx) or lookup_name
        except:
            pass
    if "opic.config.get_primitive_name" in voices:
        try:
            config_ctx = {**context, "project_root": context.get("project_root", "")}
            get_name = execute_opic(voices["opic.config.get_primitive_name"], config_ctx) or get_name
        except:
            pass
    
    steps = [s.strip() for s in chain_body.split(chain_op)]
    result = None
    env = dict(context)
    
    # Primitives (Python provides these - circular boundary)
    # Lossless: Phase θ preserved through lookup (circle S¹)
    def lookup_primitive(mapping, key):
        """Lookup key in dict or chain result - Circular: preserves phase"""
        if isinstance(mapping, dict):
            return mapping.get(key)
        # If result is a chain string, convert it to dict (circular transformation)
        if isinstance(mapping, str):
            mapping_stripped = mapping.strip()
            if mapping_stripped.startswith("{") and mapping_stripped.endswith("}"):
                d = _chain_to_dict(mapping_stripped)
                return d.get(key)
        return None
    
    for i, step in enumerate(steps):
        # Pattern matching (declarative routing)
        # Symmetry breaking: check primitives first (they have specific roles)
        is_lookup = step == lookup_name
        is_get = step == get_name
        is_extension = step.startswith(ext_prefix) and step.endswith(ext_prefix)
        in_env = step in env
        is_voice = step in voices
        is_last_step = i == len(steps) - 1
        has_plus = f" {plus_op} " in step or (step.strip().startswith('"') and plus_op in step)
        
        # Handle + operator: hopeful OR or string concatenation
        if has_plus and not (is_lookup or is_get or is_extension):
            # Split by + and evaluate each part
            # Theory: + is hopeful OR (try first, if None try next) OR concatenation (if all strings)
            plus_parts = [p.strip() for p in step.split(plus_op)]
            evaluated_parts = []
            for part in plus_parts:
                # Evaluate part (could be quoted string, variable, voice, etc.)
                if part.startswith('"') and part.endswith('"'):
                    # Quoted string literal
                    evaluated_parts.append(part[1:-1])
                elif part in env:
                    evaluated_parts.append(env[part])
                elif part in voices:
                    voice_body = voices[part]
                    part_context = {**context, **env, "input": result}
                    evaluated_parts.append(execute_opic(voice_body, part_context))
                else:
                    evaluated_parts.append(part)
            
            # Theory: If all parts are strings, concatenate (string concatenation)
            # Otherwise, use hopeful OR (first non-None wins)
            if all(isinstance(p, str) and not p.startswith('"') for p in evaluated_parts):
                # All are strings - concatenate
                step_result = "".join(str(p) for p in evaluated_parts if p is not None)
            else:
                # Hopeful OR: first non-None wins
                step_result = next((p for p in evaluated_parts if p is not None), None)
        elif is_lookup or is_get:
            # Lookup uses: mapping (result from previous step) + key (original chain input)
            # Circular: Preserve original input (phase θ from chain start)
            key = env.get("command")  # Original chain input (circular: phase preservation)
            mapping = result if result is not None else env
            step_result = lookup_primitive(mapping, key)
        elif is_extension:
            step_result = call_extension(step[1:-1], env)
        elif in_env:
            step_result = env[step]
        elif is_voice:
            # Circular: preserve original inputs (command) through recursive execution
            # Lossless: Information flows through circle S¹ (phase preserved)
            # Theory: Check for stability - if result unchanged, equilibrium reached
            voice_body = voices[step]
            new_context = {**context, **env, "input": result, "command": env.get("command")}
            
            # Theory-based termination: Execute and check if result stabilizes
            # Stable formations: when result doesn't change, we've reached equilibrium
            step_result = execute_opic(voice_body, new_context)
            
            # Store result in env under voice name (for later steps to reference)
            # Also store under output variable name if chain ends with variable name
            env[step] = step_result
            
            # Theory: If result is same as input and no transformation occurred, stop recursion
            # This is the natural termination from OPIC's energy minimization principle
            if step_result == result and step_result is not None:
                # Equilibrium reached - no transformation, stable state
                # This prevents infinite recursion through theory, not arbitrary limits
                pass  # Result is stable, continue
        elif is_last_step:
            # Symmetry breaking: final step is output variable name, not execution
            # Circular: Result flows back (lossless diffeomorphism)
            step_result = result
            env[step] = result  # Store result under output variable name
        else:
            step_result = step
        
        # Update result and env (circular: phase flows forward, information preserved)
        # Symmetry breaking: result flows forward, env stores intermediate values
        result = step_result
        env["input"] = result
        if not is_last_step:  # Don't overwrite output variable with step name
            env[step] = result
    
    return result


def _chain_to_dict(chain_str: str) -> Dict[str, Any]:
    """
    Convert OPIC chain mapping to Python dict
    Circular: Smooth, invertible transformation (lossless diffeomorphism)
    """
    import re
    # Handle chain like: { "key" -> value "key2" -> value2 }
    chain_body = chain_str.strip()
    chain_body = chain_body[1:-1].strip() if chain_body.startswith("{") and chain_body.endswith("}") else chain_body
    
    # Extract "key" -> value pairs (circular: preserves structure)
    pairs = re.findall(r'"([^"]+)"\s*->\s*([^\s]+)', chain_body)
    result = {k: v.strip('"') for k, v in pairs}
    
    # Handle default case (not quoted) - Circular: preserves all information
    default_match = re.search(r'default\s*->\s*([^\s}]+)', chain_body)
    if default_match:
        result["default"] = default_match.group(1).strip('"')
    
    return result


def _load_ops_file(file_path: Path, voices: Dict, defs: Dict, voice_sources: Dict = None, def_sources: Dict = None, base_dir: Path = None, target_file: Path = None, loaded_files: set = None):
    """
    Load .ops file - Circular: Python provides file I/O
    Lossless: All information preserved (no transformation, just reading)
    Auto-detects namespace usage and includes files automatically
    Conflict resolution: target file always wins, then nearest definition wins
    Expansions are idempotent: if already expanded, don't expand again
    
    Args:
        target_file: The file being executed (target) - its voices always override includes
        loaded_files: Set of file paths already loaded (prevents cycles)
    """
    if voice_sources is None:
        voice_sources = {}
    if def_sources is None:
        def_sources = {}
    if base_dir is None:
        base_dir = file_path.parent
    if loaded_files is None:
        loaded_files = set()
    
    # Resolve path once and convert to string for tracking
    try:
        resolved_path = file_path.resolve()
        file_key = str(resolved_path)
    except (OSError, ValueError) as e:
        # If resolve fails, use absolute path as fallback
        file_key = str(file_path.absolute())
        resolved_path = file_path
    
    # Lambda expansion: if file already loaded, don't expand again (prevents cycles)
    # BUT: Always reload target file to ensure it wins conflicts
    is_target = (target_file and target_file.resolve() == resolved_path) if target_file else False
    if not is_target and file_key in loaded_files:
        return  # Already expanded (but target file always reloads to win conflicts)
    
    # Mark as loaded BEFORE processing includes (prevents cycles)
    loaded_files.add(file_key)
    
    content = file_path.read_text()
    inc_defs, inc_voices, inc_includes, boundary_matrix, symbol_list = parse_ops(content, file_path)
    
    # Semantic boundary matrix available for symbol extraction and type filtering
    # boundary_matrix: [line, char, type, content, position] for each semantic change
    # symbol_list: extracted symbols ready for expansion operations
    # Can use expansion.batch_expand, expansion.expand_namespaces, etc. on symbol_list
    
    # Calculate distance using OPIC voices (declarative)
    def calculate_distance(path: Path) -> int:
        """Calculate directory distance using OPIC - delegates to file.calculate_distance"""
        try:
            rel_path = path.parent.relative_to(base_dir)
            return len(rel_path.parts)
        except ValueError:
            # Different tree - use OPIC to calculate
            # Call file.calculate_distance voice if available
            if "file.calculate_distance" in voices:
                # Build context for OPIC voice
                context = {
                    "voices": voices,
                    "defs": defs,
                    "call_extension": call_extension,
                    "file_path": str(path),
                    "base_dir": str(base_dir)
                }
                try:
                    result = execute_opic(voices["file.calculate_distance"], context)
                    return int(result) if isinstance(result, (int, float)) else 999
                except:
                    pass
            # Fallback: calculate manually
            path_parts = path.parent.parts
            base_parts = base_dir.parts
            common = 0
            for p_part, b_part in zip(path_parts, base_parts):
                if p_part == b_part:
                    common += 1
                else:
                    break
            up_levels = len(base_parts) - common
            down_levels = len(path_parts) - common
            return up_levels + down_levels
    
    current_distance = calculate_distance(file_path)
    
    # Merge voices with conflict resolution: nearest wins
    # Lambda expansion: track source file so we know if already expanded
    for name, body in inc_voices.items():
        if name in voices:
            # Conflict: check which is nearer
            existing_source = voice_sources.get(name)
            if existing_source and existing_source != file_key:
                # Different file - resolve conflict
                # Theory: Target file always wins (it's what we're executing)
                # Then nearest definition wins (same directory > parent > grandparent)
                is_target_file = (target_file and file_path.resolve() == target_file.resolve())
                existing_is_target = (target_file and Path(existing_source).resolve() == target_file.resolve())
                
                if is_target_file and not existing_is_target:
                    # This is target file, existing is not - target wins
                    voices[name] = body
                    voice_sources[name] = file_key
                elif not is_target_file and existing_is_target:
                    # Existing is target file, this is not - keep existing
                    pass
                else:
                    # Neither or both are target - use distance (nearest wins)
                    existing_distance = calculate_distance(Path(existing_source)) if existing_source.startswith('/') else 999
                    if current_distance <= existing_distance:
                        voices[name] = body
                        voice_sources[name] = file_key
            else:
                # Same file or no existing source - always update
                voices[name] = body
                voice_sources[name] = file_key
        else:
            # No conflict, add it (lambda expansion: mark as expanded)
            voices[name] = body
            voice_sources[name] = file_key
    
    # Merge defs with conflict resolution: nearest wins (using OPIC)
    # Lambda expansion: track source file so we know if already expanded
    for name, fields in inc_defs.items():
        if name in defs:
            # Conflict: check which is nearer
            existing_source = def_sources.get(name)
            if existing_source and existing_source != file_key:
                # Different file - compare distances
                existing_distance = calculate_distance(Path(existing_source)) if existing_source.startswith('/') else 999
                if "file.resolve_conflict" in voices:
                    context = {
                        "voices": voices,
                        "defs": defs,
                        "call_extension": call_extension,
                        "existing_distance": existing_distance,
                        "current_distance": current_distance
                    }
                    try:
                        resolution = execute_opic(voices["file.resolve_conflict"], context)
                        if resolution == "current_wins":
                            defs[name] = fields
                            def_sources[name] = file_key
                        # else: existing wins, keep it
                        continue
                    except:
                        pass
                # Fallback: simple comparison
                if current_distance <= existing_distance:
                    defs[name] = fields
                    def_sources[name] = file_key
            # else: same file or no existing, keep current
        else:
            # No conflict, add it (lambda expansion: mark as expanded)
            defs[name] = fields
            def_sources[name] = file_key
    
    # Load includes recursively
    for include_file in inc_includes:
        include_path = file_path.parent / include_file
        if not include_path.exists():
            # Search up the directory tree for the file
            search_dir = file_path.parent.parent
            while search_dir != search_dir.parent:  # Stop at filesystem root
                alt_path = search_dir / include_file
                if alt_path.exists():
                    include_path = alt_path
                    break
                # Also check common subdirectories
                for subdir in search_dir.iterdir():
                    if subdir.is_dir():
                        alt_path = subdir / include_file
                        if alt_path.exists():
                            include_path = alt_path
                            break
                    if include_path.exists():
                        break
                if include_path.exists():
                    break
                search_dir = search_dir.parent
        if include_path.exists():
            # Pass target_file and loaded_files to prevent cycles
            _load_ops_file(include_path, voices, defs, voice_sources, def_sources, base_dir, target_file, loaded_files)


def main():
    """
    CLI entry point - Circular architecture
    Equilibrium: Python provides bootstrap, OPIC executes itself
    Lossless: All information preserved through circle S¹
    """
    project_root = find_project_root()
    sys.path.insert(0, str(project_root))
    
    # Initialize parser (circular: minimal Python)
    _init_parser(project_root)
    
    # Load config first (discoverable paths, not hardcoded)
    config_path = project_root / "core" / "opic_config.ops"
    voices = {}
    defs = {}
    voice_sources = {}
    def_sources = {}
    loaded_files = set()
    
    # Load config if it exists (allows discovery of paths)
    if config_path.exists():
        _load_ops_file(config_path, voices, defs, voice_sources, def_sources, project_root, target_file=None, loaded_files=loaded_files)
    
    # Discover bootstrap path from config (not hardcoded)
    bootstrap_path = project_root / "core" / "bootstrap.ops"  # Default fallback
    if "opic.config.bootstrap_path" in voices:
        try:
            context = {
                "voices": voices,
                "defs": defs,
                "call_extension": call_extension,
                "project_root": str(project_root)
            }
            discovered_path = execute_opic(voices["opic.config.bootstrap_path"], context)
            if discovered_path:
                # Config returns relative path, join with project_root
                bootstrap_path = project_root / discovered_path
        except:
            pass
    bootstrap_path.exists() or (print(f"Error: bootstrap.ops not found", file=sys.stderr) or sys.exit(1))
    
    # Bootstrap is NOT the target file (it's infrastructure)
    _load_ops_file(bootstrap_path, voices, defs, voice_sources, def_sources, project_root, target_file=None, loaded_files=loaded_files)
    
    # Discover file resolution path from config (not hardcoded)
    file_resolution_path = project_root / "systems" / "file_resolution.ops"  # Default fallback
    if "opic.config.file_resolution_path" in voices:
        try:
            context = {
                "voices": voices,
                "defs": defs,
                "call_extension": call_extension,
                "project_root": str(project_root)
            }
            discovered_path = execute_opic(voices["opic.config.file_resolution_path"], context)
            if discovered_path:
                # Config returns relative path, join with project_root
                file_resolution_path = project_root / discovered_path
        except:
            pass
    if file_resolution_path.exists():
        _load_ops_file(file_resolution_path, voices, defs, voice_sources, def_sources, project_root, target_file=None, loaded_files=loaded_files)
    
    # Discover executor impl path from config (not hardcoded)
    executor_impl = project_root / "systems" / "opic_executor_impl.ops"  # Default fallback
    if "opic.config.executor_impl_path" in voices:
        try:
            context = {
                "voices": voices,
                "defs": defs,
                "call_extension": call_extension,
                "project_root": str(project_root)
            }
            discovered_path = execute_opic(voices["opic.config.executor_impl_path"], context)
            if discovered_path:
                # Config returns relative path, join with project_root
                executor_impl = project_root / discovered_path
        except:
            pass
    if executor_impl.exists():
        _load_ops_file(executor_impl, voices, defs, voice_sources, def_sources, project_root, target_file=None, loaded_files=loaded_files)
    
    # Get command (empty command -> "help") - Circular: self-routing
    command_line_args = sys.argv[1:] if len(sys.argv) > 1 else []
    command = command_line_args[0] if command_line_args else "help"
    
    # Check if command is a file path (ends with .ops or exists as file)
    ops_file = None
    if command.endswith(".ops"):
        # Direct file path - execute it
        ops_file = command
    elif (Path(command).exists() and Path(command).is_file()):
        # Existing file - execute it
        ops_file = command
    elif command == "execute":
        # Legacy "execute" command - still supported but not needed
        if len(command_line_args) < 2:
            print(f"Error: {command} requires an argument", file=sys.stderr)
            sys.exit(1)
        ops_file = command_line_args[1]
    else:
        # Route command using OPIC (circular: OPIC routes itself)
        # First try direct command routing, then search action/ directories
        try:
            context = {
                "voices": voices,
                "defs": defs,
                "call_extension": call_extension,  # Circular boundary: Python ↔ OPIC
                "command": command,
                "command_line_args": command_line_args,
                "project_root": str(project_root)
            }
            # Get find command voice name from config (discoverable, not hardcoded)
            find_command_voice_name = "opic.cli.find_command"  # Default fallback
            if "opic.config.find_command_voice_name" in voices:
                try:
                    config_ctx = {**context, "project_root": str(project_root)}
                    find_command_voice_name = execute_opic(voices["opic.config.find_command_voice_name"], config_ctx) or find_command_voice_name
                except:
                    pass
            find_command_voice = voices.get(find_command_voice_name)
            # Circular: Preserve original command (phase θ) through execution
            ops_file = find_command_voice and execute_opic(find_command_voice, {**context, "command": command})
            
            # Discover search directories from config (not hardcoded)
            if not ops_file or ops_file == "default":
                action_dirs = [
                    project_root / "action" / "examples" / f"{command}.ops",
                    project_root / "action" / "tests" / f"{command}.ops",
                    project_root / "action" / "ml" / f"{command}.ops",
                    project_root / "action" / f"{command}.ops",
                    project_root / f"{command}.ops",
                    Path.cwd() / f"{command}.ops"
                ]  # Default fallback
                if "opic.config.search_directories" in voices:
                    try:
                        config_ctx = {
                            **context,
                            "project_root": str(project_root),
                            "current_dir": str(Path.cwd())
                        }
                        discovered_dir = execute_opic(voices["opic.config.search_directories"], config_ctx)
                        # Config returns single directory string, add to list
                        if discovered_dir and isinstance(discovered_dir, str):
                            action_dirs = [project_root / discovered_dir / f"{command}.ops"] + action_dirs
                    except:
                        pass
                for path in action_dirs:
                    if path.exists():
                        ops_file = str(path.relative_to(project_root)) if path.is_relative_to(project_root) else str(path)
                        break
            
            ops_file or (print(f"Error: Command '{command}' not found. Try 'opic help'", file=sys.stderr) or sys.exit(1))
        except Exception as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)
    
    # Resolve and execute ops file (circular: OPIC executes itself)
    ops_path = project_root / ops_file if not Path(ops_file).is_absolute() else Path(ops_file)
    (ops_path.exists() or (Path.cwd() / ops_file).exists()) or (print(f"Error: File not found: {ops_file}", file=sys.stderr) or sys.exit(1))
    ops_path = ops_path if ops_path.exists() else Path.cwd() / ops_file
    
    # Load target file - THIS is what we're executing, so it's the target
    # Theory: Target file voices always override included files
    # Use same loaded_files set from bootstrap to prevent cycles
    _load_ops_file(ops_path, voices, defs, voice_sources, def_sources, project_root, target_file=ops_path, loaded_files=loaded_files)
    
    # Get main voice name from config (discoverable, not hardcoded)
    main_voice_name = "main"  # Default fallback
    if "opic.config.main_voice_name" in voices:
        try:
            config_ctx = {
                "voices": voices,
                "defs": defs,
                "call_extension": call_extension,
                "project_root": str(project_root)
            }
            main_voice_name = execute_opic(voices["opic.config.main_voice_name"], config_ctx) or main_voice_name
        except:
            pass
    main_voice = voices.get(main_voice_name)
    
    if "--debug" in sys.argv:
        print(f"DEBUG main: Found main voice, type={type(main_voice)}, first 100: {str(main_voice)[:100] if main_voice else 'None'}", file=sys.stderr)
    
    # Circular: OPIC executes itself, information preserved through circle S¹
    context = {
        "voices": voices,
        "defs": defs,
        "call_extension": call_extension,
        "command": command,
        "command_line_args": command_line_args
    }
    if main_voice:
        result = execute_opic(main_voice, context)
        if result:
            print(result)


if __name__ == "__main__":
    main()
