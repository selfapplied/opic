;;; planning.ops â€” Generic planning and execution in opic

;; Planning: break any goal into steps
def plan { goal, steps, order }
def step { name, action, dependencies, result }

voice plan.from_goal / {goal -> analyze -> decompose -> steps}
voice plan.analyze / {goal -> requirements + constraints}
voice plan.decompose / {requirements -> step_1 -> step_2 -> ... -> step_n}
voice plan.order / {steps -> topological_sort -> ordered_steps}

;; Execution: execute any plan
def execution { plan, state, step_index, results }
def state { inputs, outputs, completed_steps }

voice execute.plan / {plan -> execute_step_1 -> execute_step_2 -> ... -> execute_step_n}
voice execute.step / {step + state -> run_action -> update_state}
voice execute.check_dependencies / {step + state -> all_dependencies_met}
voice execute.run_action / {action + inputs -> outputs}
voice execute.update_state / {state + step + outputs -> new_state}

;; Generic step execution
voice step.execute / {step_name -> find_voice -> check_dependencies -> run -> store_result}
voice step.find_voice / {step_name -> voice_definition}
voice step.check_dependencies / {dependencies + state -> ready}
voice step.run / {voice + inputs -> outputs}
voice step.store_result / {outputs + state -> updated_state}

;; Planning helpers
voice plan.find_steps / {plan -> extract_steps}
voice plan.extract_steps / {plan_body -> step_list}
voice plan.parse_chain / {chain_string -> step_names}

;; Execution helpers  
voice execute.follow_chain / {chain -> step_1 -> step_2 -> ... -> step_n}
voice execute.resolve_voice / {voice_name -> voice_body}
voice execute.check_available / {voice_name -> exists}

target planning / "generic_planning_and_execution"
voice main / {plan.from_goal -> execute.plan}

