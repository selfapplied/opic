;;; phase2_functor_computation.ops — Phase 2: Compute Functor ℱ(v) from real voice data

include examples/phase1_prime_voices.ops
include systems/field_coherence.ops

;; Phase 2 definitions
def functor_value { amplitude, phase, coherence_weight, complex_value }
def coherence_measurement { voice_name, execution_time, output_coherence, phase_value }

;; Load Phase 1 results
voice phase2.load_prime_voices / {
  -> 
  read_phase1_results -> 
  extract_prime_voices -> 
  prime_voices
}

;; Measure coherence for a voice
voice phase2.measure_voice_coherence / {
  prime_voice -> 
  phase2.execute_voice -> 
  phase2.measure_execution_time -> 
  phase2.compute_output_coherence -> 
  phase2.compute_phase -> 
  coherence_measurement
}

voice phase2.execute_voice / {
  prime_voice -> 
  try_execute -> 
  capture_output -> 
  execution_result
}

voice phase2.measure_execution_time / {
  execution_result -> 
  get_timing -> 
  execution_time
}

voice phase2.compute_output_coherence / {
  execution_result -> 
  measure_coherence -> 
  output_coherence
}

voice phase2.compute_phase / {
  execution_time -> 
  normalize_to_2pi -> 
  phase_value
}

;; Compute functor ℱ(v) = ||voice_matrix(v)||₂ · exp(i·phase(v))
voice phase2.compute_functor / {
  coherence_measurement -> 
  phase2.compute_spectral_norm -> 
  phase2.compute_complex_amplitude -> 
  functor_value
}

voice phase2.compute_spectral_norm / {
  coherence_measurement -> 
  use_coherence_as_norm -> 
  spectral_norm
}

voice phase2.use_coherence_as_norm / {
  measurement -> 
  extract_coherence -> 
  use_as_amplitude -> 
  amplitude
}

voice phase2.compute_complex_amplitude / {
  amplitude + phase -> 
  compute_exp_i_phase -> 
  multiply_by_amplitude -> 
  complex_value
}

;; Compute functors for all prime voices
voice phase2.compute_all_functors / {
  prime_voices -> 
  for_each_prime -> 
  phase2.measure_voice_coherence -> 
  phase2.compute_functor -> 
  all_functors
}

;; Save functor results
voice phase2.save_functors / {
  all_functors -> 
  format_results -> 
  write_json -> 
  saved
}

;; Main Phase 2 execution
voice phase2.run / {
  -> 
  phase2.load_prime_voices -> 
  phase2.compute_all_functors -> 
  phase2.save_functors -> 
  phase2.display_summary -> 
  results
}

target phase2_functor / "phase2_functor_computation"
voice main / {phase2.run -> phase2.display_summary}

