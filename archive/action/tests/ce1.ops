;;; ce1.ops — CE1 Test Operator Table

;; Tests as composable morphisms - tests become operators in CE1 space
;; Each test is an operator: Ô_test ∈ ℒ(ℋ_test)

;; Test operator structure
def test_operator {
  name,           ;; test name
  input_type,     ;; input domain
  output_type,    ;; output codomain
  phi_k,          ;; field potential
  dimension,      ;; CE1 dimension
  trace7          ;; stability trace
}

;; CE1 Test Operator Table
voice ce1.test_operator_table / {
  "atomic.voice" -> test.atomic_voice_operator
  "atomic.chain" -> test.atomic_chain_operator
  "atomic.field" -> test.atomic_field_operator
  "compositional.two" -> test.compositional_two_operator
  "compositional.three" -> test.compositional_three_operator
  "progressive.incremental" -> test.progressive_incremental_operator
  "coherence.terminology" -> test.coherence_terminology_operator
  "field.potential" -> test.field_potential_operator
  "intelligence.understanding" -> test.intelligence_understanding_operator
  default -> test.default_operator
}

;; Atomic voice test operator
voice test.atomic_voice_operator / {
  input: "question" ->
  output: "explanation" ->
  phi_k: 1.0 ->
  dimension: 0 ->
  trace7: 7 ->
  operator
}

;; Compositional test operator (composes two concepts)
voice test.compositional_two_operator / {
  input: "concept1 + concept2" ->
  output: "combined_explanation" ->
  phi_k: 1.5 ->
  dimension: 1 ->
  trace7: 7 ->
  operator
}

;; Field test operator (validates field theory)
voice test.field_potential_operator / {
  input: "field_query" ->
  output: "field_explanation" ->
  phi_k: 2.5 ->
  dimension: 2 ->
  trace7: 7 ->
  operator
}

;; Compose test operators
voice test.compose_operators / {
  operator1 + operator2 ->
  test.compute_composition ->
  test.check_trace7 ->
  composed_operator
}

;; Compute composition: Ô₁ ∘ Ô₂
voice test.compute_composition / {
  op1 + op2 ->
  test.merge_inputs ->
  test.merge_outputs ->
  test.combine_phi_k ->
  test.promote_dimension ->
  composed
}

;; Combine field potentials: φₖ_composed = (φₖ₁ + φₖ₂) / 2
voice test.combine_phi_k / {
  phi_k1 + phi_k2 ->
  math.add ->
  math.divide 2 ->
  combined_phi_k
}

;; Promote dimension: D_composed = max(D₁, D₂) + 1
voice test.promote_dimension / {
  D1 + D2 ->
  math.max ->
  math.add 1 ->
  promoted_dimension
}

;; Check trace7 stability: τ ≈ 7 ± ε
voice test.check_trace7 / {
  trace7 + epsilon ->
  test.compute_deviation ->
  test.check_stable ->
  stability_status
}

;; Test operator morphism: tests compose like any other morphism
voice test.operator_morphism / {
  test_input ->
  test.lookup_operator ->
  test.apply_operator ->
  test_output
}

;; Lookup test operator from table
voice test.lookup_operator / {
  test_name ->
  ce1.test_operator_table ->
  lookup ->
  operator
}

;; Apply test operator
voice test.apply_operator / {
  operator + input ->
  test.execute_test ->
  test.score_result ->
  test_output
}

target ce1 / "ce1_test_operator_table"
voice main / {ce1.test_operator_table -> ce1}

