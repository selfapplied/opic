;;; galois.ops â€” Galois theory and field extensions

;; Galois extension: algebraic lifting of modular field
def galois_extension { base_field, extension, property }

;; ============================================================================
;; FIELD EXTENSIONS (from Field Spec 0.7)
;; ============================================================================

;; ð”½â‚â‚€: digits {0â€“9} â€” unit group Uâ‚â‚€ â€” cyclic of order 4
voice galois.base_field / {digits_0_to_9 -> galois.unit_group -> galois.cyclic_order_4}

;; ð”½â‚â‚€[x]/(xÂ²âˆ’xâˆ’1): Pascal recurrence â€” golden ratio extension â€” captures Fibonacci subfield
voice galois.golden_ratio_extension / {pascal_recurrence -> galois.golden_ratio -> galois.fibonacci_subfield}

;; ð”¾â‚‡: 7-trace subgroup â€” self-conjugate extension â€” invariant under 7â†”3 mapping
voice galois.trace7_subgroup / {trace7 -> galois.self_conjugate -> galois.invariant_7_3}

;; â„‚_{tan}: tangent symmetry field â€” complexification of bias â€” links trigonometric and algebraic domains
voice galois.tangent_symmetry / {tan_theta -> galois.complexify -> galois.trigonometric_algebraic_link}

;; ð“”_{herm}: hermitian closure â€” dualization of all flows â€” ensures reversibility and conservation
voice galois.hermitian_closure / {flows -> galois.dualize -> galois.reversible_conserved}

;; ============================================================================
;; GALOIS GROUP OPERATIONS
;; ============================================================================

;; Galois group: Gal(Î¦Îº) = {Ïƒ | Ïƒ(Î¦Îº) = Î¦Îº}
;; Meaning-preserving transformations
voice galois.group / {field -> galois.find_automorphisms -> galois_group}
voice galois.find_automorphisms / {field -> galois.check_invariant -> automorphisms}

;; Galois invariant: Ïƒ(Î¦Îº) = Î¦Îº
voice galois.invariant / {expr + sigma -> galois.check_invariant -> galois_witness}
voice galois.check_invariant / {sigma_phi_k -> galois.equals_phi_k -> invariant}

;; Gradient preservation: Ïƒ preserves gradient structure
voice galois.gradient_preservation / {sigma_x -> galois.gradient_phi_k -> galois.equals_gradient -> preserved}

;; ============================================================================
;; FIXED FIELDS AND CORRESPONDENCE
;; ============================================================================

;; Fixed field: Fix(G) = {Î¦Îº | Ïƒ(Î¦Îº)=Î¦Îº âˆ€ÏƒâˆˆG}
voice galois.fixed_field / {G -> galois.all_sigma -> galois.check_invariant -> fixed_field}

;; Galois correspondence: H â†” L^H (subgroups â†” fixed fields)
voice galois.correspondence / {H -> galois.fixed_field_LH -> correspondence}

;; ============================================================================
;; FUNCTORIALITY
;; ============================================================================

;; Functoriality: Ïƒ(f âˆ˜ g) = Ïƒ(f) âˆ˜ Ïƒ(g)
voice galois.functoriality / {f + g -> galois.compose -> sigma -> galois.equals_sigma_compose -> functorial}

;; ============================================================================
;; EXTENSION OPERATIONS
;; ============================================================================

;; Create extension from base field
voice galois.create_extension / {base_field + polynomial -> galois.quotient_ring -> extension}

;; Compute extension degree
voice galois.extension_degree / {extension -> galois.compute_degree -> degree}

;; Check if extension is Galois
voice galois.is_galois / {extension -> galois.check_separable -> galois.check_normal -> is_galois}

target galois / "galois_theory_operations"
voice main / {galois.base_field -> galois}

