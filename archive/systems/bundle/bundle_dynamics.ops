;;; bundle_dynamics.ops — Bundle Dynamics and Curvature Bounds on X × S¹
;;; Declarative mathematical definitions with automatic text generation
;;; Focus on significant explanations - defaults handle the rest

include systems/00_core/opic_field_0.7.ops

;; ============================================================================
;; MATHEMATICAL STRUCTURES (OPIC can infer much of this)
;; ============================================================================

;; OPIC could auto-generate:
;; - symbol from name (X → "X", tilde_X → "\\tilde{X}")
;; - type from relationships (if factors: [X, S1] → product_space)
;; - properties from type (metric_space → has metric)
;; - domain/codomain from relationships (if base_component: F, fiber_component: R → domain: X×S1)

;; Base space X: compact metric space
def X {
  type: metric_space,
  compact: true,
  metric: d_X
  ;; OPIC infers: symbol: "X", description: "compact metric space"
}

;; Circle S¹ = ℝ / 2πℤ
def S1 {
  type: quotient_space,
  quotient: "ℝ / 2πℤ",
  metric: d_S1,
  d_S1_formula: "min_k |theta - theta_prime + 2*pi*k|",
  symbol: "S^1",
  description: "unit circle"
}

;; Bundle X̃ = X × S¹
def tilde_X {
  factors: [X, S1]
  ;; OPIC infers:
  ;; - type: product_space (from factors)
  ;; - symbol: "\\tilde{X}" (from name pattern)
  ;; - domain: X × S1 (from factors)
  ;; - metric: d_product (from type product_space)
  ;; - d_product_formula: "d_X(x,x_prime) + d_S1(theta,theta_prime)" (from factors' metrics)
}

;; Base dynamics F : X → X
def F {
  type: map,
  domain: X,
  codomain: X,
  properties: [continuous],
  symbol: "F",
  role: "base dynamics",
  application: "renormalization or evolution operator on a configuration space"
}

;; Fiber dynamics R : S¹ → S¹
def R {
  type: map,
  domain: S1,
  codomain: S1,
  properties: [continuous, circle_map],
  symbol: "R",
  role: "fiber dynamics",
  interpretation: "induced phase dynamics after projection onto $S^1$"
}

;; Lift R̂ : ℝ → ℝ
def R_hat {
  type: lift,
  base_map: R,
  domain: ℝ,
  codomain: ℝ,
  periodicity: "R_hat(theta + 2*pi) = R_hat(theta) + 2*pi",
  properties: [continuous],
  symbol: "\\hat{R}"
}

;; Bundle map F̃ : X̃ → X̃
def tilde_F {
  base_component: F,
  fiber_component: R
  ;; OPIC infers:
  ;; - type: bundle_map (from base_component + fiber_component)
  ;; - domain: tilde_X (from base_component.domain × fiber_component.domain)
  ;; - codomain: tilde_X (from base_component.codomain × fiber_component.codomain)
  ;; - symbol: "\\tilde{F}" (from name pattern)
  ;; - definition: "(x,theta) ↦ (F(x), R(theta))" (from components)
  ;; - coupling: decoupled (default for bundle_map)
}

;; Rotation number ρ(R)
def rho_R {
  map: R
  ;; OPIC infers:
  ;; - type: rotation_number (from map being circle_map)
  ;; - symbol: "\\rho(R)" (from name + map.symbol)
  ;; - definition: "lim_{n→∞} (R_hat^n(0) - 0) / (2*pi*n)" (standard rotation number formula)
  ;; - lift: R_hat (from map.base_map if exists, or finds lift of R)
}

;; Parameterized family R_x : S¹ → S¹, x ∈ X
def R_x {
  type: parameterized_family,
  base_space: X,
  fiber_maps: "R_x : S^1 → S^1",
  lift: "R_hat_x : ℝ → ℝ",
  continuity: "continuous in (x,theta)",
  symbol: "R_x"
}

;; Rotation field ρ : X → ℝ
def rho_field {
  depends_on: R_x
  ;; OPIC infers:
  ;; - type: field (from depends_on being parameterized_family)
  ;; - domain: X (from R_x.base_space)
  ;; - codomain: ℝ (from rotation_number output type)
  ;; - symbol: "\\rho" (from name pattern)
  ;; - definition: "rho(x) = rho(R_x)" (from depends_on relationship)
  ;; - interpretation: ["rotation field", "phase–advance field"] (from type field + source)
}

;; Curvature field K(x) = dρ(x)/dx
def K {
  depends_on: rho_field
  ;; OPIC infers:
  ;; - type: curvature_field (from depends_on being field + derivative pattern)
  ;; - domain: X (from rho_field.domain)
  ;; - symbol: "K" (from name)
  ;; - definition: "K(x) = d rho(x) / d x" (from depends_on + derivative pattern)
  ;; - interpretation: "sensitivity of average phase advance to changes in base point" (from type)
}

;; ============================================================================
;; ASSUMPTIONS
;; ============================================================================

;; Lipschitz constant L
def L {
  constant: L > 0,
  condition: |R_hat_x(theta) - R_hat_{x_prime}(theta)| ≤ L|x - x_prime|,
  uniform_lipschitz,
  text: "There exists a constant $L > 0$ such that for all $x, x' \\in X$ and all $\\theta \\in \\mathbb R$, $|\\hat{R}_x(\\theta) - \\hat{R}_{x'}(\\theta)| \\leq L |x - x'|$. That is, the family $(\\hat{R}_x)_x$ is uniformly Lipschitz in $x$."
}

def assumptions {
  assumption_1: {
    statement: "X ⊆ ℝ is closed interval",
    text: "$X \\subseteq \\mathbb R$ is a closed interval with the usual metric."
  },
  assumption_2: {
    statement: "Each R_x has lift R̂_x, orientation-preserving",
    text: "For each $x \\in X$, $\\hat{R}_x : \\mathbb R \\to \\mathbb R$ is a lift of an orientation-preserving circle map $R_x : S^1 \\to S^1$."
  },
  assumption_3: {
    statement: "Uniform Lipschitz: |R̂_x(θ) - R̂_{x'}(θ)| ≤ L|x - x'|",
    text: L.text
  },
  text: "We will show that this implies a Lipschitz bound on the rotation number field $\\rho(x)$, and hence a pointwise bound on its derivative $K(x)$ wherever it exists."
}

;; ============================================================================
;; PROPOSITIONS WITH EMBEDDED PROOFS
;; ============================================================================

;; Proposition: Rotation field is Lipschitz
def proposition {
  statement: "ρ : X → ℝ is Lipschitz with constant ≤ L/(2π)",
  bound: |rho(x) - rho(x_prime)| ≤ (L/(2*pi))|x - x_prime|,
  text: "Under the assumptions above, the rotation number field $\\rho : X \\to \\mathbb R$ is Lipschitz with constant at most $L / (2 \\pi)$. That is, for all $x, x' \\in X$, $|\\rho(x) - \\rho(x')| \\leq L / (2 \\pi) \\cdot |x - x'|$.",
  proof: {
    step_1: {
      statement: "n-th iterate bound",
      text: "Fix $x, x' \\in X$ and consider the $n$-th iterate of the lifts: $ \\hat{R}^n_x, \\hat{R}^n_{x'} : \\mathbb R \\to \\mathbb R$. By repeated application of the Lipschitz assumption, we obtain for all $\\theta \\in \\mathbb R$: $|\\hat{R}^n_x(\\theta) - \\hat{R}^n_{x'}(\\theta)| \\leq n L |x - x'|$."
    },
    step_2: {
      statement: "At θ=0",
      text: "In particular, take $\\theta = 0$. Then $|\\hat{R}^n_x(0) - \\hat{R}^n_{x'}(0)| \\leq n L |x - x'|$."
    },
    step_3: {
      statement: "Rotation number difference",
      text: "By definition of the rotation number, $\\rho(x) = \\lim_{n \\to \\infty} (\\hat{R}^n_x(0) - 0) / (2 \\pi n)$, and similarly for $\\rho(x')$. Subtracting and using the inequality above, we get $|\\rho(x) - \\rho(x')| = \\lim_{n \\to \\infty} |\\hat{R}^n_x(0) - \\hat{R}^n_{x'}(0)| / (2 \\pi n) \\leq \\lim_{n \\to \\infty} (n L |x - x'|) / (2 \\pi n) = L / (2 \\pi) \\cdot |x - x'|$. Thus $\\rho$ is Lipschitz with constant at most $L / (2 \\pi)$."
    }
  }
}

;; Corollary: Curvature bound
def corollary {
  statement: "If ρ differentiable at x, then |K(x)| ≤ L/(2π)",
  bound: |K(x)| = |rho_prime(x)| ≤ L/(2*pi),
  text: "If $\\rho$ is differentiable at $x \\in X$, then the curvature field $K(x) = d \\rho(x) / d x$ satisfies $|K(x)| \\leq L / (2 \\pi)$.",
  proof: {
    text: "Since $\\rho$ is Lipschitz with constant at most $L / (2 \\pi)$, every derivative (where it exists) must have magnitude at most this constant: $|K(x)| = |\\rho'(x)| \\leq L / (2 \\pi)$."
  },
  conclusion: {
    type: text_content,
    content: "In this minimal sense, the curvature of the rotation–number field is bounded by the Lipschitz constant governing the dependence of the fiber dynamics $\\hat{R}_x$ on the base point $x$."
  }
}

;; ============================================================================
;; EXTENSIONS
;; ============================================================================

def extensions {
  extension_1: {
    statement: "Higher-dimensional base X (smooth manifold), K = ∇ρ",
    text: "Higher-dimensional base spaces $X$ (smooth manifolds) with $K$ interpreted as the gradient $\\nabla \\rho$."
  },
  extension_2: {
    statement: "Coupled dynamics: (x,θ) ↦ (F(x), R_x(θ)) with interaction",
    text: "Fully coupled dynamics where the phase update depends on $x$, e.g. $(x, \\theta) \\mapsto (F(x), R_x(\\theta))$ with nontrivial interaction between base and fiber."
  },
  extension_3: {
    statement: "Geometric curvature: connections, curvature tensors",
    text: "Incorporation of additional structure (connections, curvature tensors) to interpret $K$ as a genuine geometric curvature rather than a scalar sensitivity."
  },
  intro: {
    type: text_content,
    content: "This toy setting can be extended in many directions:"
  },
  conclusion: {
    type: text_content,
    content: "For present purposes, this note shows how a simple bundle dynamics on $X \\times S^1$ admits a well-defined rotation–number field and a basic curvature bound under mild regularity assumptions. It provides a concrete backbone for more speculative or metaphorical interpretations of \"curvature\" and \"phase\" in complex systems."
  }
}

;; ============================================================================
;; SUBSECTION DEFAULTS (How content combines automatically)
;; ============================================================================

;; Default combination rules for different subsection types
def subsection_defaults {
  definition_sequence: {
    separator: "",              ;; Blank line between definitions
    intro: "Let",               ;; First definition intro
    subsequent_intro: "and let", ;; Subsequent definition intro
    math_before: true,          ;; Show math notation before definition text
    context_aware: true         ;; Adjust phrasing based on position
  },
  definition_with_math: {
    math_first: true,           ;; Math appears before definition text
    separator: ""               ;; Blank line between math and text
  },
  proof: {
    proposition_label: "#strong[Proposition.]",
    proof_label: "#strong[Proof.]",
    step_separator: "",         ;; Blank line between proof steps
    qed: {align_right: "□"}     ;; End marker
  },
  assumptions: {
    intro: "Assume:",
    list_format: true,          ;; Format as Typst list
    after_list: ""              ;; Blank line after list
  },
  extensions: {
    intro: "This toy setting can be extended in many directions:",
    list_format: true,
    conclusion: true            ;; Include conclusion text
  }
}

;; ============================================================================
;; DOCUMENT STRUCTURE (OPIC could infer this from dependencies)
;; ============================================================================

;; OPIC could auto-generate document structure by:
;; - Analyzing dependencies (X, S1 → tilde_X → tilde_F)
;; - Grouping related definitions (F, R, tilde_F together)
;; - Inferring section boundaries from dependency clusters
;; - Inferring subsection titles from definition types

;; Sections are just flat lists - defaults handle combination
;; Only add explicit explanations where they add significant value
;; Math notation and transitions auto-generate from definitions
def section_1 {
  definitions: [X, S1, tilde_X, F, R, tilde_F]
  ;; OPIC could infer:
  ;; - title: "1. The bundle and its dynamics" (from types: metric_space, product_space, bundle_map)
  ;; - content order: [X, S1, tilde_X, F, R, tilde_F] (from dependencies)
  ;; - subsections: ["1.1 Base and fiber dynamics"] (from grouping F, R, tilde_F)
  ;; - subsection defaults: definition_sequence (from types)
}

def section_2 {
  definitions: [R_hat, rho_R, R_x, rho_field, K]
  ;; OPIC could infer:
  ;; - title: "2. Rotation numbers and a curvature field" (from types: rotation_number, field, curvature_field)
  ;; - intro: (from analyzing what these definitions introduce)
  ;; - content order: [R_hat, rho_R, R_x, rho_field, K] (from dependencies)
  ;; - subsections: ["2.1 Rotation number", "2.2 Parameterization", "2.3 Curvature field"] (from dependency clusters)
}

def section_3 {
  title: "3. A curvature bound under Lipschitz dependence",
  content: [
    {subsection: "3.1 Lipschitz dependence of the family", defaults: subsection_defaults.assumptions},
    {list_source: assumptions},  ;; Auto-generates: "Assume:" + list + transition text
    {subsection: "3.2 Lipschitz bound on the rotation field", defaults: subsection_defaults.proof},
    proposition,          ;; Auto-generates: "#strong[Proposition.]" + statement + proof + QED
    {subsection: "3.3 Curvature bound", defaults: subsection_defaults.proof},
    {strong: "Corollary (Curvature bound)."},  ;; Explicit: custom label
    corollary,            ;; Auto-generates statement + proof + QED + conclusion
  ]
}

def section_4 {
  title: "4. Remarks and extensions",
  defaults: subsection_defaults.extensions,
  content: [
    {list_source: extensions},  ;; Auto-generates: intro + list + conclusion
  ]
}

;; ============================================================================
;; TEXT GENERATION (Context-aware, automatic)
;; ============================================================================

;; Generate text for a definition based on its type and context
voice text.generate_for_definition / {
  definition + context ->
  if_type_metric_space -> "Let $" + definition.symbol + "$ be a " + definition.description + " with metric $d_" + definition.symbol + "$."
  if_type_quotient_space -> "Let $" + definition.symbol + "$ denote the " + definition.description + ", represented as the quotient $" + definition.symbol + " = " + definition.quotient + "$ equipped with its standard metric $d_{" + definition.symbol + "}(\\theta, \\theta') = " + definition.d_S1_formula + "$."
  if_type_product_space -> "We define the " + definition.description + " $" + definition.symbol + " = " + format_factors(definition.factors) + "$ with the product metric $d((x, \\theta), (x', \\theta')) = " + definition.d_product_formula + "$."
  if_type_map -> generate_map_text(definition, context)
  if_type_lift -> "Assume that $" + definition.base_map.symbol + "$ lifts to a continuous map $" + definition.symbol + " : \\mathbb R \\to \\mathbb R$ satisfying $" + definition.periodicity + "$."
  if_type_bundle_map -> generate_bundle_map_text(definition)
  if_type_rotation_number -> generate_rotation_number_text(definition)
  if_type_parameterized_family -> generate_family_text(definition)
  if_type_field -> generate_field_text(definition)
  if_type_curvature_field -> generate_curvature_text(definition)
  else -> "" -> generated_text
}

;; Generate text for a map definition
voice text.generate_map / {
  map_def + context ->
  {
    type: text_content,
    content: (if_context_first -> "Let" else -> "and let") + " $" + map_def.symbol + " : " + format_type(map_def.domain) + " \\to " + format_type(map_def.codomain) + "$ be a " + format_properties(map_def.properties) + " (" + map_def.role + ")." +
    (if_has_application -> " In applications, $" + map_def.symbol + "$ might represent " + map_def.application + "." else -> "") +
    (if_has_interpretation -> " $" + map_def.symbol + "$ represents " + map_def.interpretation + "." else -> "")
  } -> text_content
}

;; Generate text for bundle map
voice text.generate_bundle_map / {
  bundle_map ->
  {
    type: text_content,
    content: "We combine them into a bundle map $" + bundle_map.symbol + " : " + format_type(bundle_map.domain) + " \\to " + format_type(bundle_map.codomain) + "$, $" + bundle_map.definition + "$. " +
    "This is the simplest " + bundle_map.coupling + " bundle dynamics: the base evolves under $" + bundle_map.base_component.symbol + "$ and the phase evolves under $" + bundle_map.fiber_component.symbol + "$ independently."
  } -> text_content
}

;; Generate text for rotation number
voice text.generate_rotation_number / {
  rotation_number ->
  {
    type: text_content,
    content: "The (" + rotation_number.name + ") rotation number of $" + rotation_number.map.symbol + "$ is defined by $" + rotation_number.symbol + " = " + rotation_number.definition + "$, " +
    "provided the limit exists. Under standard hypotheses (e.g. $" + rotation_number.map.symbol + "$ is orientation-preserving and continuous), this limit exists and is independent of the initial point.",
    auto_transition: {
      type: transition,
      kind: "logical",
      text: "Then"
    }
  } -> text_with_transition
}

;; Generate text for parameterized family
voice text.generate_family / {
  family ->
  "Now suppose that we have a \\emph{family} of circle maps $" + family.symbol + " : S^1 \\to S^1$, $x \\in " + format_type(family.base_space) + "$, " +
  "such that each $" + family.symbol + "$ admits a lift $" + family.lift + "$ and the map $(x, \\theta) \\mapsto " + family.lift + "(\\theta)$ is continuous."
}

;; Generate text for field
voice text.generate_field / {
  field ->
  {
    type: text_content,
    content: "For each $x \\in " + format_type(field.domain) + "$, define " + field.interpretation[0] + " $" + field.symbol + "(x) = " + field.definition + "$. " +
    "We think of $" + field.symbol + " : " + format_type(field.domain) + " \\to " + format_type(field.codomain) + "$ as a \"" + field.interpretation.join("\" or \"") + "\" " +
    "induced by " + field.source + ".",
    auto_transition: {
      type: transition,
      kind: "definition",
      text: "For each $x \\in " + format_type(field.domain) + "$, define the rotation number"
    }
  } -> text_with_transition
}

;; Generate text for curvature field
voice text.generate_curvature / {
  curvature ->
  "To get a simple notion of curvature, we treat $\\rho$ as a scalar field over $" + format_type(curvature.domain) + "$. " +
  "When $" + format_type(curvature.domain) + "$ has additional structure (e.g. a smooth manifold with a connection), one can define curvature in a fully geometric way. " +
  "Here we build a minimal analogue. Suppose $" + format_type(curvature.domain) + " \\subseteq \\mathbb R$ with the standard metric, and $\\rho$ is differentiable. " +
  "Define the \\emph{curvature field} $" + curvature.symbol + "(x) = " + curvature.definition + "$. " +
  "Informally, $" + curvature.symbol + "(x)$ measures how sensitive " + curvature.interpretation + "."
}

;; ============================================================================
;; STRUCTURED DATA TYPES (Not strings)
;; ============================================================================

;; Math expression as structured data
def math_expression {
  type: math,
  symbol,
  operator: null,
  left: null,
  right: null,
  definition: null
}

;; Text content as structured data
def text_content {
  type: text,
  content,
  formatting: []
}

;; Typst node as structured data
def typst_node {
  type: typst,
  node_type,
  content,
  attributes: {}
}

;; ============================================================================
;; MATH NOTATION AUTO-GENERATION (Structured)
;; ============================================================================

;; Auto-generate math expression from definition (structured, not string)
voice math.from_definition / {
  definition ->
  if_type_map -> {
    type: math,
    symbol: definition.symbol,
    operator: "→",
    left: format_type(definition.domain),
    right: format_type(definition.codomain)
  }
  if_type_product_space -> {
    type: math,
    symbol: definition.symbol,
    operator: "=",
    left: format_factors(definition.factors),
    right: null
  }
  if_type_rotation_number -> {
    type: math,
    symbol: definition.symbol,
    operator: "=",
    left: null,
    right: definition.definition
  }
  if_type_field -> {
    type: math,
    symbol: definition.symbol,
    operator: "=",
    left: definition.symbol + "(x)",
    right: definition.definition
  }
  if_type_curvature_field -> {
    type: math,
    symbol: definition.symbol,
    operator: "=",
    left: definition.symbol + "(x)",
    right: definition.definition
  }
  else -> {
    type: math,
    symbol: definition.symbol
  } -> math_expr
}

;; Auto-generate math block when definition has math_before flag
voice math.auto_generate / {
  definition + defaults ->
  if_defaults_math_before -> math.from_definition(definition) -> math_block
  else -> null -> math_block
}

;; ============================================================================
;; TRANSITION AUTO-GENERATION
;; ============================================================================

;; Auto-generate transitions based on context (structured)
voice transition.auto_generate / {
  previous_item + current_item ->
  if_previous_lift_and_current_rotation_number -> {
    type: transition,
    kind: "logical",
    text: "Then"
  }
  if_previous_family_and_current_field -> {
    type: transition,
    kind: "definition",
    text: "For each $x \\in " + format_type(current_item.domain) + "$, define the rotation number"
  }
  if_previous_field_and_current_curvature -> {
    type: transition,
    kind: "proof_intro",
    text: "We now prove a simple bound on $" + current_item.symbol + "$ under a Lipschitz condition on the family $\\hat{R}_x$."
  }
  if_previous_assumptions_and_current_proposition -> {
    type: transition,
    kind: "implication",
    text: "We will show that this implies a Lipschitz bound on the rotation number field $\\rho(x)$, and hence a pointwise bound on its derivative $K(x)$ wherever it exists."
  }
  else -> null -> transition
}

;; ============================================================================
;; LIST AUTO-GENERATION
;; ============================================================================

;; Auto-generate list items from structured data
voice list.auto_generate / {
  source ->
  if_is_assumptions -> [
    source.assumption_1.text,
    source.assumption_2.text,
    source.assumption_3.text
  ]
  if_is_extensions -> [
    source.extension_1.text,
    source.extension_2.text,
    source.extension_3.text
  ]
  if_is_proof_steps -> [
    source.step_1,
    source.step_2,
    source.step_3
  ]
  else -> [] -> list_items
}

;; ============================================================================
;; TYPST OUTPUT GENERATION (Fully Automatic - no manual concatenation)
;; ============================================================================

;; Convert structured math to Typst string (only at final output)
voice typst.math_to_string / {
  math_expr ->
  if_has_operator -> math_expr.symbol + " " + math_expr.operator + " " + math_expr.right
  else -> math_expr.symbol -> math_string
}

;; Convert structured text to Typst string (only at final output)
voice typst.text_to_string / {
  text_content ->
  text_content.content -> text_string
}

;; Convert structured transition to Typst string
voice typst.transition_to_string / {
  transition ->
  transition.text -> transition_string
}

;; Auto-format any content item - works with structured data
voice typst.format_item / {
  item + context + previous_item + defaults ->
  if_is_definition -> {
    ;; Auto-generate structured math if needed
    math_expr: if_defaults_math_before -> math.from_definition(item) -> auto_math
    else -> null -> auto_math,
    ;; Generate structured text
    text_content: text.generate_for_definition(item, context) -> generated_text,
    ;; Return structured content (conversion to string happens later)
    {
      type: content_block,
      math: auto_math,
      text: generated_text
    } -> formatted
  },
  if_has_literal -> {
    ;; Check if we can auto-generate this transition
    auto_transition: transition.auto_generate(previous_item, next_item) -> transition_obj,
    if_transition_obj -> transition_obj -> formatted
    else -> {
      type: text_content,
      content: item.literal
    } -> formatted
  },
  if_has_math -> {
    type: math_expression,
    symbol: item.math  ;; Could parse this into structured form
  } -> formatted,
  if_has_subsection -> {
    type: subsection_header,
    title: item.subsection
  } -> formatted,
  if_has_strong -> {
    type: strong_text,
    content: item.strong
  } -> formatted,
  if_has_list -> {
    ;; Auto-generate list items if source is provided
    if_has_list_source -> list.auto_generate(item.list_source) -> auto_items
    else -> item.list -> auto_items,
    {
      type: list,
      items: auto_items
    } -> formatted
  },
  if_has_align_right -> {
    type: aligned_content,
    alignment: "right",
    content: item.align_right
  } -> formatted,
  else -> null -> formatted
}

;; Convert structured content to Typst string (final step)
voice typst.structured_to_string / {
  structured_content ->
  if_type_content_block -> {
    if_has_math -> "#math(" + typst.math_to_string(structured_content.math) + ")" + "" -> math_part
    else -> "" -> math_part,
    math_part + typst.text_to_string(structured_content.text) -> formatted
  },
  if_type_text_content -> typst.text_to_string(structured_content) -> formatted,
  if_type_transition -> typst.transition_to_string(structured_content) -> formatted,
  if_type_math_expression -> "#math(" + typst.math_to_string(structured_content) + ")" -> formatted,
  if_type_subsection_header -> structured_content.title -> formatted,
  if_type_strong_text -> "#strong[" + structured_content.content + "]" -> formatted,
  if_type_list -> format_list(structured_content.items) -> formatted,
  if_type_aligned_content -> "#align(" + structured_content.alignment + ")[" + structured_content.content + "]" -> formatted,
  else -> "" -> formatted
}

;; Auto-format content list - works with structured data, converts to string at end
voice typst.format_content / {
  content + defaults ->
  current_subsection: null,
  current_defaults: null,
  structured_items: [],
  for_each_item: {
    if_is_subsection -> {
      current_subsection = item.subsection,
      current_defaults = item.defaults || defaults,
      structured_items.append({type: subsection_header, title: item.subsection})
    },
    else -> {
      structured_item: format_with_defaults(item, current_defaults, position_in_subsection) -> item_struct,
      structured_items.append(structured_item)
    }
  } ->
  ;; Convert all structured items to Typst strings
  map_structured_to_string(structured_items) ->
  join_with_defaults(current_defaults) ->
  formatted
}

;; Format item using subsection defaults
voice typst.format_with_defaults / {
  item + defaults + position ->
  if_defaults_definition_sequence -> {
    if_position_first -> defaults.intro + " " + format_item(item)
    else -> defaults.subsequent_intro + " " + format_item(item)
  },
  if_defaults_proof -> {
    if_is_proposition -> defaults.proposition_label + format_item(item)
    if_is_proof_step -> format_item(item) + defaults.step_separator
    if_is_last_step -> format_item(item) + defaults.qed
  },
  if_defaults_assumptions -> {
    if_is_list -> defaults.intro + format_list(item) + defaults.after_list
  },
  else -> format_item(item) ->
  formatted
}

;; Auto-format section - automatically handles title, intro, content with defaults
voice typst.format_section / {
  section ->
  "== " + section.title +
  "" +
  if_has_intro -> section.intro + "" -> intro_part
  else -> "" -> intro_part
  intro_part +
  format_content(section.content, section.defaults || {}) ->
  formatted
}

;; Generate document - structured until final conversion
voice typst.generate / {
  ;; Build structured document
  document_structure: {
    preamble: {
      page_width: "16cm",
      page_height: "24cm",
      font: "Latin Modern Roman",
      font_size: "11pt",
      math_numbering: "1."
    },
    title: "Bundle Dynamics and Curvature Bounds on `X × S^1`",
    intro: {
      type: text_content,
      content: "This note formalizes a simple bundle dynamics on a product space $\\tilde X = X \\times S^1$ and proves a basic curvature bound for a rotation–number field induced by the dynamics. It is intentionally minimal and pedagogical rather than exhaustive."
    },
    sections: [
      format_section(section_1),
      format_section(section_2),
      format_section(section_3),
      format_section(section_4)
    ]
  } ->
  ;; Convert structured document to Typst string (only at the end)
  typst.document_to_string(document_structure) ->
  complete_document
}

;; Convert structured document to Typst string (final step)
voice typst.document_to_string / {
  doc ->
  "#set page(width: " + doc.preamble.page_width + ", height: " + doc.preamble.page_height + ")" +
  "#set text(font: \"" + doc.preamble.font + "\", size: " + doc.preamble.font_size + "pt)" +
  "#set math.equation(numbering: \"" + doc.preamble.math_numbering + "\")" +
  "" +
  "= " + doc.title +
  "" +
  typst.text_to_string(doc.intro) +
  "" +
  map_section_to_string(doc.sections) ->
  typst_string
}

target bundle_dynamics / "bundle_dynamics_typst"
voice main / {
  typst.generate ->
  bundle_dynamics
}

