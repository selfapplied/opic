;;; hopic_codegen.ops â€” Generate implementations from hopic.ops operator spec

include runtime/hopic.ops
include core/codegen.ops
include systems/opic_compile.ops
include systems/language_template.ops

;; ============================================================================
;; CODE GENERATION PLAN
;; ============================================================================

;; Generate implementations from hopic.ops operators
;; Each operator becomes a function in the target language

;; ----------------------------------------------------------------------------
;; State Structure Generation
;; ----------------------------------------------------------------------------

;; Generate OPICState structure definition
voice hopic.gen_state_structure / {
  target_language -> 
  hopic.gen_state_fields -> 
  hopic.format_state_struct -> 
  state_structure_code
}

voice hopic.gen_state_fields / {
  -> 
  list_fields -> 
  format_fields -> 
  field_definitions
}

voice list_fields / {
  -> 
  "x_t" + "u_t" + "C_t" + "A_t" + "G_t" + "S_t" + 
  "zeta_array" + "W" + "Z_field" + "S_set" + "F_set" + 
  "H_region" + "R" + "Phi" + "t" + "dt" + "alpha" -> 
  field_list
}

voice hopic.format_state_struct / {
  field_list + target_language -> 
  hopic.format_structure -> 
  state_code
}

;; Common structure formatter (dispatches to language-specific)
voice hopic.format_structure / {
  field_list + target_language -> 
  hopic.select_structure_formatter -> 
  hopic.apply_structure_formatter -> 
  state_code
}

voice hopic.select_structure_formatter / {
  target_language -> 
  hopic.get_language_template -> 
  language_template
}

voice hopic.apply_structure_formatter / {
  field_list + language_template -> 
  hopic.format_structure_with_template -> 
  state_code
}

voice hopic.format_structure_with_template / {
  field_list + language_template -> 
  parse_fields -> 
  template.format_structure -> 
  state_code
}

;; Language-agnostic structure formatter
voice format_structure / {
  field_list + language + structure_type -> 
  parse_fields -> 
  format_structure_template -> 
  structure_code
}

;; ----------------------------------------------------------------------------
;; Operator Implementation Generation
;; ----------------------------------------------------------------------------

;; Generate implementation for a single operator
voice hopic.gen_operator / {
  operator_name + operator_voice + target_language -> 
  hopic.extract_signature -> 
  hopic.extract_update_rule -> 
  hopic.extract_invariants -> 
  hopic.generate_function -> 
  operator_code
}

voice hopic.extract_signature / {
  operator_voice -> 
  parse_voice_body -> 
  extract_inputs -> 
  extract_outputs -> 
  signature
}

voice hopic.extract_update_rule / {
  operator_voice -> 
  parse_voice_chain -> 
  extract_computation_steps -> 
  update_rule
}

voice hopic.extract_invariants / {
  operator_voice -> 
  find_invariant_comments -> 
  parse_invariants -> 
  invariants
}

voice hopic.generate_function / {
  operator_name + signature + update_rule + invariants + operator_metadata + target_language -> 
  hopic.create_function_template -> 
  hopic.format_function -> 
  function_code
}

voice hopic.create_function_template / {
  operator_name + signature + update_rule + invariants + operator_metadata -> 
  create_template -> 
  function_template
}

;; ----------------------------------------------------------------------------
;; Phase-Based Generation
;; ----------------------------------------------------------------------------

;; Phase 1: Foundation operators
voice hopic.gen_phase1 / {
  target_language -> 
  hopic.gen_operator "sigma.step" -> 
  hopic.gen_operator "C.op" -> 
  hopic.gen_operator "A.op" -> 
  hopic.gen_operator "G.op" -> 
  hopic.gen_operator "S.op" -> 
  hopic.gen_operator "zeta.trace" -> 
  combine_code -> 
  phase1_code
}

;; Phase 2: Dynamics operators
voice hopic.gen_phase2 / {
  target_language -> 
  hopic.gen_operator "zeta.coupler" -> 
  hopic.gen_operator "sigma.flow" -> 
  hopic.gen_operator "zeta.field_compose" -> 
  combine_code -> 
  phase2_code
}

;; Phase 3: Detection & Memory operators
voice hopic.gen_phase3 / {
  target_language -> 
  hopic.gen_operator "sigma.strength" -> 
  hopic.gen_operator "singularity.set_update" -> 
  hopic.gen_operator "fractal.closure" -> 
  combine_code -> 
  phase3_code
}

;; Phase 4: Resonance operators
voice hopic.gen_phase4 / {
  target_language -> 
  hopic.gen_operator "resonance.matrix" -> 
  hopic.gen_operator "field.potential" -> 
  hopic.gen_operator "harmony.flow" -> 
  combine_code -> 
  phase4_code
}

;; Phase 5: Field & Energy operators
voice hopic.gen_phase5 / {
  target_language -> 
  hopic.gen_operator "zeta.wave_step" -> 
  hopic.gen_operator "energy.density" -> 
  hopic.gen_operator "conservation.check" -> 
  hopic.gen_operator "opic.hamiltonian" -> 
  combine_code -> 
  phase5_code
}

;; Phase 6: Hopic condition
voice hopic.gen_phase6 / {
  target_language -> 
  hopic.gen_operator "hopic.check_vanishing_gradient" -> 
  phase6_code
}

;; ----------------------------------------------------------------------------
;; Common Template Interface
;; ----------------------------------------------------------------------------

;; Common template interface: all languages use the same signature
;; Language-specific formatting is handled through dispatch
def function_template {
  function_name,
  signature,
  body,
  invariants,
  operator_metadata
}

def operator_metadata {
  operator_id,
  symbol,
  type,
  role,
  update_rule
}

;; Common template formatter - dispatches to language-specific formatters
voice hopic.format_function / {
  function_template + target_language -> 
  hopic.select_language_formatter -> 
  hopic.apply_formatter -> 
  formatted_code
}

voice hopic.select_language_formatter / {
  target_language -> 
  hopic.get_language_template -> 
  language_template
}

voice hopic.apply_formatter / {
  function_template + language_template -> 
  hopic.format_with_template -> 
  formatted_code
}

;; Language-agnostic formatting pipeline
voice hopic.format_language / {
  function_template + language -> 
  hopic.format_documentation -> 
  hopic.format_signature -> 
  hopic.format_body -> 
  hopic.format_invariants -> 
  hopic.combine_sections -> 
  formatted_code
}

;; Common documentation formatter (dispatches to language-specific)
voice hopic.format_documentation / {
  operator_metadata + language -> 
  hopic.select_doc_formatter -> 
  hopic.apply_doc_formatter -> 
  documentation
}

voice hopic.select_doc_formatter / {
  language -> 
  hopic.get_language_template -> 
  language_template
}

voice hopic.apply_doc_formatter / {
  operator_metadata + language_template -> 
  hopic.format_documentation_with_template -> 
  documentation
}

;; Common signature formatter (dispatches to language-specific)
voice hopic.format_signature / {
  function_name + signature + language -> 
  hopic.select_sig_formatter -> 
  hopic.apply_sig_formatter -> 
  formatted_signature
}

voice hopic.select_sig_formatter / {
  language -> 
  hopic.get_language_template -> 
  language_template
}

voice hopic.apply_sig_formatter / {
  function_name + signature + language_template -> 
  hopic.format_signature_with_template -> 
  formatted_signature
}

;; Common body formatter (dispatches to language-specific)
voice hopic.format_body / {
  body + update_rule + language -> 
  hopic.select_body_formatter -> 
  hopic.apply_body_formatter -> 
  formatted_body
}

voice hopic.select_body_formatter / {
  language -> 
  hopic.get_language_template -> 
  language_template
}

voice hopic.apply_body_formatter / {
  body + update_rule + language_template -> 
  hopic.format_body_with_template -> 
  formatted_body
}

;; Common invariant formatter (dispatches to language-specific)
voice hopic.format_invariants / {
  invariants + language -> 
  hopic.select_invariant_formatter -> 
  hopic.apply_invariant_formatter -> 
  formatted_invariants
}

voice hopic.select_invariant_formatter / {
  language -> 
  hopic.get_language_template -> 
  language_template
}

voice hopic.apply_invariant_formatter / {
  invariants + language_template -> 
  hopic.format_invariants_with_template -> 
  formatted_invariants
}

;; Combine all sections into final code
voice hopic.combine_sections / {
  documentation + formatted_signature + formatted_body + formatted_invariants + language -> 
  format_code_structure -> 
  formatted_code
}

;; Use generalized language template system
voice hopic.get_language_template / {
  language -> 
  template.get -> 
  language_template
}

;; Single unified formatter (uses language template)
voice format.python / {
  function_template + language_template -> 
  hopic.format_with_template -> 
  formatted_code
}

voice format.rust / {
  function_template + language_template -> 
  hopic.format_with_template -> 
  formatted_code
}

voice format.typescript / {
  function_template + language_template -> 
  hopic.format_with_template -> 
  formatted_code
}

voice format.swift / {
  function_template + language_template -> 
  hopic.format_with_template -> 
  formatted_code
}

voice format.julia / {
  function_template + language_template -> 
  hopic.format_with_template -> 
  formatted_code
}

;; Unified formatting logic (works for all languages using template)
voice hopic.format_with_template / {
  function_template + language_template -> 
  hopic.format_documentation_with_template -> 
  hopic.format_signature_with_template -> 
  hopic.format_body_with_template -> 
  hopic.format_invariants_with_template -> 
  hopic.combine_code_sections -> 
  formatted_code
}

voice hopic.format_documentation_with_template / {
  operator_metadata + language_template -> 
  extract_metadata_fields -> 
  template.format_doc -> 
  documentation
}

voice hopic.format_signature_with_template / {
  function_name + signature + language_template -> 
  parse_signature -> 
  extract_params_and_return -> 
  template.format_signature -> 
  formatted_signature
}

voice hopic.format_body_with_template / {
  body + update_rule + language_template -> 
  parse_body -> 
  template.format_block -> 
  formatted_body
}

voice hopic.format_invariants_with_template / {
  invariants + language_template -> 
  parse_invariants -> 
  template.format_assert -> 
  formatted_invariants
}

voice hopic.combine_code_sections / {
  documentation + formatted_signature + formatted_body + formatted_invariants + language_template -> 
  format_code_structure -> 
  formatted_code
}

;; ----------------------------------------------------------------------------
;; Numerical Method Templates
;; ----------------------------------------------------------------------------

;; Euler time stepping
voice hopic.gen_euler_step / {
  x_t + f_function + dt -> 
  format_euler_update -> 
  euler_code
}

voice format_euler_update / {
  x_t + f_function + dt -> 
  "x_next = x_t + dt * f(x_t)" -> 
  euler_code
}

;; Finite differences
voice hopic.gen_finite_diff / {
  field + dimension -> 
  format_finite_diff -> 
  finite_diff_code
}

;; Trapezoidal integration
voice hopic.gen_trapezoidal / {
  function + a + b + n -> 
  format_trapezoidal -> 
  integration_code
}

;; ----------------------------------------------------------------------------
;; Main Generation Pipeline
;; ----------------------------------------------------------------------------

;; Generate complete implementation
voice hopic.generate_implementation / {
  hopic.ops_file + target_language + phase -> 
  hopic.parse_ops_file -> 
  hopic.gen_state_structure -> 
  hopic.gen_phase_code -> 
  hopic.add_numerical_methods -> 
  hopic.add_tests -> 
  complete_implementation
}

voice hopic.gen_phase_code / {
  phase + target_language -> 
  if_phase1 -> hopic.gen_phase1 -> 
  if_phase2 -> hopic.gen_phase2 -> 
  if_phase3 -> hopic.gen_phase3 -> 
  if_phase4 -> hopic.gen_phase4 -> 
  if_phase5 -> hopic.gen_phase5 -> 
  if_phase6 -> hopic.gen_phase6 -> 
  phase_code
}

voice hopic.add_numerical_methods / {
  implementation + target_language -> 
  hopic.gen_euler_step -> 
  hopic.gen_finite_diff -> 
  hopic.gen_trapezoidal -> 
  add_to_implementation -> 
  implementation_with_methods
}

voice hopic.add_tests / {
  implementation + operators -> 
  gen_unit_tests -> 
  gen_invariant_tests -> 
  gen_integration_tests -> 
  add_to_implementation -> 
  implementation_with_tests
}

;; ----------------------------------------------------------------------------
;; Code Generation from OPIC Spec
;; ----------------------------------------------------------------------------

;; Parse hopic.ops and generate code
voice hopic.codegen / {
  "systems/hopic.ops" + target_language -> 
  opic.parse_ops -> 
  hopic.extract_operators -> 
  hopic.generate_all_operators -> 
  hopic.combine_code -> 
  generated_code
}

voice hopic.extract_operators / {
  parsed_ops -> 
  find_voice_definitions -> 
  extract_operator_metadata -> 
  operators_list
}

voice hopic.generate_all_operators / {
  operators_list + target_language -> 
  for_each_operator -> 
  hopic.gen_operator -> 
  all_operator_code
}

voice hopic.combine_code / {
  state_structure_code + all_operator_code + numerical_methods + tests -> 
  format_header -> 
  combine_sections -> 
  format_footer -> 
  complete_code
}

;; ----------------------------------------------------------------------------
;; Runtime Generation
;; ----------------------------------------------------------------------------

;; Generate main runtime loop
voice hopic.gen_runtime / {
  target_language -> 
  hopic.gen_main_loop -> 
  hopic.gen_initialization -> 
  hopic.gen_step_function -> 
  runtime_code
}

voice hopic.gen_main_loop / {
  target_language -> 
  format_main_loop -> 
  main_loop_code
}

voice hopic.gen_step_function / {
  target_language -> 
  format_step_function -> 
  step_function_code
}

;; ----------------------------------------------------------------------------
;; Entry Point
;; ----------------------------------------------------------------------------

target hopic_codegen / "generated_implementation"
voice main / {
  target_language + phase -> 
  hopic.generate_implementation -> 
  hopic_codegen
}

