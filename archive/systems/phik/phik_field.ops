;;; phik_field.ops — Stabilizing Φκ-Field Construction
;;; Declarative definition of the potential landscape field
;;; Implementation: see phik_field_impl.ops
;;; Files auto-included: bootstrap primitives machine_encodings phik_field_impl

;; ============================================================================
;; 1. DOMAIN Ω
;; ============================================================================

;; Domain: discrete grid where field lives
def domain {
  shape: "(H, W)",
  grid: "Omega subset Z^2",
  interpretation: "2D array, token lattice, program structure, or square grid"
}

;; Create domain from shape
voice phik.create_domain / {H + W -> create_grid -> domain}
voice phik.create_grid / {H + W -> $numpy.zeros$ -> grid}

;; ============================================================================
;; 2. FOUR BASE CHANNELS
;; ============================================================================

;; Channel definitions
def intensity_channel {
  I: "intensity field",
  interpretation: "frequency, structural weight, or noise/pattern"
}

def alignment_channel {
  A: "alignment/direction field",
  interpretation: "gradient orientation, syntactic flow, or dependency direction"
}

def chroma_channel {
  C: "chroma/categorical cues",
  interpretation: "type class, role, or categorical channels (3-4 channels)"
}

def gradient_magnitude_channel {
  alpha: "gradient magnitude (structure)",
  interpretation: "magnitude of gradient, curvature of grammar"
}

;; Initialize channels from source data
voice phik.init_channels / {
  domain ->
  phik.init_intensity ->
  phik.init_alignment ->
  phik.init_chroma ->
  phik.init_gradient_magnitude ->
  channels
}

;; Initialize intensity (from noise/pattern or source data)
voice phik.init_intensity / {
  domain ->
  if_has_source -> phik.load_intensity_from_source
  if_no_source -> phik.generate_noise_pattern ->
  I
}

;; Initialize alignment from intensity gradient
voice phik.init_alignment / {
  I ->
  phik.compute_gradient_orientation ->
  A
}

;; Initialize chroma (categorical channels)
voice phik.init_chroma / {
  domain + num_channels ->
  phik.create_categorical_channels ->
  C
}

;; Initialize gradient magnitude
voice phik.init_gradient_magnitude / {
  I ->
  phik.compute_gradient_magnitude ->
  alpha
}

;; Compute gradient orientation
voice phik.compute_gradient_orientation / {
  I ->
  phik.compute_gx ->
  phik.compute_gy ->
  phik.atan2 ->
  A
}

;; Compute gradient components
voice phik.compute_gx / {
  I ->
  phik.slice_x_forward ->
  phik.slice_x_backward ->
  math.subtract ->
  gx
}

voice phik.compute_gy / {
  I ->
  phik.slice_y_forward ->
  phik.slice_y_backward ->
  math.subtract ->
  gy
}

;; Compute gradient magnitude: alpha = sqrt(gx^2 + gy^2)
voice phik.compute_gradient_magnitude / {
  I ->
  phik.compute_gx ->
  phik.compute_gy ->
  phik.compute_magnitude ->
  alpha
}

voice phik.compute_magnitude / {
  gx + gy ->
  math.power gx 2 ->
  math.power gy 2 ->
  math.add ->
  math.sqrt ->
  magnitude
}

;; ============================================================================
;; 3. FIELD CONSTRUCTION
;; ============================================================================

;; Φκ field: canonical form
def phik_field {
  formula: "Phi_kappa(x) = kappa_1*I(x) + kappa_2*A(x) - kappa_3*d_1(x,x_0) + kappa_4*alpha(x)",
  kappa_1: "weight for intensity (structure)",
  kappa_2: "weight for alignment (flow)",
  kappa_3: "weight for distance penalty (anchoring)",
  kappa_4: "weight for gradient magnitude (edges)",
  stability_condition: "kappa_1, kappa_2, kappa_4 > 0, kappa_3 > 0"
}

;; Compute Φκ field
voice phik.compute_field / {
  I + A + alpha + x_0 + kappa ->
  phik.compute_intensity_term ->
  phik.compute_alignment_term ->
  phik.compute_distance_term ->
  phik.compute_gradient_term ->
  phik.combine_terms ->
  Phi_kappa
}

;; Individual terms
voice phik.compute_intensity_term / {I + kappa_1 -> math.multiply -> term_1}
voice phik.compute_alignment_term / {A + kappa_2 -> math.multiply -> term_2}
voice phik.compute_distance_term / {
  x + x_0 ->
  phik.manhattan_distance ->
  math.multiply kappa_3 ->
  math.negate ->
  term_3
}
voice phik.compute_gradient_term / {alpha + kappa_4 -> math.multiply -> term_4}

;; Combine terms
voice phik.combine_terms / {
  term_1 + term_2 + term_3 + term_4 ->
  math.add_all ->
  Phi_kappa
}

;; Manhattan distance
voice phik.manhattan_distance / {
  x + x_0 ->
  math.subtract ->
  math.abs ->
  math.sum ->
  d_1
}

;; ============================================================================
;; 4. DERIVE FLOWS (Stability Dynamics)
;; ============================================================================

;; Alignment: A(x) = grad(Phi_kappa)
def alignment_field {
  A: "gradient of Phi_kappa",
  discrete: "A = grad(Phi_kappa)"
}

voice phik.compute_alignment / {
  Phi_kappa ->
  phik.compute_gradient ->
  A
}

;; Momentum: M(x) = partial_t A(x) = A - A_prev
def momentum_field {
  M: "time derivative of alignment",
  discrete: "M = A - A_prev"
}

voice phik.compute_momentum / {
  A + A_prev ->
  math.subtract ->
  M
}

;; Kinetics: K(x) = dPhi_kappa/dt = Phi_kappa - Phi_kappa_prev
def kinetics_field {
  K: "time derivative of Phi_kappa",
  discrete: "K = Phi_kappa - Phi_kappa_prev"
}

voice phik.compute_kinetics / {
  Phi_kappa + Phi_kappa_prev ->
  math.subtract ->
  K
}

;; Charge: Q(x) = div(A) = laplacian(Phi_kappa)
def charge_field {
  Q: "divergence of alignment",
  interpretation: "laplacian of Phi_kappa",
  discrete: "Q = laplacian(Phi_kappa)"
}

voice phik.compute_charge / {
  Phi_kappa ->
  phik.compute_laplacian ->
  Q
}

;; ============================================================================
;; 5. STABILITY CONDITION
;; ============================================================================

;; Stability check
def stability_condition {
  alignment_stable: "A stops changing",
  momentum_zero: "M -> 0",
  charge_stable: "Q stops flipping sign",
  kinetics_drift: "K tends toward small constant drift",
  criteria: "abs(M).mean() < epsilon AND abs(K).mean() < epsilon AND Q has consistent sign-structure"
}

;; Check stability
voice phik.check_stability / {
  M + K + Q + epsilon ->
  phik.check_momentum_stable ->
  phik.check_kinetics_stable ->
  phik.check_charge_stable ->
  phik.combine_stability_checks ->
  is_stable
}

voice phik.check_momentum_stable / {
  M + epsilon ->
  math.abs ->
  math.mean ->
  math.less_than epsilon ->
  momentum_stable
}

voice phik.check_kinetics_stable / {
  K + epsilon ->
  math.abs ->
  math.mean ->
  math.less_than epsilon ->
  kinetics_stable
}

voice phik.check_charge_stable / {
  Q ->
  phik.check_sign_consistency ->
  charge_stable
}

voice phik.combine_stability_checks / {
  momentum_stable + kinetics_stable + charge_stable ->
  phik.all_true ->
  is_stable
}

;; ============================================================================
;; 6. EVOLUTION
;; ============================================================================

;; Evolve field
voice phik.evolve / {
  Phi_kappa_0 ->
  phik.compute_flows ->
  phik.update_intensity ->
  phik.update_kappa ->
  Phi_kappa_next
}

;; Compute all flows
voice phik.compute_flows / {
  Phi_kappa ->
  phik.compute_alignment ->
  phik.compute_momentum ->
  phik.compute_kinetics ->
  phik.compute_charge ->
  flows
}

;; Update intensity: I = I + eta * Q (self-healing potential)
voice phik.update_intensity / {
  I + Q + eta ->
  math.multiply Q eta ->
  math.add I ->
  I_next
}

;; Update kappa weights (adaptive)
voice phik.update_kappa / {
  kappa + Q + A ->
  phik.adapt_kappa ->
  kappa_next
}

;; ============================================================================
;; 7. EMERGENT STRUCTURES
;; ============================================================================

;; What emerges from stable field
def emergent_structures {
  flow_corridors: "A (alignment field)",
  stable_attractors: "Phi_kappa (potential surface)",
  boundary_membranes: "Q (charge field)",
  momentum_strands: "M (momentum field)",
  witness_points: "symmetry breaks"
}

;; Extract emergent structures
voice phik.extract_structures / {
  Phi_kappa + A + M + Q ->
  phik.find_flow_corridors ->
  phik.find_attractors ->
  phik.find_boundaries ->
  phik.find_momentum_strands ->
  phik.find_witness_points ->
  structures
}

target phik_field / "stabilizing_phik_field"
voice main / phik.compute_field

