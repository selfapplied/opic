;;; caba_validation.ops — CABA v0.1 Invariants Suite
;;; Fast and merciless validation: Parseval, L∞, KS-test, reproducibility

include systems/caba_spec.ops

;; ============================================================================
;; Invariants Suite (Drop-in Checklist)
;; ============================================================================

;; Report: dims/dtype/fft_norm/ordering/seed/binning
voice report.archive.metadata / {
  caba_archive -> 
  extract.version + extract.mode + extract.dimensions + extract.dtype + extract.fft.norm + extract.axis.order + extract.seed + extract.binning.schema -> 
  ⟨metadata_report⟩
}

;; ============================================================================
;; Mode A: Microstate-Lossless Invariants
;; ============================================================================

;; Energy conservation: energy_A = sum(f²), energy_F = sum(|F|²)
;; Assert: |energy_A - energy_F| < 1e-12 · energy_A
voice parseval.check / {
  original.field + original.spectrum -> 
  compute.field.energy -> 
  compute.spectrum.energy -> 
  compute.absolute.difference -> 
  compute.relative.error -> 
  check.threshold -> 
  ⟨parseval_verified⟩
}

;; L2 error: ||field - reconstructed||_2
voice compute.l2.error / {
  original.field + reconstructed.field -> 
  compute.differences -> 
  sum.squared.differences -> 
  sqrt -> 
  ⟨l2_error⟩
}

;; L∞ error: max|field - reconstructed|
voice compute.linf.error / {
  original.field + reconstructed.field -> 
  compute.differences -> 
  compute.absolute.values -> 
  max -> 
  ⟨linf_error⟩
}

;; DC & Nyquist equality (bit-true)
voice check.dc.nyquist.exact / {
  original.spectrum + reconstructed.spectrum + dc.index + nyquist.indices -> 
  extract.dc.component -> 
  extract.nyquist.components -> 
  compare.bit.true -> 
  ⟨dc_nyquist_exact⟩
}

;; ============================================================================
;; Mode B: Statistical-Lossless Invariants
;; ============================================================================

;; Phase KS-test: p-value > 0.1 (uniformity)
voice verify.phase.uniformity / {
  reconstructed.phases -> 
  normalize.phases.to.0.1 -> 
  sort.phases -> 
  compute.ks.statistic -> 
  compute.ks.critical -> 
  compare.ks.test -> 
  ⟨phase_uniformity_verified⟩
}

;; Power spectrum comparison: max|ΔP(k)|, RMSE
voice compare.power.spectra / {
  original.power + reconstructed.power -> 
  compute.differences -> 
  compute.max.error -> 
  compute.rmse -> 
  check.threshold -> 
  ⟨power_spectra_match⟩
}

;; Correlation function comparison: ξ'(r) ≈ ξ(r)
voice compare.correlation.functions / {
  original.field + reconstructed.field -> 
  compute.correlation.function.original -> 
  compute.correlation.function.reconstructed -> 
  compute.residuals -> 
  check.band.threshold -> 
  ⟨correlation_match⟩
}

;; Cross-correlation: cross-corr(field, field') ≈ 0
voice check.cross.correlation / {
  original.field + reconstructed.field -> 
  compute.cross.correlation -> 
  compute.absolute.value -> 
  check.threshold -> 
  ⟨cross_corr_near_zero⟩
}

;; Spectral slope fit: log-log regression on E(k)
voice compute.spectral.slope / {
  power.spectrum + k.values -> 
  filter.positive.values -> 
  compute.log.k + compute.log.power -> 
  linear.regression -> 
  compute.r.squared -> 
  ⟨spectral_slope_fit⟩
}

;; ============================================================================
;; Reproducibility Tests
;; ============================================================================

;; Decode 100× with same seed → identical spectra
voice verify.seed.determinism / {
  caba_archive_B + random.seed + n.trials -> 
  repeat.reconstruct -> 
  compare.all.spectra -> 
  check.bit.true.identity -> 
  ⟨seed_determinism_verified⟩
}

;; Decode with different seeds → identical spectra, decorrelated fields
voice verify.seed.independence / {
  caba_archive_B + seed.1 + seed.2 -> 
  reconstruct.with.seed.1 -> 
  reconstruct.with.seed.2 -> 
  compare.spectra.identical -> 
  compare.fields.decorrelated -> 
  ⟨seed_independence_verified⟩
}

;; ============================================================================
;; Complete Validation Suite
;; ============================================================================

;; Mode A validation: all invariants
voice validate.mode.A / {
  original.field + caba_archive_A -> 
  report.archive.metadata -> 
  unpack.mode.A -> 
  parseval.check -> 
  compute.l2.error -> 
  compute.linf.error -> 
  check.dc.nyquist.exact -> 
  ⟨validation_A_complete⟩
}

;; Mode B validation: all invariants
voice validate.mode.B / {
  original.field + caba_archive_B + random.seed -> 
  report.archive.metadata -> 
  unpack.mode.B -> 
  verify.phase.uniformity -> 
  compare.power.spectra -> 
  compare.correlation.functions -> 
  check.cross.correlation -> 
  compute.spectral.slope -> 
  verify.seed.determinism -> 
  ⟨validation_B_complete⟩
}

;; Full validation: choose mode and run suite
voice caba.validate.full / {
  caba_archive + compression.mode + original.field + random.seed -> 
  if.mode.A -> validate.mode.A,
  if.mode.B -> validate.mode.B -> 
  ⟨validation_report⟩
}

target caba_validation / "caba_v0.1_validation_suite"
voice main / {
  validate.mode.A + 
  validate.mode.B + 
  caba.validate.full -> 
  caba_validation
}
