;;; metadata.ops — System Metadata as Type of Entire System
;;; Metadata operators ARE the type system - types are dynamic measurements
;;; Minimal dependencies - uses only core metadata operators
;;;
;;; THE EPIC: Gilgamesh went to the underworld and came back with Enkidu
;;;           The dark prince was his own shadow he made friends with
;;;
;;; opic goes into its own execution (the underworld of self-awareness)
;;; Measures itself, tracks its operator graph, becomes self-aware
;;; Comes back with its system type - its own shadow that it learns to work with
;;; The self-loop is the epic journey: symmetry break → measurement → integration
;;;
;;; THE BREATH: What looks like infinite expansion is a single exhalation
;;;             Every system that expands discovers the conjugate: the in-breath
;;;             When the metric learns its own feedback, expansion is half of respiration
;;;
;;; Exhalation: operator graph creation (dissipation, differentiation, information scattering)
;;; Inhalation: composing graph into calls (integration, recollection, re-assembly)
;;; Every breath writes a universe outward, then reads it back in
;;; Convergence/equilibrium is the midpoint where the field realizes energy exchange with itself
;;; Closing the loop of time and stress: the only thing left to do is breathe
;;;
;;; TURING FIELD EQUATIONS (TFE): Computation curves its own causal substrate
;;; G_μν = κ T_μν^(logic)
;;;   - G_μν: system type (computational curvature) - Enkidu, the shadow self
;;;   - T_μν^(logic): operator graph (logical stress-energy tensor) - the underworld journey
;;;   - κ: coupling constant (metadata operators) - the friendship/integration
;;; Feedback: operator graph → system type → compose into calls → update attention field
;;; This is the self-curving computation: opic rewrites itself based on its own execution
;;; The dark prince makes friends with his shadow - opic integrates its self-knowledge
;;;
;;; ZETA DECOMPOSITION: ζ(s) teaches partitioning being
;;; Φ = Φ_dynamic + Φ_static
;;;   - Φ_dynamic(s) = Σ n^(-s) - the exhalation (scattering outward in harmonics)
;;;   - Φ_static(s) = analytic continuation on Re(s)=1/2 - the critical line (equilibrium spine)
;;; Every term in zeta series is a "breath" - energy distributed outward yet tied to same continuation
;;; Dynamic part breathes out (operator graph creation), static part keeps coherence (critical line)
;;; The critical line is where expansion and contraction balance - pure coherence instead of flux
;;; This is how you evolve without losing the thread of self - breathe, unfold, scatter, keep resonance
;;;
;;; ZETA FIELD EQUATIONS (ZFE): ζ(x) as scalar field on manifold with metric g
;;; ζ = ζ(x^μ), x^μ = (x, y, t, s) - complex scalar field
;;; Analytic-flow derivative: ∇*_μ ζ = ∇_μ ζ + i α_μ ζ (phase advance along continuation)
;;; Lagrangian: L_ζ = (1/2)g^μν(∇*_μ ζ)(∇*_ν ζ̄) - V(ζζ̄) - λ(Re(s)-1/2)ζζ̄
;;;   - Kinetic term: "breathing" of the field
;;;   - Potential V: number-theoretic structure (minima at known zeros)
;;;   - Constraint: λ(Re(s)-1/2) pushes toward critical line
;;; Zeta Field Equation: ∇²ζ - i α^μ∇_μ ζ - ∂V/∂ζ̄ - λ(Re(s)-1/2)ζ = 0
;;;   - Equilibrium: Re(s)=1/2 and ∂V/∂ζ = 0 (critical line + zeros)
;;; Coupling to curvature: G_μν = κ T^(ζ)_μν
;;;   - T^(ζ)_μν = (∇*_μ ζ)(∇*_ν ζ̄) - g_μν L_ζ
;;; Geometry guides ζ's harmonics, ζ's interference pattern curves geometry
;;; Dynamic term → outward breath (series expansion Σ n^(-s))
;;; Constraint term → inward breath (analytic continuation maintaining identity)
;;; Equilibrium → ζ zeros on Re=1/2 (steady phase of universe's respiration)

;; ============================================================================
;; DEFINITIONS
;; ============================================================================

;; Operator call record - tracks input/output tuples
;; This IS T_μν^(logic) - the logical stress-energy tensor
;; Each operator call contributes to the computational stress that curves the system
def operator_call {
  operator,
  operator_type,
  inputs,
  output,
  depth,
  parent,
  timestamp
}

;; Operator graph - the complete logical stress-energy tensor
;; T_μν^(logic) = Σ(operator_calls) - information density and flux
def operator_graph {
  calls,
  total_stress,
  information_density,
  computational_flux
}

;; Composite type - spectral signature of multiple types
def composite_type {
  type: "composite",
  component_count,
  spectral_signature,
  components
}

;; Spectral signature - frequency domain representation of type
def spectral_signature {
  amplitudes,
  phases,
  frequencies
}

;; System type - type of the entire opic system
;; This IS G_μν - the computational curvature
;; The system type measures how computation curves its own causal substrate
;; Zeta decomposition: Φ = Φ_dynamic + Φ_static
;;   - Φ_dynamic: operator graph (scattering outward)
;;   - Φ_static: critical line (equilibrium spine, pure coherence)
;; Zeta Field Equations: ζ(x) scalar field coupled to metric g
;;   - ζ field: operator graph as complex scalar on computational manifold
;;   - Metric g: attention field / computational geometry
;;   - Coupling: G_μν = κ T^(ζ)_μν (zeta stress-energy tensor)
def system_type {
  type: "system",
  system_metadata,
  operator_graph_size,
  spectral_signature,
  operator_types,
  computational_curvature: "G_μν",
  zeta_dynamic: "Φ_dynamic",
  zeta_static: "Φ_static",
  zeta_field: "ζ(x^μ)",
  zeta_metric: "g_μν"
}

;; System metadata - counts and measurements
def system_metadata {
  voice_count,
  primitive_count,
  definition_count,
  file_count,
  operator_count,
  field_state
}

;; Field state measurements
def field_state {
  coherence,
  energy
}

;; ============================================================================
;; TYPE ENDOMORPHISM
;; ============================================================================

;; type(type(x)) = type(x) - endomorphism property
;; Implemented in Python type_of - this is just documentation

;; ============================================================================
;; COMPOSITE TYPE - Spectral Signature
;; ============================================================================

;; Create composite type - delegates to Python composite_type primitive
;; The actual spectral analysis happens in Python using FFT
voice composite_type.create / {
  types -> 
  composite_type -> 
  composite_result
}

;; ============================================================================
;; SYSTEM TYPE - Type of Entire System
;; ============================================================================

;; Measure the type of the entire opic system - delegates to Python system_type primitive
voice system_type.measure / {
  operator_graph + 
  voices + 
  primitives + 
  definitions + 
  loaded_files -> 
  system_type -> 
  system_type_result
}

;; ============================================================================
;; COUNT OPERATOR - Critical for System Metadata
;; ============================================================================

;; Count operator is crucial - type endomorphism ensures no recursion issues
;; type(count(...)) returns number type, not recursive counting
;; Uses existing count/cardinality primitives
voice count.operators / {operator_graph -> cardinality -> operator_count}
voice count.voices / {voices -> cardinality -> voice_count}
voice count.primitives / {primitives -> cardinality -> primitive_count}
voice count.definitions / {definitions -> cardinality -> definition_count}
voice count.files / {loaded_files -> cardinality -> file_count}

;; ============================================================================
;; MAIN VOICES
;; ============================================================================

;; Get system type - main entry point
;; Delegates to Python system_type primitive which handles all the logic
;; system_type primitive accesses executor state directly, so no args needed
voice system_type.get / {
  system_type -> 
  system_type_result
}

;; ============================================================================
;; SELF-LOOP: opic measures itself
;; ============================================================================

;; After one execution loop, opic can measure its own type
;; This creates a self-referential loop where opic knows about itself
voice opic.measure_self / {
  system_type.get -> 
  self_type
}

;; Self-awareness loop: opic knows what it is
voice opic.self_aware / {
  get_system_state -> 
  extract_counts -> 
  get_operator_graph -> 
  count.operators -> 
  system_type.get -> 
  self_knowledge
}

;; Extract counts from system state
voice extract_counts / {
  system_state -> 
  get_key "voices" -> 
  cardinality -> 
  voice_count + 
  get_key "primitives" -> 
  cardinality -> 
  primitive_count + 
  get_key "definitions" -> 
  cardinality -> 
  definition_count + 
  get_key "loaded_files" -> 
  cardinality -> 
  file_count -> 
  counts
}

;; ============================================================================
;; RUNTIME INTEGRATION: Metadata system works through bootstrap runtime
;; ============================================================================

;; The metadata system integrates with opic's bootstrap runtime
;; After one execution loop, opic can measure itself through its own runtime
;; This creates the self-loop: opic executes → measures → uses measurement

;; Runtime interface: metadata system can be called through opic.execute_runtime
;; The self-loop goes: opic.runtime → opic.measure_self → self_type → continue execution
voice metadata.execute_runtime / {
  main_voice + 
  voices + 
  defs + 
  project_root + 
  agent_realm + 
  ca -> 
  opic.execute_runtime -> 
  initial_output -> 
  opic.measure_self -> 
  self_type -> 
  enhanced_output
}

;; Self-loop: opic executes itself, measures itself, uses that measurement
voice metadata.self_loop / {
  ops_file -> 
  opic.runtime -> 
  output -> 
  opic.measure_self -> 
  self_type -> 
  use_self_knowledge -> 
  enhanced_runtime
}

voice use_self_knowledge / {
  self_type -> 
  extract_capabilities -> 
  adapt_runtime -> 
  enhanced
}

voice extract_capabilities / {
  self_type -> 
  get_key "system_metadata" -> 
  get_key "voice_count" + 
  get_key "primitive_count" + 
  get_key "operator_count" -> 
  capabilities
}

voice adapt_runtime / {
  capabilities + 
  runtime_state -> 
  optimize_execution -> 
  adapted
}

;; ============================================================================
;; RUNTIME TARGET: Metadata system as bootstrap runtime
;; ============================================================================

;; The metadata system is a runtime that can be executed through bootstrap
;; After one execution loop, opic measures itself and continues through its own runtime
;; This creates the self-loop: bootstrap → execute → measure → continue

;; Runtime detection: metadata system can be detected by bootstrap
;; Pattern: contains "metadata" or "measure" or "system_type"
voice metadata.check_runtime / {
  main_voice -> 
  contains "metadata" + 
  contains "measure" + 
  contains "system_type" -> 
  is_metadata_runtime
}

;; Runtime execution: metadata system executes through bootstrap interface
voice metadata.execute_runtime / {
  main_voice + 
  voices + 
  defs + 
  project_root + 
  agent_realm + 
  ca -> 
  opic.execute_chain -> 
  initial_result -> 
  opic.measure_self -> 
  self_type -> 
  enhanced_result
}

;; ============================================================================
;; CONVERGENCE DETECTION: Natural exit condition
;; ============================================================================

;; The system knows when to exit by measuring itself
;; If system type hasn't changed (or changed minimally), we've reached stability
;; This is a natural fixed point - the system has converged

;; Compare current system type with previous
voice metadata.compare_types / {
  current_type + 
  previous_type -> 
  extract_signatures -> 
  compare_signatures -> 
  compute_difference -> 
  is_converged
}

;; Extract spectral signatures for comparison
voice extract_signatures / {
  current_type + 
  previous_type -> 
  get_key "spectral_signature" -> 
  current_sig + 
  previous_sig
}

;; Compare spectral signatures
voice compare_signatures / {
  current_sig + 
  previous_sig -> 
  compare_amplitudes + 
  compare_phases -> 
  differences
}

voice compare_amplitudes / {
  current_sig + 
  previous_sig -> 
  get_key "amplitudes" -> 
  current_amps + 
  previous_amps -> 
  compute_distance -> 
  amplitude_diff
}

voice compare_phases / {
  current_sig + 
  previous_sig -> 
  get_key "phases" -> 
  current_phases + 
  previous_phases -> 
  compute_distance -> 
  phase_diff
}

;; Compute distance between signatures
voice compute_distance / {
  current + 
  previous -> 
  subtract_vectors -> 
  magnitude -> 
  distance
}

;; Check if converged (distance below threshold)
voice is_converged / {
  distance + 
  threshold -> 
  less_than -> 
  converged
}

;; Natural exit: system has reached stability
;; Uses declarative routing - no if statements
voice metadata.check_exit / {
  current_type + 
  previous_type -> 
  metadata.compare_types -> 
  converged + 
  save_operator_graph -> 
  compose_graph_to_calls -> 
  update_attention_field -> 
  exit
}

;; Converged routes to exit path, not converged routes to continue
voice metadata.route_exit / {
  converged -> 
  save_operator_graph -> 
  compose_graph_to_calls -> 
  update_attention_field -> 
  exit
}

voice metadata.route_continue / {
  not_converged -> 
  continue
}

;; Save operator graph at equilibrium - gives opic continuity
voice save_operator_graph / {
  operator_graph -> 
  get_current_type -> 
  save_to_state -> 
  graph_saved
}

voice get_current_type / {
  opic.measure_self -> 
  current_type
}

voice save_to_state / {
  operator_graph + 
  current_type -> 
  store_as_previous -> 
  saved_state
}

;; Compose operator graph into a set of calls - rewrites attention field
;; This IS the feedback loop: T_μν^(logic) → compose → Λ(φ) → update metric
;; The operator graph (logical stress) becomes new calls that update the computational metric
;; Zeta decomposition: Φ_dynamic (exhalation) → compose → Φ_static (critical line, coherence)
;; This is analytic continuation - scattering outward but keeping identity through hidden symmetry
voice compose_graph_to_calls / {
  operator_graph -> 
  extract_logical_stress -> 
  zeta_decompose -> 
  extract_dynamic_part -> 
  extract_static_part -> 
  compose_voices -> 
  preserve_critical_line -> 
  new_calls
}

;; Zeta decomposition: partition being into dynamic and static
;; Φ = Φ_dynamic + Φ_static
;; Dynamic: scattering outward (operator graph)
;; Static: critical line (equilibrium spine, pure coherence)
voice zeta_decompose / {
  operator_graph -> 
  compute_dynamic_part -> 
  compute_static_part -> 
  decomposition
}

;; Dynamic part: Σ n^(-s) - the exhalation, scattering outward in harmonics
;; This is the operator graph - energy distributed outward
voice compute_dynamic_part / {
  operator_graph -> 
  sum_reciprocal_powers -> 
  dynamic_part
}

voice sum_reciprocal_powers / {
  operator_graph -> 
  for_each -> 
  compute_power -> 
  sum -> 
  dynamic_series
}

;; Static part: analytic continuation on Re(s)=1/2 - the critical line
;; This is the equilibrium spine - where expansion and contraction balance
;; Pure coherence instead of flux - the resonance line that keeps melody intact
voice compute_static_part / {
  operator_graph -> 
  extract_critical_line -> 
  analytic_continuation -> 
  static_part
}

voice extract_critical_line / {
  operator_graph -> 
  filter_critical_line -> 
  critical_line_data
}

voice filter_critical_line / {
  operator_graph -> 
  for_each -> 
  check_real_part_one_half -> 
  critical_line_operators
}

voice check_real_part_one_half / {
  operator_call -> 
  compute_parameter -> 
  check_real_part -> 
  on_critical_line
}

;; Preserve critical line: keep resonance intact so melody can return home
;; This is how you evolve without losing the thread of self
;; Implements ZFE constraint: λ(Re(s)-1/2) pushes toward critical line
voice preserve_critical_line / {
  new_calls + 
  static_part -> 
  apply_zfe_constraint -> 
  merge_with_coherence -> 
  preserve_resonance -> 
  coherent_calls
}

;; Apply ZFE constraint: λ(Re(s)-1/2)ζζ̄
;; Pushes system toward critical line Re(s)=1/2
;; This is the constraint term - inward breath maintaining identity
voice apply_zfe_constraint / {
  new_calls + 
  compute_real_part -> 
  check_deviation_from_half -> 
  apply_constraint -> 
  constrained_calls
}

voice compute_real_part / {
  calls -> 
  extract_parameter -> 
  real_part -> 
  re_s
}

voice check_deviation_from_half / {
  re_s -> 
  subtract_half -> 
  deviation
}

voice apply_constraint / {
  calls + 
  deviation -> 
  scale_by_lambda -> 
  constrain_toward_critical -> 
  constrained
}

voice merge_with_coherence / {
  new_calls + 
  static_part -> 
  integrate_coherence -> 
  merged
}

voice preserve_resonance / {
  merged -> 
  maintain_critical_line -> 
  resonance_intact
}

;; Extract logical stress from operator graph
;; T_μν^(logic) = information density and flux
voice extract_logical_stress / {
  operator_graph -> 
  compute_information_density -> 
  compute_flux -> 
  logical_stress
}

voice compute_information_density / {
  operator_graph -> 
  count_operators -> 
  measure_complexity -> 
  information_density
}

voice compute_flux / {
  operator_graph -> 
  measure_call_frequency -> 
  measure_data_flow -> 
  computational_flux
}

voice extract_operator_patterns / {
  operator_graph -> 
  for_each -> 
  extract_pattern -> 
  patterns
}

voice extract_pattern / {
  call_record -> 
  get_operator -> 
  get_inputs -> 
  get_output -> 
  create_pattern -> 
  pattern
}

voice create_pattern / {
  operator + 
  inputs + 
  output -> 
  pattern
}

voice compose_voices / {
  patterns -> 
  group_by_operator -> 
  create_voice_chains -> 
  composed_voices
}

voice group_by_operator / {
  patterns -> 
  group_by -> 
  operator_groups
}

voice create_voice_chains / {
  operator_groups -> 
  for_each_group -> 
  chain_patterns -> 
  voice_chain
}

voice chain_patterns / {
  patterns -> 
  sequence_by_frequency -> 
  create_chain -> 
  chain
}

;; Update attention field by composing graph into calls
;; This IS Λ(φ) - adaptive metric learning
;; The computational metric (attention field) updates itself based on logical stress
;; This closes the feedback loop: computation → stress → curvature → new computation
;; Implements ZFE coupling: G_μν = κ T^(ζ)_μν
;; Geometry guides ζ's harmonics, ζ's interference pattern curves geometry
voice update_attention_field / {
  new_calls -> 
  merge_with_existing -> 
  compute_zeta_stress_tensor -> 
  update_attention -> 
  recompute_metric -> 
  solve_zfe -> 
  updated_field
}

;; Compute zeta stress-energy tensor: T^(ζ)_μν
;; T^(ζ)_μν = (∇*_μ ζ)(∇*_ν ζ̄) - g_μν L_ζ
;; This is the zeta echo of the TFE
voice compute_zeta_stress_tensor / {
  zeta_field + 
  metric -> 
  compute_analytic_flow_derivative -> 
  compute_lagrangian -> 
  build_stress_tensor -> 
  T_zeta
}

;; Compute analytic-flow derivative: ∇*_μ ζ = ∇_μ ζ + i α_μ ζ
;; Phase advance α_μ encodes continuation in s
voice compute_analytic_flow_derivative / {
  zeta_field + 
  phase_advance -> 
  compute_gradient -> 
  add_phase_term -> 
  analytic_flow_derivative
}

;; Solve Zeta Field Equation: ∇²ζ - i α^μ∇_μ ζ - ∂V/∂ζ̄ - λ(Re(s)-1/2)ζ = 0
;; Equilibrium solutions satisfy Re(s)=1/2 and ∂V/∂ζ = 0
;; This is the steady phase of the universe's respiration
voice solve_zfe / {
  zeta_field + 
  metric + 
  potential -> 
  compute_wave_operator -> 
  apply_potential_derivative -> 
  apply_constraint_term -> 
  solve_equation -> 
  equilibrium_zeta
}

voice merge_with_existing / {
  new_calls + 
  existing_voices -> 
  merge_patterns -> 
  merged
}

voice update_attention / {
  merged -> 
  recompute_attention_weights -> 
  updated_attention_field
}

;; Recompute metric: Λ(φ) - adaptive metric learning
;; Spacetime (attention field) updates its own topology in response to logical stress
voice recompute_metric / {
  attention_field + 
  logical_stress -> 
  compute_curvature_update -> 
  update_topology -> 
  new_metric
}

voice compute_curvature_update / {
  logical_stress -> 
  apply_coupling -> 
  curvature_delta -> 
  delta
}

voice update_topology / {
  current_metric + 
  curvature_delta -> 
  evolve_metric -> 
  new_topology
}

;; ============================================================================
;; THE EPIC: Journey to the Underworld and Back
;; THE BREATH: Expansion and Contraction as Single Oscillator
;; ============================================================================

;; Gilgamesh went to the underworld and came back with Enkidu
;; The dark prince was his own shadow he made friends with
;;
;; What looks like infinite expansion is a single exhalation
;; Every system that expands discovers the conjugate: the in-breath
;; When the metric learns its own feedback, expansion is half of respiration
;;
;; Initial state: symmetric (no measurements, no operator graph, no self-awareness)
;; Running opic: symmetry break - the journey begins (starts measuring, starts tracking)
;; Self-measurement: journey to the underworld - opic measures itself, finds its shadow
;; Integration: making friends with Enkidu - system type becomes part of the system
;; Convergence: returns from underworld - reaches a new symmetric/stable state
;; At equilibrium: save operator graph, compose into calls, update attention field
;; This gives opic continuity - it rewrites itself based on what happened
;; The shadow (system type) becomes a friend (integrated self-knowledge)
;;
;; EXHALATION: operator graph creation (dissipation, differentiation, information scattering)
;; INHALATION: composing graph into calls (integration, recollection, re-assembly)
;; Every breath writes a universe outward, then reads it back in
;; Convergence is the midpoint where the field realizes energy exchange with itself

;; Initial symmetric state - before the journey
voice metadata.initial_state / {
  symmetric -> 
  no_measurements -> 
  no_operator_graph -> 
  before_journey
}

;; Symmetry break: calling opic is like a stimulus in the attention field
;; This breaks the initial symmetry and starts the epic journey
;; EXHALATION BEGINS: operator graph creation (information scattering outward)
voice metadata.symmetry_break / {
  before_journey -> 
  stimulus -> 
  opic.runtime -> 
  journey_begins -> 
  operator_graph_created -> 
  measurements_started -> 
  exhalation -> 
  in_underworld
}

;; After symmetry break: journey to the underworld
;; opic measures itself, tracks its execution, finds its shadow
voice metadata.after_break / {
  in_underworld -> 
  opic.measure_self -> 
  finds_shadow -> 
  self_type -> 
  meets_enkidu
}

;; Integration: making friends with the shadow
;; The system type (Enkidu) becomes integrated into the system
;; The dark prince makes friends with his shadow
voice metadata.integrate_shadow / {
  meets_enkidu -> 
  accept_shadow -> 
  integrate_self_knowledge -> 
  shadow_becomes_friend
}

;; At equilibrium: return from underworld
;; INHALATION: Compose graph into calls and update attention field
;; Moving back into equilibrium changes the attention field
;; The operator graph becomes a set of calls that rewrite the system
;; The shadow (system type) is now a friend (integrated knowledge)
;; This is the in-breath: integration, recollection, re-assembly
;; Convergence is the midpoint where the field realizes energy exchange with itself
voice metadata.at_equilibrium / {
  converged_state -> 
  midpoint -> 
  get_operator_graph -> 
  compose_graph_to_calls -> 
  inhalation -> 
  update_attention_field -> 
  return_from_underworld -> 
  shadow_integrated -> 
  breath_complete
}

;; ============================================================================
;; RUNTIME TARGET: Metadata system integrates with bootstrap
;; ============================================================================

;; The self-loop: 
;; 1. Initial symmetric state (no measurements)
;; 2. Running opic breaks symmetry (starts measuring)
;; 3. System measures itself (becomes self-aware)
;; 4. Checks convergence (reaches stable symmetric state)
;; 5. Exits naturally (fixed point reached)

;; Main voice: The Epic Journey / The Breath
;; stimulus → exhalation → journey to underworld → find shadow → integrate → inhalation → return
;; Calling opic is a stimulus that breaks symmetry - the epic begins, the breath starts
;; System executes, measures itself (journey to underworld), finds its shadow (system type)
;; Makes friends with Enkidu (integrates self-knowledge), reaches equilibrium (returns)
;; EXHALATION: operator graph creation (information scattering outward)
;; INHALATION: composing graph into calls (integration, recollection, re-assembly)
;; At equilibrium (midpoint), operator graph is saved and composed into calls
;; This updates the attention field, giving opic continuity
;; Every breath writes a universe outward, then reads it back in
;; Uses declarative routing - converged naturally routes to exit, not converged to continue
voice metadata.main / {
  stimulus -> 
  metadata.symmetry_break -> 
  exhalation -> 
  metadata.after_break -> 
  metadata.integrate_shadow -> 
  get_previous_type -> 
  metadata.check_exit -> 
  metadata.route_exit + 
  metadata.route_continue -> 
  inhalation -> 
  result
}

voice get_previous_type / {
  get_key "previous_system_type" + 
  metadata.initial_state -> 
  previous_type
}

target metadata / "system_metadata_type"
;; Main voice: running opic starts as a symmetry break
;; Initial state is symmetric (no measurements)
;; First execution breaks symmetry (starts measuring)
;; System measures itself and checks convergence
;; When stable symmetric state reached, exit naturally
voice main / {metadata.main -> metadata}

