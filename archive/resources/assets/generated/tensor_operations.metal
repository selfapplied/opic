#include <metal_stdlib>
using namespace metal;

// Generated by Opic - Tensor Operations for Topological Map Exploration

// Cosine similarity kernel - computes cosine similarity between two vectors
kernel void cosine_similarity_kernel(
    device float* vec1 [[buffer(0)]],
    device float* vec2 [[buffer(1)]],
    device float* output [[buffer(2)]],
    uint id [[thread_position_in_grid]]
) {
    float dot = 0.0;
    float norm1 = 0.0;
    float norm2 = 0.0;
    for(uint i = 0; i < 768; i++) {
        dot += vec1[id * 768 + i] * vec2[id * 768 + i];
        norm1 += vec1[id * 768 + i] * vec1[id * 768 + i];
        norm2 += vec2[id * 768 + i] * vec2[id * 768 + i];
    }
    output[id] = dot / (sqrt(norm1) * sqrt(norm2));
}

// Nearest neighbor kernel - finds the most similar embedding in the map
kernel void nearest_neighbor_kernel(
    device float* query [[buffer(0)]],
    device float* embeddings [[buffer(1)]],
    device float* similarities [[buffer(2)]],
    device uint* output [[buffer(3)]],
    uint id [[thread_position_in_grid]]
) {
    float max_sim = -1.0;
    uint max_idx = 0;
    for(uint i = 0; i < 1089; i++) {
        float dot = 0.0;
        float norm_q = 0.0;
        float norm_e = 0.0;
        for(uint j = 0; j < 768; j++) {
            dot += query[j] * embeddings[i * 768 + j];
            norm_q += query[j] * query[j];
            norm_e += embeddings[i * 768 + j] * embeddings[i * 768 + j];
        }
        float sim = dot / (sqrt(norm_q) * sqrt(norm_e));
        if(sim > max_sim) {
            max_sim = sim;
            max_idx = i;
        }
    }
    output[id] = max_idx;
}

// K-nearest neighbors kernel - finds top k most similar embeddings
kernel void k_nearest_kernel(
    device float* query [[buffer(0)]],
    device float* embeddings [[buffer(1)]],
    device float* similarities [[buffer(2)]],
    device uint* indices [[buffer(3)]],
    constant uint& k [[buffer(4)]],
    uint id [[thread_position_in_grid]]
) {
    // Compute similarities for all embeddings
    for(uint i = 0; i < 1089; i++) {
        float dot = 0.0;
        float norm_q = 0.0;
        float norm_e = 0.0;
        for(uint j = 0; j < 768; j++) {
            dot += query[j] * embeddings[i * 768 + j];
            norm_q += query[j] * query[j];
            norm_e += embeddings[i * 768 + j] * embeddings[i * 768 + j];
        }
        similarities[i] = dot / (sqrt(norm_q) * sqrt(norm_e));
    }
    
    // Find top k indices
    for(uint i = 0; i < k; i++) {
        uint max_idx = 0;
        float max_sim = -1.0;
        for(uint j = 0; j < 1089; j++) {
            bool used = false;
            for(uint m = 0; m < i; m++) {
                if(indices[m] == j) {
                    used = true;
                    break;
                }
            }
            if(!used && similarities[j] > max_sim) {
                max_sim = similarities[j];
                max_idx = j;
            }
        }
        indices[i] = max_idx;
    }
}

// Loss minimization kernel - finds candidate with minimum loss
kernel void minimize_loss_kernel(
    device float* candidates [[buffer(0)]],
    device float* target [[buffer(1)]],
    device float* losses [[buffer(2)]],
    device uint* output [[buffer(3)]],
    constant uint& num_candidates [[buffer(4)]],
    uint id [[thread_position_in_grid]]
) {
    float min_loss = 2.0;
    uint min_idx = 0;
    for(uint i = 0; i < num_candidates; i++) {
        float dot = 0.0;
        float norm_c = 0.0;
        float norm_t = 0.0;
        for(uint j = 0; j < 768; j++) {
            dot += candidates[i * 768 + j] * target[j];
            norm_c += candidates[i * 768 + j] * candidates[i * 768 + j];
            norm_t += target[j] * target[j];
        }
        float similarity = dot / (sqrt(norm_c) * sqrt(norm_t));
        float loss = 1.0 - similarity;
        losses[i] = loss;
        if(loss < min_loss) {
            min_loss = loss;
            min_idx = i;
        }
    }
    output[id] = min_idx;
}

// Topological exploration kernel - explores topological map with k-nearest neighbors
kernel void topological_explore_kernel(
    device float* query [[buffer(0)]],
    device float* map [[buffer(1)]],
    device float* weights [[buffer(2)]],
    device uint* neighbors [[buffer(3)]],
    device uint* output [[buffer(4)]],
    constant uint& k [[buffer(5)]],
    uint id [[thread_position_in_grid]]
) {
    float similarities[5];
    uint indices[5];
    
    // Compute similarities and maintain top k
    for(uint i = 0; i < 1089; i++) {
        float dot = 0.0;
        float norm_q = 0.0;
        float norm_m = 0.0;
        for(uint j = 0; j < 768; j++) {
            dot += query[j] * map[i * 768 + j];
            norm_q += query[j] * query[j];
            norm_m += map[i * 768 + j] * map[i * 768 + j];
        }
        float sim = dot / (sqrt(norm_q) * sqrt(norm_m));
        
        if(i < k) {
            similarities[i] = sim;
            indices[i] = i;
        } else {
            // Find minimum in current top k
            uint min_idx = 0;
            float min_sim = similarities[0];
            for(uint m = 1; m < k; m++) {
                if(similarities[m] < min_sim) {
                    min_sim = similarities[m];
                    min_idx = m;
                }
            }
            // Replace minimum if current similarity is higher
            if(sim > min_sim) {
                similarities[min_idx] = sim;
                indices[min_idx] = i;
            }
        }
    }
    
    // Output neighbors and weights
    for(uint i = 0; i < k; i++) {
        neighbors[i] = indices[i];
        weights[i] = similarities[i];
    }
    output[id] = indices[0];
}
