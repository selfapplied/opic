{
  "comment_code_pairs": [
    {
      "comment": "Maps biological concepts to field equations.\nShows that biology = Field Spec 0.7 at different scales.",
      "code": "class BiologyFieldMapper:\n    \"\"\"\n    Maps biological concepts to field equations.\n    Shows that biology = Field Spec 0.7 at different scales.\n    \"\"\"\n    \n    def __init__(self, project_root: Path):\n        self.project_root = project_root\n        self.opic = OpicExecutor(project_root)\n        \n        # Scale-to-dimension mapping\n        self.scale_dimensions = {\n            \"molecular\": 2.5,      # Chemistry, bonds\n            \"genetic\": 3.5,       # DNA, genes, alleles\n            \"hormonal",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 16,
      "alignment": 0.5060507647570999,
      "coherence": 0.5060507647570999,
      "comment_phi_k": 21.70198412698413,
      "code_phi_k": 907.5138519738542
    },
    {
      "comment": "Test biology field mapper",
      "code": "def main():\n    \"\"\"Test biology field mapper\"\"\"\n    project_root = Path(__file__).parent.parent\n    mapper = BiologyFieldMapper(project_root)\n    \n    print(\"=\" * 70)\n    print(\"Biology Field Mapper\")\n    print(\"=\" * 70)\n    print(\"\\nMapping: Biology = Field Equations at Different Scales\")\n    print(\"\\n\" + \"=\" * 70)\n    \n    # Example questions\n    examples = [\n        \"How do hormones work?\",\n        \"What is genetic inheritance?\",\n        \"How do enzymes catalyze reactions?\",\n        \"What is ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 281,
      "alignment": 0.5083257424312027,
      "coherence": 0.5083257424312027,
      "comment_phi_k": 6.238095238095238,
      "code_phi_k": 190.43253015955165
    },
    {
      "comment": "Map a biological concept to field equations.\n\nArgs:\n    concept: Biological concept (e.g., \"gene\", \"hormone\", \"enzyme\")\n\nReturns:\n    Field equation mapping",
      "code": "    def map_biology_to_field(self, concept: str) -> Dict:\n        \"\"\"\n        Map a biological concept to field equations.\n        \n        Args:\n            concept: Biological concept (e.g., \"gene\", \"hormone\", \"enzyme\")\n        \n        Returns:\n            Field equation mapping\n        \"\"\"\n        concept_lower = concept.lower()\n        \n        # Direct lookup\n        if concept_lower in self.biology_field_map:\n            return self.biology_field_map[concept_lower]\n        \n        # Fuzz",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 139,
      "alignment": 0.5753911955076383,
      "coherence": 0.5753911955076383,
      "comment_phi_k": 28.787301587301588,
      "code_phi_k": 109.85341036327122
    },
    {
      "comment": "Explain a biology question using field equations.\n\nArgs:\n    question: Biology question\n\nReturns:\n    Field-based explanation",
      "code": "    def explain_biology_as_field(self, question: str) -> Dict:\n        \"\"\"\n        Explain a biology question using field equations.\n        \n        Args:\n            question: Biology question\n        \n        Returns:\n            Field-based explanation\n        \"\"\"\n        # Extract biological concepts from question\n        concepts = self._extract_concepts(question)\n        \n        # Map each concept to field equations\n        field_mappings = {}\n        for concept in concepts:\n           ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 169,
      "alignment": 0.5488310817319609,
      "coherence": 0.5488310817319609,
      "comment_phi_k": 25.580393217893214,
      "code_phi_k": 143.7538795266563
    },
    {
      "comment": "Extract biological concepts from text",
      "code": "    def _extract_concepts(self, text: str) -> List[str]:\n        \"\"\"Extract biological concepts from text\"\"\"\n        concepts = []\n        text_lower = text.lower()\n        \n        # Check for known concepts\n        for concept in self.biology_field_map.keys():\n            if concept in text_lower:\n                concepts.append(concept)\n        \n        # Also check for common biology terms\n        biology_terms = [\n            \"gene\", \"dna\", \"rna\", \"allele\", \"chromosome\",\n            \"hormon",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 205,
      "alignment": 0.5236963504881536,
      "coherence": 0.5236963504881536,
      "comment_phi_k": 8.213492063492062,
      "code_phi_k": 90.76030126589708
    },
    {
      "comment": "Generate field-based explanation",
      "code": "    def _generate_explanation(self, question: str, mappings: Dict, dimension: float) -> str:\n        \"\"\"Generate field-based explanation\"\"\"\n        if not mappings:\n            return f\"This biological process follows field equations at dimension D={dimension:.1f}.\"\n        \n        concept = list(mappings.keys())[0]\n        mapping = mappings[concept]\n        \n        explanation = f\"{concept.capitalize()} operates as a {mapping['field_type']} \"\n        explanation += f\"at the {mapping['scale']",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 229,
      "alignment": 0.5195752535980038,
      "coherence": 0.5195752535980038,
      "comment_phi_k": 6.12245670995671,
      "code_phi_k": 81.25251051774235
    },
    {
      "comment": "Add biology knowledge entry with field mapping.\n\nArgs:\n    question: Biology question\n    answer: Correct answer\n\nReturns:\n    Knowledge entry with field properties",
      "code": "    def add_biology_knowledge(self, question: str, answer: str) -> Dict:\n        \"\"\"\n        Add biology knowledge entry with field mapping.\n        \n        Args:\n            question: Biology question\n            answer: Correct answer\n        \n        Returns:\n            Knowledge entry with field properties\n        \"\"\"\n        # Map question to field\n        field_explanation = self.explain_biology_as_field(question)\n        \n        # Compute field properties\n        concepts = field_expla",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 244,
      "alignment": 0.5809281658071938,
      "coherence": 0.5809281658071938,
      "comment_phi_k": 33.332142857142856,
      "code_phi_k": 119.63437215762343
    },
    {
      "comment": "!/usr/bin/env python3",
      "code": "#!/usr/bin/env python3\n\"\"\"\nBiology Field Mapper \u2014 Map biological concepts to field equations",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 1,
      "alignment": 0.5364107290119101,
      "coherence": 0.5364107290119101,
      "comment_phi_k": 2.306354756354756,
      "code_phi_k": 16.988858363858363
    },
    {
      "comment": "# Scale-to-dimension mapping",
      "code": "        self.project_root = project_root\n        self.opic = OpicExecutor(project_root)\n        \n        # Scale-to-dimension mapping\n        self.scale_dimensions = {\n            \"molecular\": 2.5,      # Chemistry, bonds",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 26,
      "alignment": 0.555103789133929,
      "coherence": 0.555103789133929,
      "comment_phi_k": 3.728838236926472,
      "code_phi_k": 18.78175953884511
    },
    {
      "comment": "Chemistry, bonds",
      "code": "\"molecular\": 2.5,",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 28,
      "alignment": 0.641841767168138,
      "coherence": 0.641841767168138,
      "comment_phi_k": 3.0728174603174603,
      "code_phi_k": 1.3581349206349207
    },
    {
      "comment": "DNA, genes, alleles",
      "code": "\"genetic\": 3.5,",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 29,
      "alignment": 0.5746972736052299,
      "coherence": 0.5746972736052299,
      "comment_phi_k": 4.604761904761905,
      "code_phi_k": 1.1970238095238095
    },
    {
      "comment": "Hormones, signaling",
      "code": "\"hormonal\": 3.5,",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 30,
      "alignment": 0.6021540901281882,
      "coherence": 0.6021540901281882,
      "comment_phi_k": 3.6162698412698413,
      "code_phi_k": 1.2269841269841268
    },
    {
      "comment": "Cells, organelles",
      "code": "\"cellular\": 4.0,",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 31,
      "alignment": 0.6020260014518577,
      "coherence": 0.6020260014518577,
      "comment_phi_k": 3.620039682539683,
      "code_phi_k": 1.2269841269841268
    },
    {
      "comment": "Organisms, systems",
      "code": "\"organism\": 4.5",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 32,
      "alignment": 0.6171323196826832,
      "coherence": 0.6171323196826832,
      "comment_phi_k": 3.5192460317460315,
      "code_phi_k": 1.3359126984126983
    },
    {
      "comment": "# Biological concept \u2192 field equation mappings",
      "code": "            \"organism\": 4.5        # Organisms, systems\n        }\n        \n        # Biological concept \u2192 field equation mappings\n        self.biology_field_map = {\n            # Genetics",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 35,
      "alignment": 0.6722285302469557,
      "coherence": 0.6722285302469557,
      "comment_phi_k": 9.32718253968254,
      "code_phi_k": 18.202553900348022
    },
    {
      "comment": "# Genetics",
      "code": "        \n        # Biological concept \u2192 field equation mappings\n        self.biology_field_map = {\n            # Genetics\n            \"gene\": {\n                \"field_type\": \"operator\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 37,
      "alignment": 0.5282920765706574,
      "coherence": 0.5282920765706574,
      "comment_phi_k": 1.817261904761905,
      "code_phi_k": 16.966677276971396
    },
    {
      "comment": "# Hormones",
      "code": "                \"description\": \"Inheritance = field combination\"\n            },\n            \n            # Hormones\n            \"hormone\": {\n                \"field_type\": \"propagator\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 67,
      "alignment": 0.5396739519280472,
      "coherence": 0.5396739519280472,
      "comment_phi_k": 1.7803571428571427,
      "code_phi_k": 12.108856421356423
    },
    {
      "comment": "# Chemistry",
      "code": "                \"description\": \"Endocrine system = field network\"\n            },\n            \n            # Chemistry\n            \"chemical_bond\": {\n                \"field_type\": \"interaction\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 90,
      "alignment": 0.5338535518346408,
      "coherence": 0.5338535518346408,
      "comment_phi_k": 1.6811507936507935,
      "code_phi_k": 13.25545288045288
    },
    {
      "comment": "# Cells",
      "code": "                \"description\": \"Enzyme = field catalyst\"\n            },\n            \n            # Cells\n            \"cell\": {\n                \"field_type\": \"unit\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 113,
      "alignment": 0.5362725334075514,
      "coherence": 0.5362725334075514,
      "comment_phi_k": 1.3916666666666668,
      "code_phi_k": 10.287572150072151
    },
    {
      "comment": "# Organisms",
      "code": "                \"description\": \"Cell division = field replication\"\n            },\n            \n            # Organisms\n            \"organism\": {\n                \"field_type\": \"system\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 129,
      "alignment": 0.5433931209022482,
      "coherence": 0.5433931209022482,
      "comment_phi_k": 2.1228174603174605,
      "code_phi_k": 13.291558441558443
    },
    {
      "comment": "# Direct lookup",
      "code": "        \"\"\"\n        concept_lower = concept.lower()\n        \n        # Direct lookup\n        if concept_lower in self.biology_field_map:\n            return self.biology_field_map[concept_lower]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 151,
      "alignment": 0.5510779055222336,
      "coherence": 0.5510779055222336,
      "comment_phi_k": 3.341666666666667,
      "code_phi_k": 18.02656793374719
    },
    {
      "comment": "# Fuzzy matching",
      "code": "        if concept_lower in self.biology_field_map:\n            return self.biology_field_map[concept_lower]\n        \n        # Fuzzy matching\n        for key, mapping in self.biology_field_map.items():\n            if key in concept_lower or concept_lower in key:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 155,
      "alignment": 0.5247669971751139,
      "coherence": 0.5247669971751139,
      "comment_phi_k": 3.083928571428572,
      "code_phi_k": 32.67137966885304
    },
    {
      "comment": "# Default: generic biological field",
      "code": "            if key in concept_lower or concept_lower in key:\n                return mapping\n        \n        # Default: generic biological field\n        return {\n            \"field_type\": \"biological\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 160,
      "alignment": 0.5799623977701136,
      "coherence": 0.5799623977701136,
      "comment_phi_k": 7.19265873015873,
      "code_phi_k": 26.083957708957712
    },
    {
      "comment": "# Extract biological concepts from question",
      "code": "        Returns:\n            Field-based explanation\n        \"\"\"\n        # Extract biological concepts from question\n        concepts = self._extract_concepts(question)\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 179,
      "alignment": 0.6545469683358398,
      "coherence": 0.6545469683358398,
      "comment_phi_k": 8.852182539682538,
      "code_phi_k": 18.745658057534925
    },
    {
      "comment": "# Map each concept to field equations",
      "code": "        # Extract biological concepts from question\n        concepts = self._extract_concepts(question)\n        \n        # Map each concept to field equations\n        field_mappings = {}\n        for concept in concepts:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 182,
      "alignment": 0.593619961585807,
      "coherence": 0.593619961585807,
      "comment_phi_k": 9.524007936507935,
      "code_phi_k": 30.19463546901234
    },
    {
      "comment": "# Determine scale and dimension",
      "code": "        for concept in concepts:\n            field_mappings[concept] = self.map_biology_to_field(concept)\n        \n        # Determine scale and dimension\n        scales = [m[\"scale\"] for m in field_mappings.values()]\n        dimensions = [m[\"dimension\"] for m in field_mappings.values()]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 187,
      "alignment": 0.5565227333029991,
      "coherence": 0.5565227333029991,
      "comment_phi_k": 6.664880952380952,
      "code_phi_k": 32.81120310366641
    },
    {
      "comment": "# Generate field-based explanation",
      "code": "        \n        avg_dimension = sum(dimensions) / len(dimensions) if dimensions else 3.5\n        \n        # Generate field-based explanation\n        explanation = {\n            \"question\": question,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 193,
      "alignment": 0.5777981976239672,
      "coherence": 0.5777981976239672,
      "comment_phi_k": 6.12245670995671,
      "code_phi_k": 22.735388222888226
    },
    {
      "comment": "# Check for known concepts",
      "code": "        concepts = []\n        text_lower = text.lower()\n        \n        # Check for known concepts\n        for concept in self.biology_field_map.keys():\n            if concept in text_lower:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 210,
      "alignment": 0.568005448998944,
      "coherence": 0.568005448998944,
      "comment_phi_k": 5.492261904761905,
      "code_phi_k": 22.93665239444651
    },
    {
      "comment": "# Also check for common biology terms",
      "code": "            if concept in text_lower:\n                concepts.append(concept)\n        \n        # Also check for common biology terms\n        biology_terms = [\n            \"gene\", \"dna\", \"rna\", \"allele\", \"chromosome\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 215,
      "alignment": 0.6146410528674426,
      "coherence": 0.6146410528674426,
      "comment_phi_k": 8.921428571428573,
      "code_phi_k": 23.9158491354968
    },
    {
      "comment": "# Map question to field",
      "code": "        Returns:\n            Knowledge entry with field properties\n        \"\"\"\n        # Map question to field\n        field_explanation = self.explain_biology_as_field(question)\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 255,
      "alignment": 0.5813156889467602,
      "coherence": 0.5813156889467602,
      "comment_phi_k": 5.655357142857143,
      "code_phi_k": 20.21472040833619
    },
    {
      "comment": "# Compute field properties",
      "code": "        # Map question to field\n        field_explanation = self.explain_biology_as_field(question)\n        \n        # Compute field properties\n        concepts = field_explanation[\"concepts\"]\n        dimension = field_explanation[\"dimension\"]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 258,
      "alignment": 0.5590129725837019,
      "coherence": 0.5590129725837019,
      "comment_phi_k": 5.125396825396825,
      "code_phi_k": 24.275707438498415
    },
    {
      "comment": "# Estimate phi_k from dimension (higher D \u2192 higher phi_k)",
      "code": "        concepts = field_explanation[\"concepts\"]\n        dimension = field_explanation[\"dimension\"]\n        \n        # Estimate phi_k from dimension (higher D \u2192 higher phi_k)\n        phi_k = dimension * 2.0\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 262,
      "alignment": 0.656704514403892,
      "coherence": 0.656704514403892,
      "comment_phi_k": 10.749603174603173,
      "code_phi_k": 22.524280680955872
    },
    {
      "comment": "# Create knowledge entry",
      "code": "        # Estimate phi_k from dimension (higher D \u2192 higher phi_k)\n        phi_k = dimension * 2.0\n        \n        # Create knowledge entry\n        knowledge_entry = {\n            \"text\": f\"{question} {answer}\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 265,
      "alignment": 0.5573804472458018,
      "coherence": 0.5573804472458018,
      "comment_phi_k": 4.96170634920635,
      "code_phi_k": 24.098436285936288
    },
    {
      "comment": "# Example questions",
      "code": "    print(\"\\nMapping: Biology = Field Equations at Different Scales\")\n    print(\"\\n\" + \"=\" * 70)\n    \n    # Example questions\n    examples = [\n        \"How do hormones work?\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/biology_field_mapper.py",
      "line": 292,
      "alignment": 0.5451078665595888,
      "coherence": 0.5451078665595888,
      "comment_phi_k": 4.020436507936508,
      "code_phi_k": 24.292565073815073
    },
    {
      "comment": "ion: q \u2208 \u2124\u2081\u2080 \u2192 { \u00b1 1 } \u2014 Elementary bias quantum",
      "code": "class Ion:\n    \"\"\"ion: q \u2208 \u2124\u2081\u2080 \u2192 { \u00b1 1 } \u2014 Elementary bias quantum\"\"\"\n    q: int  # 0-9\n    bias: int  # +1 or -1",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 21,
      "alignment": 0.671277757553695,
      "coherence": 0.671277757553695,
      "comment_phi_k": 8.215079365079365,
      "code_phi_k": 16.098412698412695
    },
    {
      "comment": "voice: \u03b6 \u2208 \u2102 \u2014 Dirichlet-trace of an active process",
      "code": "class VoiceZeta:\n    \"\"\"voice: \u03b6 \u2208 \u2102 \u2014 Dirichlet-trace of an active process\"\"\"\n    real: float\n    imaginary: float\n    s_parameter: complex",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 27,
      "alignment": 0.65328118435973,
      "coherence": 0.65328118435973,
      "comment_phi_k": 10.773171273171274,
      "code_phi_k": 22.957514707514708
    },
    {
      "comment": "operator: \u00d4 \u2208 \u2112(\u210b) \u2014 Composable transformation shell",
      "code": "class Operator:\n    \"\"\"operator: \u00d4 \u2208 \u2112(\u210b) \u2014 Composable transformation shell\"\"\"\n    matrix: List[List[complex]]\n    dimension: int\n    hermitian: bool",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 34,
      "alignment": 0.6283155070192032,
      "coherence": 0.6283155070192032,
      "comment_phi_k": 8.601941114441114,
      "code_phi_k": 21.0603266831208
    },
    {
      "comment": "cycle: C\u2099 \u2208 \u210b\u207f \u2014 Closed sequence of voice interactions",
      "code": "class Cycle:\n    \"\"\"cycle: C\u2099 \u2208 \u210b\u207f \u2014 Closed sequence of voice interactions\"\"\"\n    voices: List[VoiceZeta]\n    length: int\n    closed: bool",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 41,
      "alignment": 0.6663755544792417,
      "coherence": 0.6663755544792417,
      "comment_phi_k": 11.403589466089466,
      "code_phi_k": 22.837108724608726
    },
    {
      "comment": "field: \u039e(x,t) \u2208 \u2102\u00d7\u211d \u2014 Continuous meaning manifold",
      "code": "class FieldXi:\n    \"\"\"field: \u039e(x,t) \u2208 \u2102\u00d7\u211d \u2014 Continuous meaning manifold\"\"\"\n    position: Tuple[float, float]\n    time: float\n    value_complex: complex",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 48,
      "alignment": 0.6182098623999306,
      "coherence": 0.6182098623999306,
      "comment_phi_k": 8.625992063492063,
      "code_phi_k": 22.555957930957934
    },
    {
      "comment": "trace7: \u03c4 \u2208 \u2124\u2081\u2080 \u2192 7 \u00b1 \u03b5 \u2014 Stability invariant",
      "code": "class Trace7:\n    \"\"\"trace7: \u03c4 \u2208 \u2124\u2081\u2080 \u2192 7 \u00b1 \u03b5 \u2014 Stability invariant\"\"\"\n    tau: float\n    epsilon: float\n    stable: bool",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 55,
      "alignment": 0.6185021059419117,
      "coherence": 0.6185021059419117,
      "comment_phi_k": 6.855158730158729,
      "code_phi_k": 17.88968253968254
    },
    {
      "comment": "add(a,b) = (a + b) mod 10 \u2014 Pascal sum \u2192 context merge",
      "code": "def pascal_add(a: int, b: int) -> int:\n    \"\"\"add(a,b) = (a + b) mod 10 \u2014 Pascal sum \u2192 context merge\"\"\"\n    return (a + b) % 10",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 65,
      "alignment": 0.6714663162456489,
      "coherence": 0.6714663162456489,
      "comment_phi_k": 9.734523809523811,
      "code_phi_k": 19.06031746031746
    },
    {
      "comment": "mul(a,b) = (a \u00d7 b) mod 10 \u2014 Pascal product \u2192 phase rotation",
      "code": "def pascal_mul(a: int, b: int) -> int:\n    \"\"\"mul(a,b) = (a \u00d7 b) mod 10 \u2014 Pascal product \u2192 phase rotation\"\"\"\n    return (a * b) % 10",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 69,
      "alignment": 0.6723432082450631,
      "coherence": 0.6723432082450631,
      "comment_phi_k": 10.039880952380953,
      "code_phi_k": 19.58373015873016
    },
    {
      "comment": "tan\u03b8(a,b) = sin\u03b8/ cos\u03b8 \u2014 Bias curvature measure",
      "code": "def tan_theta(a: complex, b: complex) -> float:\n    \"\"\"tan\u03b8(a,b) = sin\u03b8/ cos\u03b8 \u2014 Bias curvature measure\"\"\"\n    if abs(b) < 1e-10:\n        return float('inf')\n    theta = cmath.phase(a / b)\n    return math.tan(theta)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 73,
      "alignment": 0.5912647648779413,
      "coherence": 0.5912647648779413,
      "comment_phi_k": 9.338492063492064,
      "code_phi_k": 30.25001665001665
    },
    {
      "comment": "res(a,b) = Re(a \u00b7 b\u0304) \u2014 Resonance magnitude",
      "code": "def resonance(a: complex, b: complex) -> float:\n    \"\"\"res(a,b) = Re(a \u00b7 b\u0304) \u2014 Resonance magnitude\"\"\"\n    return (a * b.conjugate()).real",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 80,
      "alignment": 0.6179204876065023,
      "coherence": 0.6179204876065023,
      "comment_phi_k": 7.007936507936509,
      "code_phi_k": 18.36130273879887
    },
    {
      "comment": "shadow(p) = 10 \u2013 p \u2014 Prime conjugate lookup",
      "code": "def shadow(p: int) -> int:\n    \"\"\"shadow(p) = 10 \u2013 p \u2014 Prime conjugate lookup\"\"\"\n    return 10 - p",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 84,
      "alignment": 0.6716089753768678,
      "coherence": 0.6716089753768678,
      "comment_phi_k": 7.09563492063492,
      "code_phi_k": 13.88474025974026
    },
    {
      "comment": "phiScale(D) = \u03c6^{\u2013D} \u2014 Energy attenuation factor",
      "code": "def phi_scale(D: int) -> float:\n    \"\"\"phiScale(D) = \u03c6^{\u2013D} \u2014 Energy attenuation factor\"\"\"\n    return PHI ** (-D)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 88,
      "alignment": 0.6751336551433913,
      "coherence": 0.6751336551433913,
      "comment_phi_k": 8.183351370851371,
      "code_phi_k": 15.77325591075591
    },
    {
      "comment": "Verify Hermitian duality: \u00d4\u2020 \u00d4 = I",
      "code": "def verify_hermitian(op: Operator) -> bool:\n    \"\"\"Verify Hermitian duality: \u00d4\u2020 \u00d4 = I\"\"\"\n    # Simplified check: verify matrix is Hermitian\n    n = len(op.matrix)\n    for i in range(n):\n        for j in range(n):\n            if abs(op.matrix[i][j] - op.matrix[j][i].conjugate()) > 1e-10:\n                return False\n    return True",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 92,
      "alignment": 0.5420825095356366,
      "coherence": 0.5420825095356366,
      "comment_phi_k": 7.311507936507937,
      "code_phi_k": 47.091304849056066
    },
    {
      "comment": "pascal[n][k] = C(n,k) mod 10",
      "code": "def pascal_combination(n: int, k: int) -> int:\n    \"\"\"pascal[n][k] = C(n,k) mod 10\"\"\"\n    if k < 0 or k > n:\n        return 0\n    return int(comb(n, k, exact=True)) % 10",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 106,
      "alignment": 0.5435724611930558,
      "coherence": 0.5435724611930558,
      "comment_phi_k": 3.6162878787878787,
      "code_phi_k": 22.556844952433185
    },
    {
      "comment": "Check if x is in unit group U\u2081\u2080 = {1,3,7,9}",
      "code": "def is_unit(x: int) -> bool:\n    \"\"\"Check if x is in unit group U\u2081\u2080 = {1,3,7,9}\"\"\"\n    return x in [1, 3, 7, 9]",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 112,
      "alignment": 0.6816128504985364,
      "coherence": 0.6816128504985364,
      "comment_phi_k": 9.7,
      "code_phi_k": 18.202579365079366
    },
    {
      "comment": "7-trace cycle: (1 \u2192 3 \u2192 9 \u2192 7 \u2192 1)",
      "code": "def unit_cycle(x: int) -> int:\n    \"\"\"7-trace cycle: (1 \u2192 3 \u2192 9 \u2192 7 \u2192 1)\"\"\"\n    cycle_map = {1: 3, 3: 9, 9: 7, 7: 1}\n    return cycle_map.get(x, x)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 116,
      "alignment": 0.5404595330755797,
      "coherence": 0.5404595330755797,
      "comment_phi_k": 1.9595238095238092,
      "code_phi_k": 13.087685925185925
    },
    {
      "comment": "\u03b6(s) = \u03a3_{n=1}^{\u221e} 1/n^s",
      "code": "def zeta_compute(s: complex, max_n: int = 1000) -> complex:\n    \"\"\"\u03b6(s) = \u03a3_{n=1}^{\u221e} 1/n^s\"\"\"\n    result = 0.0 + 0.0j\n    for n in range(1, max_n + 1):\n        result += n ** (-s)\n    return result",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 125,
      "alignment": 0.517452543561665,
      "coherence": 0.517452543561665,
      "comment_phi_k": 1.5583333333333331,
      "code_phi_k": 23.101605339105344
    },
    {
      "comment": "Completed form: \u039e(s) = \u03c0^{-s/2} \u0393(s/2) \u03b6(s)",
      "code": "def zeta_completed_form(s: complex) -> complex:\n    \"\"\"Completed form: \u039e(s) = \u03c0^{-s/2} \u0393(s/2) \u03b6(s)\"\"\"\n    zeta_val = zeta_compute(s)\n    gamma_val = gamma(s.real / 2 + 1j * s.imag / 2)\n    pi_factor = math.pi ** (-s / 2)\n    return pi_factor * gamma_val * zeta_val",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 132,
      "alignment": 0.5520284427203273,
      "coherence": 0.5520284427203273,
      "comment_phi_k": 5.701984126984128,
      "code_phi_k": 30.249391039387174
    },
    {
      "comment": "Cycle formation: if state[t] == state[0], mark cycle",
      "code": "def detect_cycle(states: List[complex]) -> bool:\n    \"\"\"Cycle formation: if state[t] == state[0], mark cycle\"\"\"\n    if len(states) < 2:\n        return False\n    return abs(states[-1] - states[0]) < 1e-10",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 143,
      "alignment": 0.6096587132025847,
      "coherence": 0.6096587132025847,
      "comment_phi_k": 9.811507936507937,
      "code_phi_k": 27.274035634987655
    },
    {
      "comment": "Promotion condition: \u03b8_C \u2261 0 (mod 2\u03c0) \u21d2 C\u2099 \u21a6 \u00d4_C",
      "code": "def check_promotion(cycle: Cycle) -> bool:\n    \"\"\"Promotion condition: \u03b8_C \u2261 0 (mod 2\u03c0) \u21d2 C\u2099 \u21a6 \u00d4_C\"\"\"\n    if not cycle.closed:\n        return False\n    # Compute sum of phases\n    total_phase = sum(cmath.phase(v.real + 1j * v.imaginary) for v in cycle.voices)\n    # Check if total phase is near 0 mod 2\u03c0\n    normalized = total_phase % (2 * math.pi)\n    return abs(normalized) < 0.01 or abs(normalized - 2 * math.pi) < 0.01",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 149,
      "alignment": 0.5304416278745457,
      "coherence": 0.5304416278745457,
      "comment_phi_k": 6.75515873015873,
      "code_phi_k": 58.85390571330973
    },
    {
      "comment": "Apply operator to vector",
      "code": "def apply_operator(op: Operator, vector: List[complex]) -> List[complex]:\n    \"\"\"Apply operator to vector\"\"\"\n    result = []\n    for row in op.matrix:\n        val = sum(row[i] * vector[i] for i in range(len(vector)))\n        result.append(val)\n    return result",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 159,
      "alignment": 0.5452719239599428,
      "coherence": 0.5452719239599428,
      "comment_phi_k": 6.413690476190476,
      "code_phi_k": 38.62443916377741
    },
    {
      "comment": "\u03c4 = \u03a3(bias(s) * charge(s)) mod 10",
      "code": "def compute_trace7(states: List[Ion]) -> Trace7:\n    \"\"\"\u03c4 = \u03a3(bias(s) * charge(s)) mod 10\"\"\"\n    tau = sum(state.bias * state.q for state in states) % 10\n    epsilon = 0.05\n    stable = abs(tau - 7) < epsilon\n    return Trace7(tau=tau, epsilon=epsilon, stable=stable)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 171,
      "alignment": 0.5333715915182347,
      "coherence": 0.5333715915182347,
      "comment_phi_k": 4.466666666666667,
      "code_phi_k": 35.69492793712996
    },
    {
      "comment": "Check if trace7 is stable: \u03c4 \u2248 7 \u00b1 \u03b5",
      "code": "def check_trace7_stability(trace: Trace7) -> bool:\n    \"\"\"Check if trace7 is stable: \u03c4 \u2248 7 \u00b1 \u03b5\"\"\"\n    return abs(trace.tau - 7) < trace.epsilon",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 178,
      "alignment": 0.628862117404906,
      "coherence": 0.628862117404906,
      "comment_phi_k": 7.691666666666666,
      "code_phi_k": 18.768113871565884
    },
    {
      "comment": "Non-harm constraint: \u2202\u039e/\u2202t \u2265 0",
      "code": "def check_non_harm(coherence_history: List[float]) -> bool:\n    \"\"\"Non-harm constraint: \u2202\u039e/\u2202t \u2265 0\"\"\"\n    if len(coherence_history) < 2:\n        return True\n    derivative = (coherence_history[-1] - coherence_history[-2])\n    return derivative >= 0",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 186,
      "alignment": 0.5399314840164451,
      "coherence": 0.5399314840164451,
      "comment_phi_k": 3.765674603174604,
      "code_phi_k": 25.458686634057454
    },
    {
      "comment": "CE1 Kernel State",
      "code": "class CE1State:\n    \"\"\"CE1 Kernel State\"\"\"\n    pascal_index: Tuple[int, int]\n    zeta_value: complex\n    bias: float\n    dimension: int\n    resonance: float",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 198,
      "alignment": 0.5443377762929542,
      "coherence": 0.5443377762929542,
      "comment_phi_k": 3.9833333333333334,
      "code_phi_k": 24.45182178932179
    },
    {
      "comment": "CE1 Kernel",
      "code": "class CE1Kernel:\n    \"\"\"CE1 Kernel\"\"\"\n    state: CE1State\n    operators: List[Operator]\n    cycles: List[Cycle]\n    trace7_value: Trace7\n    ethical_tensor: bool\n\n    def step(self):\n        \"\"\"Update kernel state\"\"\"\n        # Update bias\n        self.state.bias = self._update_bias()\n        # Check cycles\n        self._check_cycles()\n        # Promote if resonant\n        self._promote_if_resonant()\n\n    def _update_bias(self) -> float:\n        \"\"\"Update bias based on current state\"\"\"\n        re",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 207,
      "alignment": 0.5042363396902406,
      "coherence": 0.5042363396902406,
      "comment_phi_k": 2.575,
      "code_phi_k": 153.24651345754566
    },
    {
      "comment": "Pascal\u2013Zeta Pipeline",
      "code": "def ce1_pipeline() -> CE1Kernel:\n    \"\"\"Pascal\u2013Zeta Pipeline\"\"\"\n    # Initialize Pascal kernel\n    pascal_index = (5, 3)\n    \n    # Project to Zeta field\n    zeta_value = zeta_compute(0.5 + 1j * 14.1347)  # First non-trivial zero\n    \n    # Compute tan \u03b8 curvatures\n    bias = tan_theta(zeta_value, zeta_value.conjugate())\n    \n    # Create initial state\n    state = CE1State(\n        pascal_index=pascal_index,\n        zeta_value=zeta_value,\n        bias=bias,\n        dimension=1,\n        resonance",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 245,
      "alignment": 0.5111687326638402,
      "coherence": 0.5111687326638402,
      "comment_phi_k": 3.769282106782107,
      "code_phi_k": 86.25594396284052
    },
    {
      "comment": "Update kernel state",
      "code": "    def step(self):\n        \"\"\"Update kernel state\"\"\"\n        # Update bias\n        self.state.bias = self._update_bias()\n        # Check cycles\n        self._check_cycles()\n        # Promote if resonant\n        self._promote_if_resonant()",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 215,
      "alignment": 0.5542473915373132,
      "coherence": 0.5542473915373132,
      "comment_phi_k": 4.916666666666667,
      "code_phi_k": 25.116872883962333
    },
    {
      "comment": "Update bias based on current state",
      "code": "    def _update_bias(self) -> float:\n        \"\"\"Update bias based on current state\"\"\"\n        return self.state.bias * 0.9 + 0.1 * self.state.resonance",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 224,
      "alignment": 0.6720850979611205,
      "coherence": 0.6720850979611205,
      "comment_phi_k": 9.213095238095239,
      "code_phi_k": 17.99105236009261
    },
    {
      "comment": "Check for cycle formation",
      "code": "    def _check_cycles(self):\n        \"\"\"Check for cycle formation\"\"\"\n        for cycle in self.cycles:\n            if detect_cycle([v.real + 1j * v.imaginary for v in cycle.voices]):\n                cycle.closed = True",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 228,
      "alignment": 0.5615810137088281,
      "coherence": 0.5615810137088281,
      "comment_phi_k": 5.615079365079366,
      "code_phi_k": 25.603037137441156
    },
    {
      "comment": "Promote cycle to operator if resonant",
      "code": "    def _promote_if_resonant(self):\n        \"\"\"Promote cycle to operator if resonant\"\"\"\n        for cycle in self.cycles:\n            if check_promotion(cycle):\n                # Create operator from cycle\n                # Simplified: create identity operator\n                n = len(cycle.voices)\n                matrix = [[1.0 + 0.0j if i == j else 0.0 + 0.0j for j in range(n)] for i in range(n)]\n                op = Operator(matrix=matrix, dimension=n, hermitian=True)\n                self.oper",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 234,
      "alignment": 0.5395023499204264,
      "coherence": 0.5395023499204264,
      "comment_phi_k": 9.14047619047619,
      "code_phi_k": 62.417911770910315
    },
    {
      "comment": "!/usr/bin/env python3",
      "code": "#!/usr/bin/env python3\n\"\"\"\nCE1 Kernel Implementation (Appendix A)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 1,
      "alignment": 0.5693382086218122,
      "coherence": 0.5693382086218122,
      "comment_phi_k": 2.306354756354756,
      "code_phi_k": 9.468775668775669
    },
    {
      "comment": "Golden ratio",
      "code": "from dataclasses import dataclass\nfrom scipy.special import comb, gamma\n\n# Golden ratio\nPHI = (1 + math.sqrt(5)) / 2\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 13,
      "alignment": 0.5423814914598355,
      "coherence": 0.5423814914598355,
      "comment_phi_k": 3.1916666666666664,
      "code_phi_k": 20.422841047841047
    },
    {
      "comment": "============================================================================",
      "code": "# Golden ratio\nPHI = (1 + math.sqrt(5)) / 2\n\n# ============================================================================\n# A.1 Type System\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 16,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 9.331150793650792
    },
    {
      "comment": "A.1 Type System",
      "code": "PHI = (1 + math.sqrt(5)) / 2\n\n# ============================================================================\n# A.1 Type System\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 17,
      "alignment": 0.6986768424855492,
      "coherence": 0.6986768424855492,
      "comment_phi_k": 3.4916666666666663,
      "code_phi_k": 6.139484126984126
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# A.1 Type System\n# ============================================================================\n\n@dataclass",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 18,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 4.78531746031746
    },
    {
      "comment": "0-9",
      "code": "q: int",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 23,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 1.9166666666666667
    },
    {
      "comment": "+1 or -1",
      "code": "bias: int",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 24,
      "alignment": 0.638888888888889,
      "coherence": 0.638888888888889,
      "comment_phi_k": 1.25,
      "code_phi_k": 2.875
    },
    {
      "comment": "============================================================================",
      "code": "    epsilon: float\n    stable: bool\n\n# ============================================================================\n# A.2 Core Operators\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 61,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 11.040674603174603
    },
    {
      "comment": "A.2 Core Operators",
      "code": "    stable: bool\n\n# ============================================================================\n# A.2 Core Operators\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 62,
      "alignment": 0.721587164083539,
      "coherence": 0.721587164083539,
      "comment_phi_k": 4.669246031746032,
      "code_phi_k": 7.602579365079365
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# A.2 Core Operators\n# ============================================================================\n\ndef pascal_add(a: int, b: int) -> int:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 63,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 12.474801587301586
    },
    {
      "comment": "# Simplified check: verify matrix is Hermitian",
      "code": "\ndef verify_hermitian(op: Operator) -> bool:\n    \"\"\"Verify Hermitian duality: \u00d4\u2020 \u00d4 = I\"\"\"\n    # Simplified check: verify matrix is Hermitian\n    n = len(op.matrix)\n    for i in range(n):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 94,
      "alignment": 0.5934601179852601,
      "coherence": 0.5934601179852601,
      "comment_phi_k": 9.547619047619047,
      "code_phi_k": 30.313096370004267
    },
    {
      "comment": "============================================================================",
      "code": "                return False\n    return True\n\n# ============================================================================\n# A.3 Pascal Kernel\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 102,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 10.174999999999999
    },
    {
      "comment": "A.3 Pascal Kernel",
      "code": "    return True\n\n# ============================================================================\n# A.3 Pascal Kernel\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 103,
      "alignment": 0.7071547420965059,
      "coherence": 0.7071547420965059,
      "comment_phi_k": 4.15,
      "code_phi_k": 7.083333333333334
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# A.3 Pascal Kernel\n# ============================================================================\n\ndef pascal_combination(n: int, k: int) -> int:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 104,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 12.31139040697864
    },
    {
      "comment": "============================================================================",
      "code": "    cycle_map = {1: 3, 3: 9, 9: 7, 7: 1}\n    return cycle_map.get(x, x)\n\n# ============================================================================\n# A.4 Zeta Core\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 121,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 9.121217671217671
    },
    {
      "comment": "A.4 Zeta Core",
      "code": "    return cycle_map.get(x, x)\n\n# ============================================================================\n# A.4 Zeta Core\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 122,
      "alignment": 0.6678077532337535,
      "coherence": 0.6678077532337535,
      "comment_phi_k": 3.833333333333334,
      "code_phi_k": 7.627566877566878
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# A.4 Zeta Core\n# ============================================================================\n\ndef zeta_compute(s: complex, max_n: int = 1000) -> complex:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 123,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 12.968272005772008
    },
    {
      "comment": "============================================================================",
      "code": "    pi_factor = math.pi ** (-s / 2)\n    return pi_factor * gamma_val * zeta_val\n\n# ============================================================================\n# A.5 Cycle Mechanics\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 139,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 14.131746031746031
    },
    {
      "comment": "A.5 Cycle Mechanics",
      "code": "    return pi_factor * gamma_val * zeta_val\n\n# ============================================================================\n# A.5 Cycle Mechanics\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 140,
      "alignment": 0.6165273698415759,
      "coherence": 0.6165273698415759,
      "comment_phi_k": 4.077579365079364,
      "code_phi_k": 10.786904761904763
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# A.5 Cycle Mechanics\n# ============================================================================\n\ndef detect_cycle(states: List[complex]) -> bool:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 141,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 10.660741984193995
    },
    {
      "comment": "# Compute sum of phases",
      "code": "    \"\"\"Promotion condition: \u03b8_C \u2261 0 (mod 2\u03c0) \u21d2 C\u2099 \u21a6 \u00d4_C\"\"\"\n    if not cycle.closed:\n        return False\n    # Compute sum of phases\n    total_phase = sum(cmath.phase(v.real + 1j * v.imaginary) for v in cycle.voices)\n    # Check if total phase is near 0 mod 2\u03c0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 153,
      "alignment": 0.5391540615648539,
      "coherence": 0.5391540615648539,
      "comment_phi_k": 5.626190476190476,
      "code_phi_k": 38.73651065996267
    },
    {
      "comment": "# Check if total phase is near 0 mod 2\u03c0",
      "code": "        return False\n    # Compute sum of phases\n    total_phase = sum(cmath.phase(v.real + 1j * v.imaginary) for v in cycle.voices)\n    # Check if total phase is near 0 mod 2\u03c0\n    normalized = total_phase % (2 * math.pi)\n    return abs(normalized) < 0.01 or abs(normalized - 2 * math.pi) < 0.01",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 155,
      "alignment": 0.5628701439283312,
      "coherence": 0.5628701439283312,
      "comment_phi_k": 9.608333333333333,
      "code_phi_k": 43.01122622217824
    },
    {
      "comment": "============================================================================",
      "code": "        result.append(val)\n    return result\n\n# ============================================================================\n# A.6 7-Trace Regulation\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 167,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 9.085568108362226
    },
    {
      "comment": "A.6 7-Trace Regulation",
      "code": "    return result\n\n# ============================================================================\n# A.6 7-Trace Regulation\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 168,
      "alignment": 0.685,
      "coherence": 0.685,
      "comment_phi_k": 3.7587301587301587,
      "code_phi_k": 6.958730158730159
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# A.6 7-Trace Regulation\n# ============================================================================\n\ndef compute_trace7(states: List[Ion]) -> Trace7:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 169,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 10.246674801376814
    },
    {
      "comment": "============================================================================",
      "code": "    \"\"\"Check if trace7 is stable: \u03c4 \u2248 7 \u00b1 \u03b5\"\"\"\n    return abs(trace.tau - 7) < trace.epsilon\n\n# ============================================================================\n# A.7 Ethical Tensor\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 182,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 17.147365134865137
    },
    {
      "comment": "A.7 Ethical Tensor",
      "code": "    return abs(trace.tau - 7) < trace.epsilon\n\n# ============================================================================\n# A.7 Ethical Tensor\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 183,
      "alignment": 0.6440438404429081,
      "coherence": 0.6440438404429081,
      "comment_phi_k": 4.579761904761905,
      "code_phi_k": 10.238436563436563
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# A.7 Ethical Tensor\n# ============================================================================\n\ndef check_non_harm(coherence_history: List[float]) -> bool:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 184,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 11.186271448194123
    },
    {
      "comment": "============================================================================",
      "code": "    derivative = (coherence_history[-1] - coherence_history[-2])\n    return derivative >= 0\n\n# ============================================================================\n# A.8 Pascal\u2013Zeta Pipeline\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 193,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 14.358488447826684
    },
    {
      "comment": "A.8 Pascal\u2013Zeta Pipeline",
      "code": "    return derivative >= 0\n\n# ============================================================================\n# A.8 Pascal\u2013Zeta Pipeline\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 194,
      "alignment": 0.6980612530768112,
      "coherence": 0.6980612530768112,
      "comment_phi_k": 4.769282106782107,
      "code_phi_k": 8.404599567099568
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# A.8 Pascal\u2013Zeta Pipeline\n# ============================================================================\n\n@dataclass",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 195,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 6.062932900432901
    },
    {
      "comment": "# Update bias",
      "code": "\n    def step(self):\n        \"\"\"Update kernel state\"\"\"\n        # Update bias\n        self.state.bias = self._update_bias()\n        # Check cycles",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 217,
      "alignment": 0.5576518216659856,
      "coherence": 0.5576518216659856,
      "comment_phi_k": 3.3916666666666666,
      "code_phi_k": 16.403376688670807
    },
    {
      "comment": "# Check cycles",
      "code": "        \"\"\"Update kernel state\"\"\"\n        # Update bias\n        self.state.bias = self._update_bias()\n        # Check cycles\n        self._check_cycles()\n        # Promote if resonant",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 219,
      "alignment": 0.5347831825677274,
      "coherence": 0.5347831825677274,
      "comment_phi_k": 2.633333333333333,
      "code_phi_k": 20.243437730570086
    },
    {
      "comment": "# Promote if resonant",
      "code": "        self.state.bias = self._update_bias()\n        # Check cycles\n        self._check_cycles()\n        # Promote if resonant\n        self._promote_if_resonant()\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 221,
      "alignment": 0.5909652203307038,
      "coherence": 0.5909652203307038,
      "comment_phi_k": 4.701785714285714,
      "code_phi_k": 15.272825264914712
    },
    {
      "comment": "# Create operator from cycle",
      "code": "        \"\"\"Promote cycle to operator if resonant\"\"\"\n        for cycle in self.cycles:\n            if check_promotion(cycle):\n                # Create operator from cycle\n                # Simplified: create identity operator\n                n = len(cycle.voices)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 238,
      "alignment": 0.55150680423826,
      "coherence": 0.55150680423826,
      "comment_phi_k": 6.247023809523809,
      "code_phi_k": 33.44486411206613
    },
    {
      "comment": "# Simplified: create identity operator",
      "code": "        for cycle in self.cycles:\n            if check_promotion(cycle):\n                # Create operator from cycle\n                # Simplified: create identity operator\n                n = len(cycle.voices)\n                matrix = [[1.0 + 0.0j if i == j else 0.0 + 0.0j for j in range(n)] for i in range(n)]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 239,
      "alignment": 0.5528708359302755,
      "coherence": 0.5528708359302755,
      "comment_phi_k": 7.821825396825398,
      "code_phi_k": 40.89645141365342
    },
    {
      "comment": "# Initialize Pascal kernel",
      "code": "\ndef ce1_pipeline() -> CE1Kernel:\n    \"\"\"Pascal\u2013Zeta Pipeline\"\"\"\n    # Initialize Pascal kernel\n    pascal_index = (5, 3)\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 247,
      "alignment": 0.6154195950543501,
      "coherence": 0.6154195950543501,
      "comment_phi_k": 5.576984126984127,
      "code_phi_k": 14.868295593295592
    },
    {
      "comment": "# Project to Zeta field",
      "code": "    # Initialize Pascal kernel\n    pascal_index = (5, 3)\n    \n    # Project to Zeta field\n    zeta_value = zeta_compute(0.5 + 1j * 14.1347)  # First non-trivial zero\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 250,
      "alignment": 0.5726380428477201,
      "coherence": 0.5726380428477201,
      "comment_phi_k": 5.538095238095238,
      "code_phi_k": 21.829635642135642
    },
    {
      "comment": "First non-trivial zero",
      "code": "zeta_value = zeta_compute(0.5 + 1j * 14.1347)",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 251,
      "alignment": 0.9087222750429265,
      "coherence": 0.9087222750429265,
      "comment_phi_k": 4.620256132756134,
      "code_phi_k": 4.156168831168831
    },
    {
      "comment": "# Compute tan \u03b8 curvatures",
      "code": "    # Project to Zeta field\n    zeta_value = zeta_compute(0.5 + 1j * 14.1347)  # First non-trivial zero\n    \n    # Compute tan \u03b8 curvatures\n    bias = tan_theta(zeta_value, zeta_value.conjugate())\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 253,
      "alignment": 0.5581710272421183,
      "coherence": 0.5581710272421183,
      "comment_phi_k": 5.3259920634920634,
      "code_phi_k": 25.552363453969487
    },
    {
      "comment": "# Create initial state",
      "code": "    # Compute tan \u03b8 curvatures\n    bias = tan_theta(zeta_value, zeta_value.conjugate())\n    \n    # Create initial state\n    state = CE1State(\n        pascal_index=pascal_index,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 256,
      "alignment": 0.5672999881517057,
      "coherence": 0.5672999881517057,
      "comment_phi_k": 5.154761904761905,
      "code_phi_k": 21.72583122083492
    },
    {
      "comment": "# Initialize kernel",
      "code": "        resonance=resonance(zeta_value, zeta_value.conjugate())\n    )\n    \n    # Initialize kernel\n    kernel = CE1Kernel(\n        state=state,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 265,
      "alignment": 0.5833344137646154,
      "coherence": 0.5833344137646154,
      "comment_phi_k": 4.0019841269841265,
      "code_phi_k": 14.006788787184288
    },
    {
      "comment": "============================================================================",
      "code": "    \n    return kernel\n\n# ============================================================================\n# Main\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 276,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 4.633333333333333
    },
    {
      "comment": "Main",
      "code": "    return kernel\n\n# ============================================================================\n# Main\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 277,
      "alignment": 0.5933831376734259,
      "coherence": 0.5933831376734259,
      "comment_phi_k": 1.4583333333333333,
      "code_phi_k": 4.633333333333333
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# Main\n# ============================================================================\n\nif __name__ == \"__main__\":",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 278,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 3.954761904761904
    },
    {
      "comment": "# Test Pascal operations",
      "code": "    print(\"CE1 Kernel Implementation\")\n    print(\"=\" * 60)\n    \n    # Test Pascal operations\n    print(\"\\nPascal Operations:\")\n    print(f\"  add(7, 3) = {pascal_add(7, 3)}\")",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 284,
      "alignment": 0.5746851186421394,
      "coherence": 0.5746851186421394,
      "comment_phi_k": 5.231746031746031,
      "code_phi_k": 20.128552003552006
    },
    {
      "comment": "# Test Zeta",
      "code": "    print(f\"  pascal(5, 3) = {pascal_combination(5, 3)}\")\n    print(f\"  shadow(7) = {shadow(7)}\")\n    \n    # Test Zeta\n    print(\"\\nZeta Operations:\")\n    s = 0.5 + 14.1347j",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 291,
      "alignment": 0.5470967301701021,
      "coherence": 0.5470967301701021,
      "comment_phi_k": 2.7083333333333335,
      "code_phi_k": 15.730607045603175
    },
    {
      "comment": "# Test CE1 Pipeline",
      "code": "    zeta_val = zeta_compute(s, max_n=1000)\n    print(f\"  \u03b6({s}) \u2248 {zeta_val}\")\n    \n    # Test CE1 Pipeline\n    print(\"\\nCE1 Pipeline:\")\n    kernel = ce1_pipeline()",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/ce1_kernel.py",
      "line": 297,
      "alignment": 0.5615065138436465,
      "coherence": 0.5615065138436465,
      "comment_phi_k": 4.171428571428572,
      "code_phi_k": 19.040945165945164
    },
    {
      "comment": "Generate BERT training code from opic nlp.ops",
      "code": "def generate_bert_training_code():\n    \"\"\"Generate BERT training code from opic nlp.ops\"\"\"\n    from generate import parse_ops, generate_swift_code\n    \n    ops_file = Path(__file__).parent / \"nlp.ops\"\n    defs, voices = parse_ops(ops_file.read_text())\n    \n    # Generate training code based on opic voices\n    code = f'''# Generated from opic nlp.ops\n# Voices: {list(voices.keys())}\n\nimport torch\nfrom transformers import BertTokenizer, BertForSequenceClassification\nfrom transformers import Trainer",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/bert_training.py",
      "line": 12,
      "alignment": 0.5098736900396349,
      "coherence": 0.5098736900396349,
      "comment_phi_k": 10.51011904761905,
      "code_phi_k": 271.3693239333004
    },
    {
      "comment": "Run BERT training using opic-generated approach",
      "code": "def run_bert_training():\n    \"\"\"Run BERT training using opic-generated approach\"\"\"\n    print(\"=\" * 70)\n    print(\"BERT Training using Opic-Generated Code\")\n    print(\"=\" * 70)\n    print()\n    \n    # Generate code from opic\n    print(\"Step 1: Generating training code from nlp.ops...\")\n    code = generate_bert_training_code()\n    code_file = Path(\"/tmp/opic_bert_training.py\")\n    code_file.write_text(code)\n    print(f\"\u2713 Generated: {code_file}\")\n    print()\n    \n    print(\"Step 2: Loading BERT mode",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/bert_training.py",
      "line": 88,
      "alignment": 0.5089579457369182,
      "coherence": 0.5089579457369182,
      "comment_phi_k": 10.446205183705183,
      "code_phi_k": 296.7577214234158
    },
    {
      "comment": "!/usr/bin/env python3",
      "code": "#!/usr/bin/env python3\n\"\"\"BERT training using opic-generated code\"\"\"\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/bert_training.py",
      "line": 1,
      "alignment": 0.5653112973445572,
      "coherence": 0.5653112973445572,
      "comment_phi_k": 2.306354756354756,
      "code_phi_k": 9.981492118992119
    },
    {
      "comment": "# Generate training code based on opic voices",
      "code": "    ops_file = Path(__file__).parent / \"nlp.ops\"\n    defs, voices = parse_ops(ops_file.read_text())\n    \n    # Generate training code based on opic voices\n    code = f'''# Generated from opic nlp.ops\n# Voices: {list(voices.keys())}",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/bert_training.py",
      "line": 19,
      "alignment": 0.6049685432253004,
      "coherence": 0.6049685432253004,
      "comment_phi_k": 11.24702380952381,
      "code_phi_k": 32.4101649913529
    },
    {
      "comment": "Generated from opic nlp.ops",
      "code": "code = f'''",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/bert_training.py",
      "line": 20,
      "alignment": 0.5927704363859865,
      "coherence": 0.5927704363859865,
      "comment_phi_k": 6.123412698412698,
      "code_phi_k": 1.9166666666666667
    },
    {
      "comment": "Voices: {list(voices.keys())}",
      "code": "    \n    # Generate training code based on opic voices\n    code = f'''# Generated from opic nlp.ops\n# Voices: {list(voices.keys())}\n\nimport torch",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/bert_training.py",
      "line": 21,
      "alignment": 0.5331859908847456,
      "coherence": 0.5331859908847456,
      "comment_phi_k": 3.2031581572022745,
      "code_phi_k": 25.731927998472116
    },
    {
      "comment": "# Load dataset",
      "code": "\ndef main(dataset_name='glue', task='sst2'):\n    \"\"\"Voice: main / {{dataset -> nlp}}\"\"\"\n    # Load dataset\n    dataset = load_dataset(dataset_name, task)\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/bert_training.py",
      "line": 62,
      "alignment": 0.5497823121587425,
      "coherence": 0.5497823121587425,
      "comment_phi_k": 3.2130952380952382,
      "code_phi_k": 17.742274842049714
    },
    {
      "comment": "# Load BERT model",
      "code": "    # Load dataset\n    dataset = load_dataset(dataset_name, task)\n    \n    # Load BERT model\n    model = BertForSequenceClassification.from_pretrained('bert-base-uncased', num_labels=2)\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/bert_training.py",
      "line": 65,
      "alignment": 0.5621328452367315,
      "coherence": 0.5621328452367315,
      "comment_phi_k": 4.266666666666667,
      "code_phi_k": 19.300850169276938
    },
    {
      "comment": "# Tokenize dataset",
      "code": "    # Load BERT model\n    model = BertForSequenceClassification.from_pretrained('bert-base-uncased', num_labels=2)\n    \n    # Tokenize dataset\n    tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/bert_training.py",
      "line": 68,
      "alignment": 0.5531115534730024,
      "coherence": 0.5531115534730024,
      "comment_phi_k": 3.63452380952381,
      "code_phi_k": 18.925233578812573
    },
    {
      "comment": "# Train",
      "code": "    \n    tokenized_dataset = dataset.map(tokenize_function, batched=True)\n    \n    # Train\n    trained_model = train_epoch(model, tokenized_dataset['train'])\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/bert_training.py",
      "line": 76,
      "alignment": 0.5256008170789936,
      "coherence": 0.5256008170789936,
      "comment_phi_k": 1.4333333333333333,
      "code_phi_k": 14.7136157573017
    },
    {
      "comment": "# Generate code from opic",
      "code": "    print(\"=\" * 70)\n    print()\n    \n    # Generate code from opic\n    print(\"Step 1: Generating training code from nlp.ops...\")\n    code = generate_bert_training_code()",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/bert_training.py",
      "line": 95,
      "alignment": 0.5824144100761042,
      "coherence": 0.5824144100761042,
      "comment_phi_k": 6.213095238095238,
      "code_phi_k": 21.953661953658088
    },
    {
      "comment": "Small subset for demo",
      "code": "train_dataset=tokenized_dataset['train'].select(range(100)),",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/bert_training.py",
      "line": 143,
      "alignment": 0.6668660092352047,
      "coherence": 0.6668660092352047,
      "comment_phi_k": 5.466666666666667,
      "code_phi_k": 2.735784513989379
    },
    {
      "comment": "Puzzle 1: Code Mutation \u2014 Transformational Invariants",
      "code": "def puzzle_code_mutation():\n    \"\"\"Puzzle 1: Code Mutation \u2014 Transformational Invariants\"\"\"\n    print(\"Puzzle 1: Code Mutation\")\n    print(\"-\" * 60)\n    \n    # Original recursive Swift code\n    original_code = \"\"\"\nfunc factorial(_ n: Int) -> Int {\n    if n <= 1 { return 1 }\n    return n * factorial(n - 1)\n}\n\"\"\"\n    \n    print(\"  Original (recursive):\")\n    print(\"    func factorial(_ n: Int) -> Int {\")\n    print(\"        if n <= 1 { return 1 }\")\n    print(\"        return n * factorial(n - 1)\")\n ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 11,
      "alignment": 0.5103393103781243,
      "coherence": 0.5103393103781243,
      "comment_phi_k": 9.199857781107783,
      "code_phi_k": 227.04846376993657
    },
    {
      "comment": "Puzzle 2: Voice Paradox \u2014 Temporal Self-Reference",
      "code": "def puzzle_voice_paradox():\n    \"\"\"Puzzle 2: Voice Paradox \u2014 Temporal Self-Reference\"\"\"\n    print(\"\\nPuzzle 2: Voice Paradox\")\n    print(\"-\" * 60)\n    \n    # Create voices that reference each other\n    paradox_ops = \"\"\"\ndef voice { name, input, output, body }\ndef narration { voice, description }\n\nvoice A / {input -> output}\nvoice B / {A + narration -> output}\nvoice narrate / {voice -> narration}\n\nvoice compose.paradox / {A + B -> synchronized.composition}\n\ntarget paradox / \"temporal.composition\"",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 67,
      "alignment": 0.5124938117959303,
      "coherence": 0.5124938117959303,
      "comment_phi_k": 8.735719835719836,
      "code_phi_k": 179.16879293986474
    },
    {
      "comment": "Puzzle 3: Meta-Compiler Bootstrap \u2014 Perfect Idempotence",
      "code": "def puzzle_meta_compiler_bootstrap():\n    \"\"\"Puzzle 3: Meta-Compiler Bootstrap \u2014 Perfect Idempotence\"\"\"\n    print(\"\\nPuzzle 3: Meta-Compiler Bootstrap\")\n    print(\"-\" * 60)\n    \n    # Test: Can opic compile itself multiple times with same result?\n    ops_file = Path(\"core.ops\")\n    \n    if not ops_file.exists():\n        print(\"  \u2717 core.ops not found\")\n        return False\n    \n    # Generate Metal code twice\n    result1 = subprocess.run(\n        [sys.executable, \"generate.py\", \"metal\", str(ops_f",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 111,
      "alignment": 0.5157593409071355,
      "coherence": 0.5157593409071355,
      "comment_phi_k": 9.494468031968031,
      "code_phi_k": 155.36374913415622
    },
    {
      "comment": "Puzzle 4: Analogy Construction \u2014 Symbolic Abstraction",
      "code": "def puzzle_analogy_construction():\n    \"\"\"Puzzle 4: Analogy Construction \u2014 Symbolic Abstraction\"\"\"\n    print(\"\\nPuzzle 4: Analogy Construction\")\n    print(\"-\" * 60)\n    \n    # Create analogy between zeta zeros and orbits\n    analogy_ops = \"\"\"\ndef zeta.zero { real, imaginary }\ndef orbit { radius, period, phase }\n\ndef analogy { domain1, domain2, mapping }\n\nvoice map.zero.to.orbit / {zeta.zero -> orbit}\nvoice preserve.correspondence / {analogy -> correspondence}\n\nvoice invert.analogy / {analogy -> ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 156,
      "alignment": 0.5122285653354304,
      "coherence": 0.5122285653354304,
      "comment_phi_k": 9.319101731601732,
      "code_phi_k": 195.17866484152432
    },
    {
      "comment": "Puzzle 5: Error Correction \u2014 Probabilistic Reasoning",
      "code": "def puzzle_error_correction():\n    \"\"\"Puzzle 5: Error Correction \u2014 Probabilistic Reasoning\"\"\"\n    print(\"\\nPuzzle 5: Error Correction\")\n    print(\"-\" * 60)\n    \n    # Create corrupted .ops file\n    original_ops = \"\"\"\ndef test { name, value }\nvoice run / {test -> result}\ntarget output / \"result\"\nvoice main / {test -> output}\n\"\"\"\n    \n    # Corrupt it (remove 20% of characters randomly)\n    corrupted = list(original_ops)\n    indices = list(range(len(corrupted)))\n    random.seed(42)  # Deterministi",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 202,
      "alignment": 0.50800809665097,
      "coherence": 0.50800809665097,
      "comment_phi_k": 9.285503385503386,
      "code_phi_k": 294.5213517586815
    },
    {
      "comment": "Puzzle 6: Dream Synthesis \u2014 Emergent Creativity",
      "code": "def puzzle_dream_synthesis():\n    \"\"\"Puzzle 6: Dream Synthesis \u2014 Emergent Creativity\"\"\"\n    print(\"\\nPuzzle 6: Dream Synthesis\")\n    print(\"-\" * 60)\n    \n    # Create dream synthesis ops\n    dream_ops = \"\"\"\ndef dream { description, discovery, operator }\ndef operator { name, function, purpose }\n\nvoice dream.discovery / {dream -> operator}\nvoice describe.operator / {operator -> description}\nvoice implement.operator / {operator -> code}\n\nvoice synthesize.dream / {dream -> dream + operator + code}\n\n",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 274,
      "alignment": 0.5117814353116698,
      "coherence": 0.5117814353116698,
      "comment_phi_k": 8.562896825396827,
      "code_phi_k": 185.984623765939
    },
    {
      "comment": "Run all Level-2 puzzles",
      "code": "def run_all_puzzles():\n    \"\"\"Run all Level-2 puzzles\"\"\"\n    print(\"=\" * 60)\n    print(\"Level-2 Intelligence Puzzles \u2014 Trial by Paradox\")\n    print(\"=\" * 60)\n    print()\n    \n    puzzles = [\n        (\"Code Mutation\", puzzle_code_mutation),\n        (\"Voice Paradox\", puzzle_voice_paradox),\n        (\"Meta-Compiler Bootstrap\", puzzle_meta_compiler_bootstrap),\n        (\"Analogy Construction\", puzzle_analogy_construction),\n        (\"Error Correction\", puzzle_error_correction),\n        (\"Dream Synthesi",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 319,
      "alignment": 0.5087112546110755,
      "coherence": 0.5087112546110755,
      "comment_phi_k": 5.729761904761905,
      "code_phi_k": 167.30049214084073
    },
    {
      "comment": "!/usr/bin/env python3",
      "code": "#!/usr/bin/env python3\n\"\"\"Level-2 Intelligence Puzzles \u2014 Trial by Paradox\"\"\"\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 1,
      "alignment": 0.5606100958437004,
      "coherence": 0.5606100958437004,
      "comment_phi_k": 2.306354756354756,
      "code_phi_k": 10.666257353757354
    },
    {
      "comment": "# Original recursive Swift code",
      "code": "    print(\"Puzzle 1: Code Mutation\")\n    print(\"-\" * 60)\n    \n    # Original recursive Swift code\n    original_code = \"\"\"\nfunc factorial(_ n: Int) -> Int {",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 16,
      "alignment": 0.5913803920986959,
      "coherence": 0.5913803920986959,
      "comment_phi_k": 6.8384920634920645,
      "code_phi_k": 22.12810661560662
    },
    {
      "comment": "# Test if opic can generate iterative version",
      "code": "    print(\"    }\")\n    print()\n    \n    # Test if opic can generate iterative version\n    test_ops = \"\"\"\ndef function { name, params, body }",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 31,
      "alignment": 0.6655633937524997,
      "coherence": 0.6655633937524997,
      "comment_phi_k": 11.334325396825397,
      "code_phi_k": 22.78194444444445
    },
    {
      "comment": "# Generate Swift code",
      "code": "    test_file = Path(\"/tmp/mutation_test.ops\")\n    test_file.write_text(test_ops)\n    \n    # Generate Swift code\n    result = subprocess.run(\n        [sys.executable, \"generate.py\", \"swift\", str(test_file), \"/tmp/mutated.swift\"],",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 46,
      "alignment": 0.5633863152939071,
      "coherence": 0.5633863152939071,
      "comment_phi_k": 4.604761904761905,
      "code_phi_k": 20.463879547979744
    },
    {
      "comment": "# Check if generated code suggests iteration",
      "code": "    )\n    \n    if result.returncode == 0:\n        # Check if generated code suggests iteration\n        generated = Path(\"/tmp/mutated.swift\").read_text()\n        if \"for\" in generated.lower() or \"while\" in generated.lower() or \"loop\" in generated.lower():",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 54,
      "alignment": 0.5852103057134098,
      "coherence": 0.5852103057134098,
      "comment_phi_k": 9.934325396825397,
      "code_phi_k": 34.11365300158621
    },
    {
      "comment": "# Create voices that reference each other",
      "code": "    print(\"\\nPuzzle 2: Voice Paradox\")\n    print(\"-\" * 60)\n    \n    # Create voices that reference each other\n    paradox_ops = \"\"\"\ndef voice { name, input, output, body }",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 72,
      "alignment": 0.6102284709064179,
      "coherence": 0.6102284709064179,
      "comment_phi_k": 10.03670634920635,
      "code_phi_k": 27.78176961926962
    },
    {
      "comment": "# Generate code",
      "code": "    test_file = Path(\"/tmp/paradox_test.ops\")\n    test_file.write_text(paradox_ops)\n    \n    # Generate code\n    result = subprocess.run(\n        [sys.executable, \"generate.py\", \"swift\", str(test_file), \"/tmp/paradox.swift\"],",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 90,
      "alignment": 0.5469617496748851,
      "coherence": 0.5469617496748851,
      "comment_phi_k": 3.2964285714285717,
      "code_phi_k": 19.196690408567775
    },
    {
      "comment": "# Check for self-reference patterns",
      "code": "    \n    if result.returncode == 0:\n        generated = Path(\"/tmp/paradox.swift\").read_text()\n        # Check for self-reference patterns\n        if (\"A\" in generated and \"B\" in generated) or \"paradox\" in generated.lower():\n            print(\"  \u2713 Generated paradoxical composition\")",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 99,
      "alignment": 0.5460940378255623,
      "coherence": 0.5460940378255623,
      "comment_phi_k": 6.167862692862693,
      "code_phi_k": 36.536537061970265
    },
    {
      "comment": "# Test: Can opic compile itself multiple times with same result?",
      "code": "    print(\"\\nPuzzle 3: Meta-Compiler Bootstrap\")\n    print(\"-\" * 60)\n    \n    # Test: Can opic compile itself multiple times with same result?\n    ops_file = Path(\"core.ops\")\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 116,
      "alignment": 0.7098537710237911,
      "coherence": 0.7098537710237911,
      "comment_phi_k": 15.330952380952379,
      "code_phi_k": 25.929327616827624
    },
    {
      "comment": "# Generate Metal code twice",
      "code": "        print(\"  \u2717 core.ops not found\")\n        return False\n    \n    # Generate Metal code twice\n    result1 = subprocess.run(\n        [sys.executable, \"generate.py\", \"metal\", str(ops_file), \"/tmp/bootstrap1.metal\"],",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 123,
      "alignment": 0.5707123647836074,
      "coherence": 0.5707123647836074,
      "comment_phi_k": 6.2214285714285715,
      "code_phi_k": 25.106261282577073
    },
    {
      "comment": "# Compare outputs",
      "code": "    )\n    \n    if result1.returncode == 0 and result2.returncode == 0:\n        # Compare outputs\n        code1 = Path(\"/tmp/bootstrap1.metal\").read_text()\n        code2 = Path(\"/tmp/bootstrap2.metal\").read_text()",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 137,
      "alignment": 0.5603477481106033,
      "coherence": 0.5603477481106033,
      "comment_phi_k": 3.8642857142857148,
      "code_phi_k": 17.940551767461198
    },
    {
      "comment": "# Hash comparison",
      "code": "        code1 = Path(\"/tmp/bootstrap1.metal\").read_text()\n        code2 = Path(\"/tmp/bootstrap2.metal\").read_text()\n        \n        # Hash comparison\n        hash1 = hashlib.md5(code1.encode()).hexdigest()\n        hash2 = hashlib.md5(code2.encode()).hexdigest()",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 141,
      "alignment": 0.5505172026073564,
      "coherence": 0.5505172026073564,
      "comment_phi_k": 3.233134920634921,
      "code_phi_k": 17.616735491019682
    },
    {
      "comment": "# Create analogy between zeta zeros and orbits",
      "code": "    print(\"\\nPuzzle 4: Analogy Construction\")\n    print(\"-\" * 60)\n    \n    # Create analogy between zeta zeros and orbits\n    analogy_ops = \"\"\"\ndef zeta.zero { real, imaginary }",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 161,
      "alignment": 0.6330227305857309,
      "coherence": 0.6330227305857309,
      "comment_phi_k": 11.592857142857142,
      "code_phi_k": 27.58378982128982
    },
    {
      "comment": "# Generate code",
      "code": "    test_file = Path(\"/tmp/analogy_test.ops\")\n    test_file.write_text(analogy_ops)\n    \n    # Generate code\n    result = subprocess.run(\n        [sys.executable, \"generate.py\", \"swift\", str(test_file), \"/tmp/analogy.swift\"],",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 181,
      "alignment": 0.5468863241409913,
      "coherence": 0.5468863241409913,
      "comment_phi_k": 3.2964285714285717,
      "code_phi_k": 19.224920456558053
    },
    {
      "comment": "# Check for analogy structure",
      "code": "    \n    if result.returncode == 0:\n        generated = Path(\"/tmp/analogy.swift\").read_text()\n        # Check for analogy structure\n        if (\"zero\" in generated.lower() and \"orbit\" in generated.lower()) or \"analogy\" in generated.lower():\n            print(\"  \u2713 Generated analogy structure\")",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 190,
      "alignment": 0.5444077480434042,
      "coherence": 0.5444077480434042,
      "comment_phi_k": 6.204563492063492,
      "code_phi_k": 38.0317916031807
    },
    {
      "comment": "# Create corrupted .ops file",
      "code": "    print(\"\\nPuzzle 5: Error Correction\")\n    print(\"-\" * 60)\n    \n    # Create corrupted .ops file\n    original_ops = \"\"\"\ndef test { name, value }",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 207,
      "alignment": 0.5810216046653922,
      "coherence": 0.5810216046653922,
      "comment_phi_k": 5.635317460317461,
      "code_phi_k": 20.205975968475972
    },
    {
      "comment": "# Corrupt it (remove 20% of characters randomly)",
      "code": "voice main / {test -> output}\n\"\"\"\n    \n    # Corrupt it (remove 20% of characters randomly)\n    corrupted = list(original_ops)\n    indices = list(range(len(corrupted)))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 215,
      "alignment": 0.6185448974509489,
      "coherence": 0.6185448974509489,
      "comment_phi_k": 8.783531746031745,
      "code_phi_k": 22.915405301836856
    },
    {
      "comment": "Deterministic for testing",
      "code": "random.seed(42)",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 218,
      "alignment": 0.6183856123458337,
      "coherence": 0.6183856123458337,
      "comment_phi_k": 4.94681290931291,
      "code_phi_k": 1.8940656565656566
    },
    {
      "comment": "# Try to generate code from corrupted file",
      "code": "    \n    print(f\"  Corrupted file: {len(corrupted_ops)}/{len(original_ops)} chars\")\n    \n    # Try to generate code from corrupted file\n    result = subprocess.run(\n        [sys.executable, \"generate.py\", \"swift\", str(corrupted_file), \"/tmp/repaired.swift\"],",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 232,
      "alignment": 0.6062295115792272,
      "coherence": 0.6062295115792272,
      "comment_phi_k": 9.665079365079364,
      "code_phi_k": 27.578289007271913
    },
    {
      "comment": "# Check if it's valid Swift-like structure",
      "code": "    \n    if result.returncode == 0:\n        generated = Path(\"/tmp/repaired.swift\").read_text()\n        # Check if it's valid Swift-like structure\n        if \"func\" in generated or \"struct\" in generated or len(generated) > 50:\n            print(\"  \u2713 Reconstructed valid program\")",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 241,
      "alignment": 0.5682976748598131,
      "coherence": 0.5682976748598131,
      "comment_phi_k": 8.776785714285715,
      "code_phi_k": 36.51534934687999
    },
    {
      "comment": "# Try to repair by adding missing elements",
      "code": "            print(\"  \u26a0 Generated code, but validity unclear\")\n            return False\n    else:\n        # Try to repair by adding missing elements\n        repaired_ops = corrupted_ops\n        if \"def\" not in repaired_ops:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 250,
      "alignment": 0.5834207648224156,
      "coherence": 0.5834207648224156,
      "comment_phi_k": 9.988690476190476,
      "code_phi_k": 34.929009879009875
    },
    {
      "comment": "# Create dream synthesis ops",
      "code": "    print(\"\\nPuzzle 6: Dream Synthesis\")\n    print(\"-\" * 60)\n    \n    # Create dream synthesis ops\n    dream_ops = \"\"\"\ndef dream { description, discovery, operator }",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 279,
      "alignment": 0.5779731961580593,
      "coherence": 0.5779731961580593,
      "comment_phi_k": 6.01031746031746,
      "code_phi_k": 22.275618825618825
    },
    {
      "comment": "# Generate code",
      "code": "    test_file = Path(\"/tmp/dream_test.ops\")\n    test_file.write_text(dream_ops)\n    \n    # Generate code\n    result = subprocess.run(\n        [sys.executable, \"generate.py\", \"swift\", str(test_file), \"/tmp/dream.swift\"],",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 297,
      "alignment": 0.5475762367788539,
      "coherence": 0.5475762367788539,
      "comment_phi_k": 3.2964285714285717,
      "code_phi_k": 18.970037083254926
    },
    {
      "comment": "# Check for creative elements",
      "code": "    \n    if result.returncode == 0:\n        generated = Path(\"/tmp/dream.swift\").read_text()\n        # Check for creative elements\n        if (\"dream\" in generated.lower() or \"operator\" in generated.lower() or \n            \"discover\" in generated.lower() or \"synthesize\" in generated.lower()):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/puzzles.py",
      "line": 306,
      "alignment": 0.5470079411983674,
      "coherence": 0.5470079411983674,
      "comment_phi_k": 6.397023809523809,
      "code_phi_k": 37.219486055327245
    },
    {
      "comment": "Test that Field Spec 0.7 voices are available",
      "code": "def test_field_spec_voices(executor: OpicExecutor) -> dict:\n    \"\"\"Test that Field Spec 0.7 voices are available\"\"\"\n    results = {}\n    \n    # Test Pascal operations\n    pascal_voices = [\n        \"pascal.add\", \"pascal.mul\", \"pascal.combination\",\n        \"pascal.shadow\", \"pascal.trace7_position\"\n    ]\n    results[\"pascal\"] = all(v in executor.voices for v in pascal_voices)\n    \n    # Test Trigonometric operators\n    trig_voices = [\n        \"trig.cos_theta\", \"trig.sin_theta\", \"trig.tan_theta\",\n  ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 15,
      "alignment": 0.514772174643279,
      "coherence": 0.514772174643279,
      "comment_phi_k": 10.93670634920635,
      "code_phi_k": 190.55799998199294
    },
    {
      "comment": "Test that cycle voices can be executed",
      "code": "def test_cycle_execution(executor: OpicExecutor) -> dict:\n    \"\"\"Test that cycle voices can be executed\"\"\"\n    results = {}\n    \n    # Test cycle phase computation\n    try:\n        result = executor.execute_voice(\"cycle.compute_phase\", {\"cycle\": \"test_cycle\"})\n        results[\"cycle_phase\"] = result is not None\n    except:\n        results[\"cycle_phase\"] = False\n    \n    # Test cycle promotion\n    try:\n        result = executor.execute_voice(\"cycle.promote_to_operator\", {\"cycle\": \"test_cycle\"})\n ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 68,
      "alignment": 0.5261912329502592,
      "coherence": 0.5261912329502592,
      "comment_phi_k": 9.847023809523808,
      "code_phi_k": 98.91511424956856
    },
    {
      "comment": "Test that NLP cycle voices can be executed",
      "code": "def test_nlp_cycle_execution(executor: OpicExecutor) -> dict:\n    \"\"\"Test that NLP cycle voices can be executed\"\"\"\n    results = {}\n    \n    # Test masked cycle\n    try:\n        result = executor.execute_voice(\"nlp.masked_cycle\", {\"context\": \"test_context\"})\n        results[\"masked_cycle\"] = result is not None\n    except:\n        results[\"masked_cycle\"] = False\n    \n    # Test attention cycle\n    try:\n        result = executor.execute_voice(\"nlp.attention_cycle\", {\n            \"token_i\": \"token1",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 96,
      "alignment": 0.5277039868107796,
      "coherence": 0.5277039868107796,
      "comment_phi_k": 10.763690476190476,
      "code_phi_k": 102.51308621892727
    },
    {
      "comment": "Run all Field Spec 0.7 tests",
      "code": "def main():\n    \"\"\"Run all Field Spec 0.7 tests\"\"\"\n    project_root = Path(__file__).parent.parent\n    executor = OpicExecutor(project_root)\n    \n    print(\"=\" * 60)\n    print(\"Field Spec 0.7 Tests\")\n    print(\"=\" * 60)\n    print(f\"\\nLoaded {len(executor.voices)} voices\\n\")\n    \n    # Test 1: Voice availability\n    print(\"Test 1: Voice Availability\")\n    print(\"-\" * 60)\n    availability = test_field_spec_voices(executor)\n    for category, passed in availability.items():\n        status = \"\u2713\" if p",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 129,
      "alignment": 0.5066981104609047,
      "coherence": 0.5066981104609047,
      "comment_phi_k": 6.741666666666666,
      "code_phi_k": 254.99652336995374
    },
    {
      "comment": "!/usr/bin/env python3",
      "code": "#!/usr/bin/env python3\n\"\"\"\nTest runner for Field Spec 0.7 and Cycle-to-Dimension Principle",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 1,
      "alignment": 0.5449101186767739,
      "coherence": 0.5449101186767739,
      "comment_phi_k": 2.306354756354756,
      "code_phi_k": 13.991902949991186
    },
    {
      "comment": "Import opic executor",
      "code": "import sys\nfrom pathlib import Path\n\n# Import opic executor\nsys.path.insert(0, str(Path(__file__).parent))\nfrom opic_executor import OpicExecutor",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 10,
      "alignment": 0.5627338052963309,
      "coherence": 0.5627338052963309,
      "comment_phi_k": 5.755357142857143,
      "code_phi_k": 25.8133075981989
    },
    {
      "comment": "# Test Pascal operations",
      "code": "    \"\"\"Test that Field Spec 0.7 voices are available\"\"\"\n    results = {}\n    \n    # Test Pascal operations\n    pascal_voices = [\n        \"pascal.add\", \"pascal.mul\", \"pascal.combination\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 19,
      "alignment": 0.5635885240534749,
      "coherence": 0.5635885240534749,
      "comment_phi_k": 5.231746031746031,
      "code_phi_k": 23.18462386211999
    },
    {
      "comment": "# Test Trigonometric operators",
      "code": "    ]\n    results[\"pascal\"] = all(v in executor.voices for v in pascal_voices)\n    \n    # Test Trigonometric operators\n    trig_voices = [\n        \"trig.cos_theta\", \"trig.sin_theta\", \"trig.tan_theta\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 26,
      "alignment": 0.5673914462471261,
      "coherence": 0.5673914462471261,
      "comment_phi_k": 5.569630369630369,
      "code_phi_k": 23.446303696303694
    },
    {
      "comment": "# Test Flow symmetry",
      "code": "    ]\n    results[\"trig\"] = all(v in executor.voices for v in trig_voices)\n    \n    # Test Flow symmetry\n    flow_voices = [\n        \"flow.equilibrium\", \"flow.hermitian_flow\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 33,
      "alignment": 0.5529284296138541,
      "coherence": 0.5529284296138541,
      "comment_phi_k": 3.9589285714285714,
      "code_phi_k": 20.678907100811124
    },
    {
      "comment": "# Check if at least 3 flow voices exist",
      "code": "        \"flow.equilibrium\", \"flow.hermitian_flow\",\n        \"flow.standing_wave\", \"flow.forward_bias\", \"flow.reverse_bias\"\n    ]\n    # Check if at least 3 flow voices exist\n    results[\"flow\"] = sum(v in executor.voices for v in flow_voices) >= 3\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 38,
      "alignment": 0.6050557495382957,
      "coherence": 0.6050557495382957,
      "comment_phi_k": 10.125,
      "code_phi_k": 29.15685001058453
    },
    {
      "comment": "# Test Cycle-to-dimension",
      "code": "    # Check if at least 3 flow voices exist\n    results[\"flow\"] = sum(v in executor.voices for v in flow_voices) >= 3\n    \n    # Test Cycle-to-dimension\n    cycle_voices = [\n        \"cycle.compute_phase\", \"cycle.compute_charge\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 41,
      "alignment": 0.5285799650247108,
      "coherence": 0.5285799650247108,
      "comment_phi_k": 3.2074096654979005,
      "code_phi_k": 29.66015681514908
    },
    {
      "comment": "# Test NLP cycles",
      "code": "    ]\n    results[\"cycle\"] = all(v in executor.voices for v in cycle_voices)\n    \n    # Test NLP cycles\n    nlp_cycle_voices = [\n        \"nlp.masked_cycle\", \"nlp.masked_promotion\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 50,
      "alignment": 0.5490889498168309,
      "coherence": 0.5490889498168309,
      "comment_phi_k": 3.533333333333333,
      "code_phi_k": 19.76121200995427
    },
    {
      "comment": "# Test Dimensional expansion",
      "code": "    ]\n    results[\"nlp_cycles\"] = all(v in executor.voices for v in nlp_cycle_voices)\n    \n    # Test Dimensional expansion\n    dimension_voices = [\n        \"dimension.symmetry_break\", \"dimension.witness_event\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 58,
      "alignment": 0.5671709521102247,
      "coherence": 0.5671709521102247,
      "comment_phi_k": 5.533946608946609,
      "code_phi_k": 23.363475345510444
    },
    {
      "comment": "# Test cycle phase computation",
      "code": "    \"\"\"Test that cycle voices can be executed\"\"\"\n    results = {}\n    \n    # Test cycle phase computation\n    try:\n        result = executor.execute_voice(\"cycle.compute_phase\", {\"cycle\": \"test_cycle\"})",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 72,
      "alignment": 0.5706956951524912,
      "coherence": 0.5706956951524912,
      "comment_phi_k": 5.978589466089466,
      "code_phi_k": 24.131280299469985
    },
    {
      "comment": "# Test cycle promotion",
      "code": "    except:\n        results[\"cycle_phase\"] = False\n    \n    # Test cycle promotion\n    try:\n        result = executor.execute_voice(\"cycle.promote_to_operator\", {\"cycle\": \"test_cycle\"})",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 79,
      "alignment": 0.5717173780403205,
      "coherence": 0.5717173780403205,
      "comment_phi_k": 4.348412698412698,
      "code_phi_k": 17.332361935875863
    },
    {
      "comment": "# Test learning threshold",
      "code": "    except:\n        results[\"cycle_promotion\"] = False\n    \n    # Test learning threshold\n    try:\n        result = executor.execute_voice(\"cycle.learning_threshold\", {\"all_cycles\": \"test_cycles\"})",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 86,
      "alignment": 0.575235711449885,
      "coherence": 0.575235711449885,
      "comment_phi_k": 4.761507936507936,
      "code_phi_k": 18.202721504507046
    },
    {
      "comment": "# Test masked cycle",
      "code": "    \"\"\"Test that NLP cycle voices can be executed\"\"\"\n    results = {}\n    \n    # Test masked cycle\n    try:\n        result = executor.execute_voice(\"nlp.masked_cycle\", {\"context\": \"test_context\"})",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 100,
      "alignment": 0.5479251433032274,
      "coherence": 0.5479251433032274,
      "comment_phi_k": 4.108333333333333,
      "code_phi_k": 23.48515805327284
    },
    {
      "comment": "# Test attention cycle",
      "code": "    except:\n        results[\"masked_cycle\"] = False\n    \n    # Test attention cycle\n    try:\n        result = executor.execute_voice(\"nlp.attention_cycle\", {",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 107,
      "alignment": 0.5870012295408475,
      "coherence": 0.5870012295408475,
      "comment_phi_k": 4.7067460317460315,
      "code_phi_k": 15.878314147699744
    },
    {
      "comment": "# Test hermitian attention",
      "code": "    except:\n        results[\"attention_cycle\"] = False\n    \n    # Test hermitian attention\n    try:\n        result = executor.execute_voice(\"nlp.hermitian_attention\", {",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 117,
      "alignment": 0.5953235925165796,
      "coherence": 0.5953235925165796,
      "comment_phi_k": 5.363492063492063,
      "code_phi_k": 16.748284865139226
    },
    {
      "comment": "# Test 1: Voice availability",
      "code": "    print(\"=\" * 60)\n    print(f\"\\nLoaded {len(executor.voices)} voices\\n\")\n    \n    # Test 1: Voice availability\n    print(\"Test 1: Voice Availability\")\n    print(\"-\" * 60)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 139,
      "alignment": 0.5838613783179135,
      "coherence": 0.5838613783179135,
      "comment_phi_k": 5.48910533910534,
      "code_phi_k": 19.108179911333934
    },
    {
      "comment": "# Test 2: Cycle execution",
      "code": "    all_available = all(availability.values())\n    print(f\"\\n  Result: {sum(availability.values())}/{len(availability)} categories available\")\n    \n    # Test 2: Cycle execution\n    print(\"\\nTest 2: Cycle Execution\")\n    print(\"-\" * 60)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 150,
      "alignment": 0.5519598079647278,
      "coherence": 0.5519598079647278,
      "comment_phi_k": 4.848412698412698,
      "code_phi_k": 25.75191332275777
    },
    {
      "comment": "# Test 3: NLP cycle execution",
      "code": "    cycle_passed = all(cycle_exec.values())\n    print(f\"\\n  Result: {sum(cycle_exec.values())}/{len(cycle_exec)} tests passed\")\n    \n    # Test 3: NLP cycle execution\n    print(\"\\nTest 3: NLP Cycle Execution\")\n    print(\"-\" * 60)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 161,
      "alignment": 0.565446973116239,
      "coherence": 0.565446973116239,
      "comment_phi_k": 5.765079365079365,
      "code_phi_k": 24.90448772145101
    },
    {
      "comment": "# Summary",
      "code": "    nlp_passed = all(nlp_exec.values())\n    print(f\"\\n  Result: {sum(nlp_exec.values())}/{len(nlp_exec)} tests passed\")\n    \n    # Summary\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Summary\")",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/test_field_spec.py",
      "line": 172,
      "alignment": 0.5269225649520676,
      "coherence": 0.5269225649520676,
      "comment_phi_k": 1.6464285714285714,
      "code_phi_k": 16.111770320028302
    },
    {
      "comment": "Execute opic voices from Python",
      "code": "class OpicExecutor:\n    \"\"\"Execute opic voices from Python\"\"\"\n    \n    def __init__(self, project_root: Path):\n        self.project_root = project_root\n        self.voices = {}\n        self.defs = {}\n        self.loaded_files = set()\n        self.primitives = {}\n        self.embedding_cache = {}  # Cache for semantic embeddings\n        self._load_opic_systems()\n        self._init_primitives()\n    \n    def _load_opic_systems(self):\n        \"\"\"Load opic's core systems including Field Spec 0.7\"\"\"\n ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 33,
      "alignment": 0.500164240686968,
      "coherence": 0.500164240686968,
      "comment_phi_k": 8.117857142857142,
      "code_phi_k": 12360.70649977053
    },
    {
      "comment": "Load opic's core systems including Field Spec 0.7",
      "code": "    def _load_opic_systems(self):\n        \"\"\"Load opic's core systems including Field Spec 0.7\"\"\"\n        # Load bootstrap\n        bootstrap_path = self.project_root / \"core\" / \"bootstrap.ops\"\n        if bootstrap_path.exists():\n            self._load_ops_file(bootstrap_path)\n        \n        # Load core files (includes Field Spec 0.7 by default)\n        core_files = [\"opic_field.ops\", \"planning.ops\", \"reasoning.ops\", \"ml.ops\"]\n        for core_file in core_files:\n            core_path = self.pr",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 46,
      "alignment": 0.5248582527908603,
      "coherence": 0.5248582527908603,
      "comment_phi_k": 10.915674603174603,
      "code_phi_k": 115.23701903864824
    },
    {
      "comment": "Load an .ops file and its includes",
      "code": "    def _load_ops_file(self, file_path: Path):\n        \"\"\"Load an .ops file and its includes\"\"\"\n        if file_path in self.loaded_files:\n            return\n        \n        if not file_path.exists():\n            return\n        \n        self.loaded_files.add(file_path)\n        content = file_path.read_text()\n        defs, voices, includes = parse_ops(content)\n        \n        self.defs.update(defs)\n        self.voices.update(voices)\n        \n        # Load includes recursively\n        for inclu",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 75,
      "alignment": 0.5315342632819078,
      "coherence": 0.5315342632819078,
      "comment_phi_k": 9.780357142857142,
      "code_phi_k": 82.42772127080453
    },
    {
      "comment": "Execute an opic voice chain directly using opic's execution semantics\nVoices are declarative chains that opic executes - no Python implementation needed",
      "code": "    def execute_voice(self, voice_name: str, inputs: Dict[str, Any] = None) -> Any:\n        \"\"\"\n        Execute an opic voice chain directly using opic's execution semantics\n        Voices are declarative chains that opic executes - no Python implementation needed\n        \"\"\"\n        inputs = inputs or {}\n        \n        # SPEC voices execute through their declarative chains\n        # No fast-path - let opic execute them natively\n        \n        if voice_name not in self.voices:\n            # ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 97,
      "alignment": 0.5548392403423112,
      "coherence": 0.5548392403423112,
      "comment_phi_k": 36.17618353868353,
      "code_phi_k": 183.00733259429086
    },
    {
      "comment": "Direct implementation of corpus.read - fast path",
      "code": "    def _corpus_read_direct(self, path: Any) -> List[Dict[str, str]]:\n        \"\"\"Direct implementation of corpus.read - fast path\"\"\"\n        from pathlib import Path\n        import os\n        \n        root = Path(str(path))\n        files = []\n        for dirpath, dirnames, filenames in os.walk(root):\n            if any(part.startswith('.') for part in Path(dirpath).parts):\n                continue\n            if any(seg in dirpath for seg in (\"/.git\", \"/build\", \"/dist\", \"/node_modules\", \"/__pyca",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 127,
      "alignment": 0.5224937519916596,
      "coherence": 0.5224937519916596,
      "comment_phi_k": 9.754736929736929,
      "code_phi_k": 113.2934403295565
    },
    {
      "comment": "Direct implementation of corpus.project - fast path",
      "code": "    def _corpus_project_direct(self, lines: List[Any]) -> List[Dict[str, Any]]:\n        \"\"\"Direct implementation of corpus.project - fast path\"\"\"\n        import json\n        from collections import Counter\n        import math\n        \n        def shannon_entropy(s: str) -> float:\n            if not s:\n                return 0.0\n            counts = Counter(s)\n            n = len(s)\n            ent = 0.0\n            for c in counts.values():\n                p = c / n\n                ent -= p * ma",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 152,
      "alignment": 0.5128434489478456,
      "coherence": 0.5128434489478456,
      "comment_phi_k": 9.856690531690532,
      "code_phi_k": 196.79056568102237
    },
    {
      "comment": "Automatically discover relevant voices based on context\nImplements opic's automatic voice discovery semantics",
      "code": "    def _discover_relevant_voices(self, context: str, current_step: str = None) -> List[str]:\n        \"\"\"\n        Automatically discover relevant voices based on context\n        Implements opic's automatic voice discovery semantics\n        \"\"\"\n        discovered = []\n        \n        # Context-based discovery patterns\n        context_lower = context.lower()\n        \n        # Discover thermo.* voices for learning/energy contexts\n        if any(keyword in context_lower for keyword in ['learn', 'e",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 218,
      "alignment": 0.5146045273476977,
      "coherence": 0.5146045273476977,
      "comment_phi_k": 24.131336718836714,
      "code_phi_k": 425.14539604127447
    },
    {
      "comment": "Enhance result using discovered voices when appropriate\nImplements automatic composition of discovered voices",
      "code": "    def _enhance_with_discovered(self, result: Any, discovered_voices: List[str], context: str) -> Any:\n        \"\"\"\n        Enhance result using discovered voices when appropriate\n        Implements automatic composition of discovered voices\n        \"\"\"\n        # For now, return result as-is\n        # Future: intelligently compose discovered voices to enhance result\n        # This could use field operations, thermo operations, etc. based on context\n        return result",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 276,
      "alignment": 0.5883347043042466,
      "coherence": 0.5883347043042466,
      "comment_phi_k": 24.107395382395385,
      "code_phi_k": 80.28111626998054
    },
    {
      "comment": "Simple token Jaccard similarity between two strings",
      "code": "    def _string_similarity(self, a: Any, b: Any) -> float:\n        \"\"\"Simple token Jaccard similarity between two strings\"\"\"\n        sa = set(self._string_tokens(a))\n        sb = set(self._string_tokens(b))\n        if not sa and not sb:\n            return 1.0\n        if not sa or not sb:\n            return 0.0\n        inter = len(sa & sb)\n        union = len(sa | sb)\n        return inter / union if union else 0.0",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 290,
      "alignment": 0.5509631267931882,
      "coherence": 0.5509631267931882,
      "comment_phi_k": 10.941269841269841,
      "code_phi_k": 59.143116034628676
    },
    {
      "comment": "Compute a [0,1] confidence score for a candidate value based on:\n- Match to expected target (if provided)\n- Best match to any provided choices (if provided)\n- Energy consistency with previous result (via field-based coupling)",
      "code": "    def _score_candidate(self, value: Any, env: Dict[str, Any], last_value: Any) -> float:\n        \"\"\"\n        Compute a [0,1] confidence score for a candidate value based on:\n        - Match to expected target (if provided)\n        - Best match to any provided choices (if provided)\n        - Energy consistency with previous result (via field-based coupling)\n        \"\"\"\n        score = 0.0\n        \n        # Target match (exact/semantic)\n        target = env.get(\"target\") or env.get(\"answer\") or",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 302,
      "alignment": 0.5582448292192185,
      "coherence": 0.5582448292192185,
      "comment_phi_k": 46.85559163059163,
      "code_phi_k": 224.54260831753223
    },
    {
      "comment": "Heuristic sign/charge of a value",
      "code": "    def _get_last_charge(self, val: Any) -> float:\n        \"\"\"Heuristic sign/charge of a value\"\"\"\n        return self._get_step_charge(val)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 345,
      "alignment": 0.6461413379283241,
      "coherence": 0.6461413379283241,
      "comment_phi_k": 7.628210678210678,
      "code_phi_k": 16.863477245690703
    },
    {
      "comment": "Heuristic distance between strings for energy coupling",
      "code": "    def _string_distance(self, a: str, b: str) -> float:\n        \"\"\"Heuristic distance between strings for energy coupling\"\"\"\n        return self._get_last_distance(a, b)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 349,
      "alignment": 0.6800569048022843,
      "coherence": 0.6800569048022843,
      "comment_phi_k": 11.833531746031746,
      "code_phi_k": 22.347032403235627
    },
    {
      "comment": "Levenshtein distance (simple DP) normalized by max length",
      "code": "    def _string_edit_distance(self, a: str, b: str) -> float:\n        \"\"\"Levenshtein distance (simple DP) normalized by max length\"\"\"\n        A, B = str(a), str(b)\n        la, lb = len(A), len(B)\n        if la == 0 and lb == 0:\n            return 0.0\n        dp = [[0] * (lb + 1) for _ in range(la + 1)]\n        for i in range(la + 1):\n            dp[i][0] = i\n        for j in range(lb + 1):\n            dp[0][j] = j\n        for i in range(1, la + 1):\n            for j in range(1, lb + 1):\n        ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 356,
      "alignment": 0.5319795652990718,
      "coherence": 0.5319795652990718,
      "comment_phi_k": 10.879581529581529,
      "code_phi_k": 90.49083373423142
    },
    {
      "comment": "Register primitive operators used by OPIC Field Spec 0.7\nThese are minimal implementations to ground declarative voices",
      "code": "    def _init_primitives(self) -> None:\n        \"\"\"\n        Register primitive operators used by OPIC Field Spec 0.7\n        These are minimal implementations to ground declarative voices\n        \"\"\"\n        import math\n        \n        def coulomb_yukawa(env: Dict[str, Any]) -> float:\n            q_i = float(env.get(\"q_i\", 0.0))\n            q_j = float(env.get(\"q_j\", 0.0))\n            R_ij = float(env.get(\"R_ij\", 1.0))\n            D = int(env.get(\"D\", 1))\n            mu = float(env.get(\"mu\", 0.",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 379,
      "alignment": 0.5012262749905861,
      "coherence": 0.5012262749905861,
      "comment_phi_k": 26.297215284715286,
      "code_phi_k": 5374.3472552933235
    },
    {
      "comment": "Invoke a registered primitive if available",
      "code": "    def _call_primitive(self, name: str, env: Dict[str, Any]) -> Any:\n        \"\"\"Invoke a registered primitive if available\"\"\"\n        func = self.primitives.get(name)\n        if not func:\n            return None\n        try:\n            return func(env)\n        except Exception:\n            return None",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1583,
      "alignment": 0.5711786256286882,
      "coherence": 0.5711786256286882,
      "comment_phi_k": 10.30297619047619,
      "code_phi_k": 41.338531956631634
    },
    {
      "comment": "Evaluate a single step token:\n- quoted strings -> literal\n- variables -> env lookup\n- '+' expressions -> combine\n- primitive names -> call with env\n- assignment-like tokens -> bind last_result",
      "code": "    def _evaluate_step_token(self, token: str, env: Dict[str, Any], last_result: Any) -> Any:\n        \"\"\"\n        Evaluate a single step token:\n        - quoted strings -> literal\n        - variables -> env lookup\n        - '+' expressions -> combine\n        - primitive names -> call with env\n        - assignment-like tokens -> bind last_result\n        \"\"\"\n        t = token.strip()\n        \n        # Literal string\n        if (t.startswith('\"') and t.endswith('\"')) or (t.startswith(\"'\") and t.en",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1593,
      "alignment": 0.5351890282233319,
      "coherence": 0.5351890282233319,
      "comment_phi_k": 35.90513375513375,
      "code_phi_k": 273.0401294500321
    },
    {
      "comment": "Execute opic voice chain following opic's execution semantics\nImplements the structure described by opic.execute_chain:\n{chain_string -> parse_chain -> resolve_steps -> execute_steps -> result}\n\nThe opic execution voices are declarative - they describe the flow.\nThis Python implementation provides the actual execution logic.",
      "code": "    def _execute_opic_chain(self, chain_str: str, inputs: Dict[str, Any] = None) -> Any:\n        \"\"\"\n        Execute opic voice chain following opic's execution semantics\n        Implements the structure described by opic.execute_chain:\n        {chain_string -> parse_chain -> resolve_steps -> execute_steps -> result}\n        \n        The opic execution voices are declarative - they describe the flow.\n        This Python implementation provides the actual execution logic.\n        \"\"\"\n        inpu",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1648,
      "alignment": 0.652192983798218,
      "coherence": 0.652192983798218,
      "comment_phi_k": 63.201528047116305,
      "code_phi_k": 135.41883511629456
    },
    {
      "comment": "Parse chain following opic.parse_chain structure:\n{chain -> remove_braces -> split_arrows -> steps}",
      "code": "    def _parse_chain(self, chain_str: str) -> List[str]:\n        \"\"\"\n        Parse chain following opic.parse_chain structure:\n        {chain -> remove_braces -> split_arrows -> steps}\n        \"\"\"\n        # opic.remove_braces: strip \"{ }\"\n        chain_body = chain_str.strip()\n        if chain_body.startswith(\"{\") and chain_body.endswith(\"}\"):\n            chain_body = chain_body[1:-1].strip()\n        \n        # opic.split_arrows: split \"->\" and trim each\n        steps = [s.strip() for s in chain",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1671,
      "alignment": 0.5745488725769532,
      "coherence": 0.5745488725769532,
      "comment_phi_k": 14.871105977355976,
      "code_phi_k": 57.305877861818246
    },
    {
      "comment": "Resolve steps following opic.resolve_steps structure:\n{steps -> for_each_step -> find_voice -> resolve_body}",
      "code": "    def _resolve_steps(self, steps: List[str], inputs: Dict[str, Any]) -> List[Any]:\n        \"\"\"\n        Resolve steps following opic.resolve_steps structure:\n        {steps -> for_each_step -> find_voice -> resolve_body}\n        \"\"\"\n        resolved = []\n        for step in steps:\n            # opic.find_voice: {step_name + voices -> lookup -> voice_body}\n            if step in inputs:\n                resolved.append(inputs[step])\n            elif step in self.voices:\n                voice_body",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1685,
      "alignment": 0.5295225698223326,
      "coherence": 0.5295225698223326,
      "comment_phi_k": 15.547689320483439,
      "code_phi_k": 139.4331938805988
    },
    {
      "comment": "Execute steps following opic.execute_steps structure:\n{resolved_steps -> for_each -> execute_step -> collect_results}\n\nUses energy coupling (field.energy_exchange) to compute object flow\nbetween steps based on field potential and dimensional Coulomb law.\n\nStops at equilibrium when energy flow stabilizes.",
      "code": "    def _execute_steps(self, resolved_steps: List[Any], inputs: Dict[str, Any]) -> Any:\n        \"\"\"\n        Execute steps following opic.execute_steps structure:\n        {resolved_steps -> for_each -> execute_step -> collect_results}\n        \n        Uses energy coupling (field.energy_exchange) to compute object flow\n        between steps based on field potential and dimensional Coulomb law.\n        \n        Stops at equilibrium when energy flow stabilizes.\n        \"\"\"\n        result = None\n    ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1712,
      "alignment": 0.516974956754676,
      "coherence": 0.516974956754676,
      "comment_phi_k": 56.971713599867606,
      "code_phi_k": 867.5412138065724
    },
    {
      "comment": "Compute energy coupling using field.energy_exchange voice:\n{q_i + q_j + s_i + s_j + R_ij + D + mu -> coulomb_yukawa -> E_ij}\n\nExecutes opic's native field.energy_exchange voice for actual computation",
      "code": "    def _compute_energy_coupling(self, q_i: float, q_j: float, s_i: Any, s_j: Any, R_ij: float, D: int = 1, mu: float = 0.1) -> float:\n        \"\"\"\n        Compute energy coupling using field.energy_exchange voice:\n        {q_i + q_j + s_i + s_j + R_ij + D + mu -> coulomb_yukawa -> E_ij}\n        \n        Executes opic's native field.energy_exchange voice for actual computation\n        \"\"\"\n        # Skip recursive call to field.energy_exchange to avoid infinite recursion\n        # Use direct compu",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1840,
      "alignment": 0.5484428265684251,
      "coherence": 0.5484428265684251,
      "comment_phi_k": 34.873401495305515,
      "code_phi_k": 197.40865926893747
    },
    {
      "comment": "Extract charge from step (q \u2208 {+1, -1} for ions, or computed from step properties)",
      "code": "    def _get_step_charge(self, step: Any) -> float:\n        \"\"\"\n        Extract charge from step (q \u2208 {+1, -1} for ions, or computed from step properties)\n        \"\"\"\n        if isinstance(step, str):\n            # Simple heuristic: positive charge for forward flow, negative for reverse\n            if step.startswith(\"+\") or \"forward\" in step.lower():\n                return 1.0\n            elif step.startswith(\"-\") or \"reverse\" in step.lower():\n                return -1.0\n            # Default: ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1867,
      "alignment": 0.5570848854691488,
      "coherence": 0.5570848854691488,
      "comment_phi_k": 16.29265873015873,
      "code_phi_k": 79.4990990004148
    },
    {
      "comment": "Compute distance R_ij between steps using semantic embeddings\nUses Field Spec 0.7: distance = ||embedding1 - embedding2||",
      "code": "    def _get_step_distance(self, step1: Any, step2: Any) -> float:\n        \"\"\"\n        Compute distance R_ij between steps using semantic embeddings\n        Uses Field Spec 0.7: distance = ||embedding1 - embedding2||\n        \"\"\"\n        if isinstance(step1, str) and isinstance(step2, str):\n            if step1 == step2:\n                return 0.1  # Very close\n            \n            # Use semantic embeddings for distance\n            emb1 = self._get_semantic_embedding(step1)\n            emb2 =",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1882,
      "alignment": 0.565178294208292,
      "coherence": 0.565178294208292,
      "comment_phi_k": 22.683152958152956,
      "code_phi_k": 98.3458208892778
    },
    {
      "comment": "Generate semantic embedding using Field Spec 0.7 principles\nUses zeta-trace, Pascal mod 10, and field potential",
      "code": "    def _get_semantic_embedding(self, text: str, dim: int = 64) -> List[float]:\n        \"\"\"\n        Generate semantic embedding using Field Spec 0.7 principles\n        Uses zeta-trace, Pascal mod 10, and field potential\n        \"\"\"\n        # Cache embeddings\n        cache_key = f\"{text}:{dim}\"\n        if cache_key in self.embedding_cache:\n            return self.embedding_cache[cache_key]\n        \n        # Convert text to embedding using Field Spec operations\n        # 1. Token quantization (NL",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1902,
      "alignment": 0.5229201131663798,
      "coherence": 0.5229201131663798,
      "comment_phi_k": 23.341468253968255,
      "code_phi_k": 266.26664389114916
    },
    {
      "comment": "Learn from coupling code with its output.\nUpdates field based on successful patterns.",
      "code": "    def _learn_from_code_output(self, code_trace: Dict, output: int, correct_answer: int, \n                                field_state: Dict, zeros: List) -> None:\n        \"\"\"\n        Learn from coupling code with its output.\n        Updates field based on successful patterns.\n        \"\"\"\n        # Store code-output pair for learning\n        correctness = 1.0 if output == correct_answer else 0.0\n        \n        # Only learn from successful outputs (or track failures)\n        if correctness > 0.",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1957,
      "alignment": 0.5306894028074267,
      "coherence": 0.5306894028074267,
      "comment_phi_k": 20.7343253968254,
      "code_phi_k": 179.27176412493347
    },
    {
      "comment": "Answer a question using enhanced zero interpretation and composer planning.\nIntegrates:\n- Zero interpretation for semantic understanding\n- Composer planning for answer generation\n- Document understanding pipeline for question+choices\n- BERT knowledge base for semantic knowledge",
      "code": "    def answer_question(self, question: str, choices: List[str] = None) -> int:\n        \"\"\"\n        Answer a question using enhanced zero interpretation and composer planning.\n        Integrates:\n        - Zero interpretation for semantic understanding\n        - Composer planning for answer generation\n        - Document understanding pipeline for question+choices\n        - BERT knowledge base for semantic knowledge\n        \"\"\"\n        if not choices:\n            return 0\n        \n        # Step ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1981,
      "alignment": 0.5055503227238429,
      "coherence": 0.5055503227238429,
      "comment_phi_k": 55.70533841158842,
      "code_phi_k": 2536.9562467459923
    },
    {
      "comment": "Select best answer using Field Spec 0.7 energy coupling with semantic embeddings\nUses field operations on meaning vectors",
      "code": "    def _select_answer_by_energy(self, question: str, choices: List[str], reasoning: str = None) -> Optional[int]:\n        \"\"\"\n        Select best answer using Field Spec 0.7 energy coupling with semantic embeddings\n        Uses field operations on meaning vectors\n        \"\"\"\n        if not choices:\n            return None\n        \n        # Get semantic embeddings\n        q_emb = self._get_semantic_embedding(question)\n        reasoning_emb = self._get_semantic_embedding(reasoning) if reasoning ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2457,
      "alignment": 0.5232451392910489,
      "coherence": 0.5232451392910489,
      "comment_phi_k": 28.64146825396825,
      "code_phi_k": 322.35791015067593
    },
    {
      "comment": "Solve a math problem using opic's math system with Field Spec 0.7\nUses cycle operations for multi-step math reasoning",
      "code": "    def solve_math_problem(self, problem: str) -> str:\n        \"\"\"\n        Solve a math problem using opic's math system with Field Spec 0.7\n        Uses cycle operations for multi-step math reasoning\n        \"\"\"\n        # Execute math.solve - opic composes Field Spec 0.7 internally\n        try:\n            result = self.execute_voice(\"math.solve\", {\"problem\": problem})\n            if result:\n                # Extract numeric answer\n                import re\n                nums = re.findall(r'-",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2522,
      "alignment": 0.5694641077476039,
      "coherence": 0.5694641077476039,
      "comment_phi_k": 27.167460317460318,
      "code_phi_k": 111.35890210858301
    },
    {
      "comment": "Compute Shannon entropy of a string",
      "code": "        def shannon_entropy(env: Dict[str, Any]) -> float:\n            \"\"\"Compute Shannon entropy of a string\"\"\"\n            import math\n            from collections import Counter\n            s = str(env.get(\"line\", env.get(\"s\", \"\")))\n            if not s:\n                return 0.0\n            counts = Counter(s)\n            n = len(s)\n            ent = 0.0\n            for c in counts.values():\n                p = c / n\n                ent -= p * math.log2(p) if p > 0 else 0\n            return",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 423,
      "alignment": 0.5416303425457251,
      "coherence": 0.5416303425457251,
      "comment_phi_k": 8.760714285714286,
      "code_phi_k": 56.99050727609163
    },
    {
      "comment": "Compute ordinal curvature (second-difference magnitude)",
      "code": "        def ordinal_curvature(env: Dict[str, Any]) -> float:\n            \"\"\"Compute ordinal curvature (second-difference magnitude)\"\"\"\n            s = str(env.get(\"line\", env.get(\"s\", \"\")))\n            xs = [ord(c) for c in s]\n            if len(xs) < 3:\n                return 0.0\n            acc = 0.0\n            cnt = 0\n            for i in range(1, len(xs) - 1):\n                sec = xs[i + 1] - 2 * xs[i] + xs[i - 1]\n                acc += abs(sec)\n                cnt += 1\n            return ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 438,
      "alignment": 0.5492415599826536,
      "coherence": 0.5492415599826536,
      "comment_phi_k": 9.10684891089303,
      "code_phi_k": 50.789007335543715
    },
    {
      "comment": "Exponentially weighted moving average of entropy delta",
      "code": "        def ewma_delta(env: Dict[str, Any]) -> float:\n            \"\"\"Exponentially weighted moving average of entropy delta\"\"\"\n            prev_entropy = float(env.get(\"prev_entropy\", 0.0))\n            current_entropy = float(env.get(\"current_entropy\", env.get(\"phi_entropy\", 0.0)))\n            prev_boundary = float(env.get(\"prev_boundary\", 0.0))\n            alpha = float(env.get(\"alpha\", 0.3))\n            delta = abs(current_entropy - prev_entropy)\n            return (1 - alpha) * prev_boundary ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 452,
      "alignment": 0.5699635542166167,
      "coherence": 0.5699635542166167,
      "comment_phi_k": 12.623598623598625,
      "code_phi_k": 51.41956565152189
    },
    {
      "comment": "Walk directory and return file paths",
      "code": "        def file_walk(env: Dict[str, Any]) -> List[str]:\n            \"\"\"Walk directory and return file paths\"\"\"\n            import os\n            from pathlib import Path\n            root = Path(str(env.get(\"path\", \".\")))\n            files = []\n            for dirpath, dirnames, filenames in os.walk(root):\n                # Skip hidden and build dirs\n                if any(part.startswith('.') for part in Path(dirpath).parts):\n                    continue\n                if any(seg in dirpath fo",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 461,
      "alignment": 0.523150324244633,
      "coherence": 0.523150324244633,
      "comment_phi_k": 8.977579365079366,
      "code_phi_k": 101.43753292919897
    },
    {
      "comment": "Read file content",
      "code": "        def file_read(env: Dict[str, Any]) -> str:\n            \"\"\"Read file content\"\"\"\n            from pathlib import Path\n            path = Path(str(env.get(\"file\", env.get(\"path\", \"\"))))\n            try:\n                return path.read_text(encoding='utf-8', errors='ignore')\n            except:\n                return \"\"",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 481,
      "alignment": 0.5375865856982941,
      "coherence": 0.5375865856982941,
      "comment_phi_k": 4.521428571428571,
      "code_phi_k": 32.33413334884681
    },
    {
      "comment": "SPEC \u00a712: project \u03b6 features onto lines -> traces",
      "code": "        def project_zeta_features(env: Dict[str, Any]) -> List[Dict[str, Any]]:\n            \"\"\"SPEC \u00a712: project \u03b6 features onto lines -> traces\"\"\"\n            lines = env.get(\"lines\", env.get(\"input\", []))\n            if not isinstance(lines, list):\n                return []\n            \n            traces = []\n            prev_entropy = 0.0\n            prev_boundary = 0.0\n            \n            for line_data in lines:\n                if isinstance(line_data, dict):\n                    line =",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 490,
      "alignment": 0.5191722524656572,
      "coherence": 0.5191722524656572,
      "comment_phi_k": 9.893452380952382,
      "code_phi_k": 133.95416022403958
    },
    {
      "comment": "SPEC \u00a712: chain with zeros.on.critical -> witnesses",
      "code": "        def chain_zeros_critical(env: Dict[str, Any]) -> Any:\n            \"\"\"SPEC \u00a712: chain with zeros.on.critical -> witnesses\"\"\"\n            ions = env.get(\"ions\", env.get(\"input\", []))\n            # Placeholder: return ions as witnesses for now\n            return {\"witnesses\": ions, \"chain\": \"zeros_on_critical\"}",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 536,
      "alignment": 0.5573131940631282,
      "coherence": 0.5573131940631282,
      "comment_phi_k": 7.896264356558475,
      "code_phi_k": 38.391616290598336
    },
    {
      "comment": "Check if glyph is a vowel (zeta_order 1)",
      "code": "        def match_vowel(env: Dict[str, Any]) -> int:\n            \"\"\"Check if glyph is a vowel (zeta_order 1)\"\"\"\n            glyph = str(env.get(\"glyph\", env.get(\"L\", \"\"))).lower()\n            return 1 if glyph in \"aeiou\" else 0",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 543,
      "alignment": 0.5900317798368145,
      "coherence": 0.5900317798368145,
      "comment_phi_k": 8.781367243867244,
      "code_phi_k": 28.774760166304283
    },
    {
      "comment": "Check if glyph is a consonant (zeta_order 2)",
      "code": "        def match_consonant(env: Dict[str, Any]) -> int:\n            \"\"\"Check if glyph is a consonant (zeta_order 2)\"\"\"\n            glyph = str(env.get(\"glyph\", env.get(\"L\", \"\"))).lower()\n            return 2 if glyph.isalpha() and glyph not in \"aeiou\" else 0",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 548,
      "alignment": 0.5785910960221972,
      "coherence": 0.5785910960221972,
      "comment_phi_k": 9.100613275613275,
      "code_phi_k": 33.4995570498473
    },
    {
      "comment": "Check if glyph is a cluster like 'th', 'ch' (zeta_order 2)",
      "code": "        def match_cluster(env: Dict[str, Any]) -> int:\n            \"\"\"Check if glyph is a cluster like 'th', 'ch' (zeta_order 2)\"\"\"\n            glyph = str(env.get(\"glyph\", env.get(\"L\", \"\"))).lower()\n            clusters = [\"th\", \"ch\", \"sh\", \"ph\", \"gh\", \"ck\", \"ng\", \"qu\"]\n            return 2 if glyph in clusters else 0",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 553,
      "alignment": 0.5900361486706125,
      "coherence": 0.5900361486706125,
      "comment_phi_k": 11.061129148629147,
      "code_phi_k": 36.24358737667561
    },
    {
      "comment": "Check if glyph is iconic like 'O'=round, 'S'=flow (zeta_order 3)",
      "code": "        def match_iconic(env: Dict[str, Any]) -> int:\n            \"\"\"Check if glyph is iconic like 'O'=round, 'S'=flow (zeta_order 3)\"\"\"\n            glyph = str(env.get(\"glyph\", env.get(\"L\", \"\"))).lower()\n            iconic = {\"o\": 3, \"s\": 3, \"i\": 3, \"c\": 3}  # Round, flow, line, curve\n            return iconic.get(glyph, 0)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 559,
      "alignment": 0.593275210279426,
      "coherence": 0.593275210279426,
      "comment_phi_k": 11.339303751803751,
      "code_phi_k": 36.0617134907576
    },
    {
      "comment": "Compute gradient \u2207\u03a6\u03ba (simplified: difference)",
      "code": "        def gradient(env: Dict[str, Any]) -> float:\n            \"\"\"Compute gradient \u2207\u03a6\u03ba (simplified: difference)\"\"\"\n            phi_k = float(env.get(\"phi_k\", env.get(\"phi_k_sigma\", env.get(\"phi_k_sentence\", 0.0))))\n            prev_phi_k = float(env.get(\"prev_phi_k\", env.get(\"prev1\", 0.0)))\n            return phi_k - prev_phi_k",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 565,
      "alignment": 0.5646590938740292,
      "coherence": 0.5646590938740292,
      "comment_phi_k": 7.132954545454545,
      "code_phi_k": 31.145562124083124
    },
    {
      "comment": "Compute temporal derivative \u2202A/\u2202t (simplified: difference)",
      "code": "        def temporal_derivative(env: Dict[str, Any]) -> float:\n            \"\"\"Compute temporal derivative \u2202A/\u2202t (simplified: difference)\"\"\"\n            A = float(env.get(\"A\", env.get(\"A_l\", env.get(\"A_sentence\", 0.0))))\n            prev_A = float(env.get(\"prev_A\", 0.0))\n            return A - prev_A",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 571,
      "alignment": 0.5901857955173753,
      "coherence": 0.5901857955173753,
      "comment_phi_k": 9.42303391053391,
      "code_phi_k": 30.832686748348348
    },
    {
      "comment": "Compute Laplacian \u2207\u00b2\u03a6\u03ba (simplified: second difference)",
      "code": "        def laplacian(env: Dict[str, Any]) -> float:\n            \"\"\"Compute Laplacian \u2207\u00b2\u03a6\u03ba (simplified: second difference)\"\"\"\n            phi_k = float(env.get(\"phi_k\", env.get(\"phi_k_sigma\", 0.0)))\n            prev1 = float(env.get(\"prev1\", 0.0))\n            prev2 = float(env.get(\"prev2\", 0.0))\n            if prev2 == 0:\n                return abs(phi_k - prev1)\n            return abs(phi_k - 2 * prev1 + prev2)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 577,
      "alignment": 0.5616229655105145,
      "coherence": 0.5616229655105145,
      "comment_phi_k": 8.797438672438672,
      "code_phi_k": 40.08930400524829
    },
    {
      "comment": "Compute divergence \u2207\u00b7A (simplified: sum of components)",
      "code": "        def divergence(env: Dict[str, Any]) -> float:\n            \"\"\"Compute divergence \u2207\u00b7A (simplified: sum of components)\"\"\"\n            A = env.get(\"A\", env.get(\"A_sentence\", 0.0))\n            if isinstance(A, (list, tuple)):\n                return sum(float(x) for x in A)\n            return float(A)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 586,
      "alignment": 0.5734945159232944,
      "coherence": 0.5734945159232944,
      "comment_phi_k": 9.668272005772005,
      "code_phi_k": 37.72186879597871
    },
    {
      "comment": "Check if value is near zero (equilibrium)",
      "code": "        def near_zero(env: Dict[str, Any]) -> bool:\n            \"\"\"Check if value is near zero (equilibrium)\"\"\"\n            val = float(env.get(\"val\", env.get(\"phi_k_sigma\", env.get(\"net\", env.get(\"dphi_k_dt\", 0.0)))))\n            threshold = float(env.get(\"threshold\", 0.001))\n            return abs(val) < threshold",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 593,
      "alignment": 0.583793351284974,
      "coherence": 0.583793351284974,
      "comment_phi_k": 9.993488455988457,
      "code_phi_k": 34.81261954130358
    },
    {
      "comment": "Sum charges from syllables or constituents",
      "code": "        def sum_charges(env: Dict[str, Any]) -> float:\n            \"\"\"Sum charges from syllables or constituents\"\"\"\n            items = env.get(\"syllables\", env.get(\"constituents\", []))\n            if not isinstance(items, (list, tuple)):\n                return 0.0\n            return sum(float(item.get(\"charge\", 0.0)) if isinstance(item, dict) else 0.0 for item in items)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 599,
      "alignment": 0.5514072911335147,
      "coherence": 0.5514072911335147,
      "comment_phi_k": 8.751406926406926,
      "code_phi_k": 46.93487519468909
    },
    {
      "comment": "Classify word type (simplified heuristic)",
      "code": "        def classify_type(env: Dict[str, Any]) -> str:\n            \"\"\"Classify word type (simplified heuristic)\"\"\"\n            word = str(env.get(\"word\", \"\")).lower()\n            # Simple heuristics\n            if word.endswith((\"tion\", \"sion\", \"ness\", \"ment\", \"ity\")):\n                return \"N\"  # Noun\n            if word.endswith((\"ed\", \"ing\", \"ize\", \"ify\")):\n                return \"V\"  # Verb\n            if word.endswith((\"ly\",)):\n                return \"Adv\"  # Adverb\n            if word in ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 606,
      "alignment": 0.5217236715099933,
      "coherence": 0.5217236715099933,
      "comment_phi_k": 7.4145021645021645,
      "code_phi_k": 89.03470322462194
    },
    {
      "comment": "Compute semantic mass from type",
      "code": "        def compute_mass(env: Dict[str, Any]) -> float:\n            \"\"\"Compute semantic mass from type\"\"\"\n            type_name = str(env.get(\"type\", \"\"))\n            # Nouns have higher mass\n            mass_map = {\"N\": 1.0, \"V\": 0.8, \"A\": 0.6, \"Adv\": 0.5, \"P\": 0.4, \"C\": 0.3, \"T\": 0.7}\n            return mass_map.get(type_name, 0.5)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 624,
      "alignment": 0.566559263106313,
      "coherence": 0.566559263106313,
      "comment_phi_k": 7.1898809523809515,
      "code_phi_k": 30.60050144858582
    },
    {
      "comment": "Compute kinetic flow from type",
      "code": "        def compute_flow(env: Dict[str, Any]) -> float:\n            \"\"\"Compute kinetic flow from type\"\"\"\n            type_name = str(env.get(\"type\", \"\"))\n            # Verbs have higher flow\n            flow_map = {\"V\": 1.0, \"T\": 0.9, \"Adv\": 0.7, \"N\": 0.3, \"A\": 0.5, \"P\": 0.6, \"C\": 0.4}\n            return flow_map.get(type_name, 0.5)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 631,
      "alignment": 0.5665219486817402,
      "coherence": 0.5665219486817402,
      "comment_phi_k": 7.05595238095238,
      "code_phi_k": 30.045360755945122
    },
    {
      "comment": "Compute curvature from type",
      "code": "        def compute_curvature(env: Dict[str, Any]) -> float:\n            \"\"\"Compute curvature from type\"\"\"\n            type_name = str(env.get(\"type\", \"\"))\n            # Adjectives modify curvature\n            curvature_map = {\"A\": 1.0, \"Adv\": 0.8, \"V\": 0.6, \"N\": 0.4, \"P\": 0.5, \"C\": 0.3, \"T\": 0.4}\n            return curvature_map.get(type_name, 0.5)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 638,
      "alignment": 0.5548962320436254,
      "coherence": 0.5548962320436254,
      "comment_phi_k": 5.984325396825396,
      "code_phi_k": 30.24505954600382
    },
    {
      "comment": "Sum field potential from words",
      "code": "        def sum_field_potential(env: Dict[str, Any]) -> float:\n            \"\"\"Sum field potential from words\"\"\"\n            words = env.get(\"words\", [])\n            if not isinstance(words, (list, tuple)):\n                return 0.0\n            total = 0.0\n            for word in words:\n                if isinstance(word, dict):\n                    total += float(word.get(\"phi_k\", word.get(\"field_potential\", 0.0)))\n                elif isinstance(word, (int, float)):\n                    total +=",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 645,
      "alignment": 0.5342799998789314,
      "coherence": 0.5342799998789314,
      "comment_phi_k": 7.248412698412698,
      "code_phi_k": 56.4860260984211
    },
    {
      "comment": "Check if Q has positive trend (rising)",
      "code": "        def positive_trend(env: Dict[str, Any]) -> bool:\n            \"\"\"Check if Q has positive trend (rising)\"\"\"\n            Q = float(env.get(\"Q\", env.get(\"Q_sentence\", 0.0)))\n            prev_Q = float(env.get(\"prev_Q\", 0.0))\n            return Q > prev_Q",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 658,
      "alignment": 0.5940669937830224,
      "coherence": 0.5940669937830224,
      "comment_phi_k": 8.476190476190476,
      "code_phi_k": 26.765100022956066
    },
    {
      "comment": "Check if Q has negative trend (falling)",
      "code": "        def negative_trend(env: Dict[str, Any]) -> bool:\n            \"\"\"Check if Q has negative trend (falling)\"\"\"\n            Q = float(env.get(\"Q\", env.get(\"Q_sentence\", 0.0)))\n            prev_Q = float(env.get(\"prev_Q\", 0.0))\n            return Q < prev_Q",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 664,
      "alignment": 0.59447952876291,
      "coherence": 0.59447952876291,
      "comment_phi_k": 8.52202380952381,
      "code_phi_k": 26.8109333562894
    },
    {
      "comment": "Compute potential for gap/punctuation slot",
      "code": "        def compute_potential(env: Dict[str, Any]) -> float:\n            \"\"\"Compute potential for gap/punctuation slot\"\"\"\n            gap = env.get(\"gap\", env.get(\"Gap\", env.get(\"Punct\", \"\")))\n            if isinstance(gap, str):\n                return float(len(gap)) * 0.1\n            return 0.5",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 670,
      "alignment": 0.5729203139903867,
      "coherence": 0.5729203139903867,
      "comment_phi_k": 8.053348040848041,
      "code_phi_k": 31.63677194838186
    },
    {
      "comment": "Emit binding invitation from slot",
      "code": "        def emit_binding_invitation(env: Dict[str, Any]) -> str:\n            \"\"\"Emit binding invitation from slot\"\"\"\n            slot = float(env.get(\"slot\", 0.0))\n            return f\"binding_invitation:{slot}\"",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 677,
      "alignment": 0.6156494067126066,
      "coherence": 0.6156494067126066,
      "comment_phi_k": 8.062301587301587,
      "code_phi_k": 21.45947536633262
    },
    {
      "comment": "Compute zero movement distance",
      "code": "        def compute_movement(env: Dict[str, Any]) -> float:\n            \"\"\"Compute zero movement distance\"\"\"\n            zero1 = env.get(\"zero1\", env.get(\"zeros_original\", []))\n            zero2 = env.get(\"zero2\", env.get(\"zeros_perturbed\", []))\n            if isinstance(zero1, (list, tuple)) and isinstance(zero2, (list, tuple)):\n                if len(zero1) > 0 and len(zero2) > 0:\n                    # Simple distance between first zeros\n                    z1 = float(zero1[0]) if isinstance(z",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 683,
      "alignment": 0.5230498515810978,
      "coherence": 0.5230498515810978,
      "comment_phi_k": 6.723214285714286,
      "code_phi_k": 76.2819713159143
    },
    {
      "comment": "RBC-compress field state (simplified)",
      "code": "        def rbc_compress(env: Dict[str, Any]) -> Dict[str, Any]:\n            \"\"\"RBC-compress field state (simplified)\"\"\"\n            field_state = env.get(\"field_state\", {})\n            # Simple compression: keep only essential fields\n            compressed = {\n                \"phi_k\": field_state.get(\"phi_k\", 0.0),\n                \"zeros\": field_state.get(\"zeros\", []),\n                \"witnesses\": field_state.get(\"witnesses\", [])\n            }\n            return compressed",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 695,
      "alignment": 0.5362695035415952,
      "coherence": 0.5362695035415952,
      "comment_phi_k": 5.880194805194805,
      "code_phi_k": 43.47135804179518
    },
    {
      "comment": "Check if output is deterministic given witness",
      "code": "        def check_determinism(env: Dict[str, Any]) -> bool:\n            \"\"\"Check if output is deterministic given witness\"\"\"\n            output = env.get(\"output\", \"\")\n            witness = env.get(\"witness\", {})\n            # If witness exists, output is deterministic\n            return witness is not None and len(str(witness)) > 0",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 706,
      "alignment": 0.5682317103855351,
      "coherence": 0.5682317103855351,
      "comment_phi_k": 11.180146242646245,
      "code_phi_k": 46.55396725307716
    },
    {
      "comment": "Check if delta is within stability basin",
      "code": "        def check_basin(env: Dict[str, Any]) -> bool:\n            \"\"\"Check if delta is within stability basin\"\"\"\n            delta_I = float(env.get(\"delta_I\", 0.0))\n            delta_A = float(env.get(\"delta_A\", 0.0))\n            threshold = float(env.get(\"threshold\", 0.1))\n            return abs(delta_I) < threshold and abs(delta_A) < threshold",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 713,
      "alignment": 0.5764095426741145,
      "coherence": 0.5764095426741145,
      "comment_phi_k": 10.144246031746034,
      "code_phi_k": 38.26249975654757
    },
    {
      "comment": "Check distance for locality bounds",
      "code": "        def check_distance(env: Dict[str, Any]) -> float:\n            \"\"\"Check distance for locality bounds\"\"\"\n            perturbation = env.get(\"perturbation\", {})\n            region = env.get(\"region\", {})\n            # Simple distance check\n            return float(env.get(\"distance\", 1.0))",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 720,
      "alignment": 0.5709380909159133,
      "coherence": 0.5709380909159133,
      "comment_phi_k": 7.705357142857143,
      "code_phi_k": 31.007896041231625
    },
    {
      "comment": "Compare distance to threshold for bounded influence",
      "code": "        def compare_threshold(env: Dict[str, Any]) -> bool:\n            \"\"\"Compare distance to threshold for bounded influence\"\"\"\n            distance = float(env.get(\"distance\", 1.0))\n            threshold = float(env.get(\"threshold\", 1.0))\n            return distance < threshold",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 727,
      "alignment": 0.6116917619149235,
      "coherence": 0.6116917619149235,
      "comment_phi_k": 11.216666666666665,
      "code_phi_k": 30.714631403934305
    },
    {
      "comment": "Compute field potential \u03a6\u03ba from text or coordinates.\nMaps text \u2192 hierarchical field \u2192 scalar potential.",
      "code": "        def compute_phi_k(env: Dict[str, Any]) -> float:\n            \"\"\"\n            Compute field potential \u03a6\u03ba from text or coordinates.\n            Maps text \u2192 hierarchical field \u2192 scalar potential.\n            \"\"\"\n            import math\n            \n            # If we have text, process it hierarchically\n            text = env.get(\"text\", env.get(\"x\", env.get(\"input\", \"\")))\n            if isinstance(text, str) and text:\n                # Aperture chain: letter \u2192 syllable \u2192 word \u2192 sentence\n ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 737,
      "alignment": 0.5345499185834756,
      "coherence": 0.5345499185834756,
      "comment_phi_k": 21.548069985569985,
      "code_phi_k": 166.69386685510918
    },
    {
      "comment": "Solve for zeros of zeta function: \u03b6_F(s) = 0\nInput: spectrum (field state) + region + tolerance\nOutput: list of zeros on critical line",
      "code": "        def zeta_zero_solver(env: Dict[str, Any]) -> list:\n            \"\"\"\n            Solve for zeros of zeta function: \u03b6_F(s) = 0\n            Input: spectrum (field state) + region + tolerance\n            Output: list of zeros on critical line\n            \"\"\"\n            import math\n            import cmath\n            \n            # Get field spectrum (phi_k values)\n            phi_k = env.get(\"phi_k\", env.get(\"phi_k_doc\", env.get(\"spectrum\", 0.0)))\n            region = env.get(\"region\", {\"mi",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 771,
      "alignment": 0.5118503505622082,
      "coherence": 0.5118503505622082,
      "comment_phi_k": 29.286111111111115,
      "code_phi_k": 632.4752234178927
    },
    {
      "comment": "Hierarchical text processing: letter \u2192 syllable \u2192 word \u2192 sentence \u2192 discourse\nReturns aperture structure with field properties at each level",
      "code": "        def aperture_chain(env: Dict[str, Any]) -> Dict[str, Any]:\n            \"\"\"\n            Hierarchical text processing: letter \u2192 syllable \u2192 word \u2192 sentence \u2192 discourse\n            Returns aperture structure with field properties at each level\n            \"\"\"\n            text = str(env.get(\"text\", env.get(\"input\", \"\")))\n            if not text:\n                return {\"aperture\": {}, \"levels\": []}\n            \n            # Level 1: Letters\n            letters = []\n            for char in te",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 901,
      "alignment": 0.533462871400494,
      "coherence": 0.533462871400494,
      "comment_phi_k": 28.08436147186147,
      "code_phi_k": 223.8595118290934
    },
    {
      "comment": "Compare zeros before and after perturbation.\nReturns zero movements indicating semantic changes.",
      "code": "        def compare_zeros(env: Dict[str, Any]) -> Dict[str, Any]:\n            \"\"\"\n            Compare zeros before and after perturbation.\n            Returns zero movements indicating semantic changes.\n            \"\"\"\n            zeros_original = env.get(\"zeros_original\", env.get(\"zeros\", []))\n            zeros_perturbed = env.get(\"zeros_perturbed\", env.get(\"zeros_new\", []))\n            \n            if not isinstance(zeros_original, list):\n                zeros_original = []\n            if not ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 966,
      "alignment": 0.5289706130160844,
      "coherence": 0.5289706130160844,
      "comment_phi_k": 20.708766233766234,
      "code_phi_k": 189.0593195836119
    },
    {
      "comment": "Enhanced zero movement interpretation with semantic mapping.\nMaps zero movements to meaningful answers based on:\n- Movement magnitude and direction\n- Zero positions on critical line\n- Context from question/document",
      "code": "        def interpret_movement(env: Dict[str, Any]) -> str:\n            \"\"\"\n            Enhanced zero movement interpretation with semantic mapping.\n            Maps zero movements to meaningful answers based on:\n            - Movement magnitude and direction\n            - Zero positions on critical line\n            - Context from question/document\n            \"\"\"\n            movements = env.get(\"movements\", env.get(\"zero_movements\", {}))\n            question = env.get(\"question\", \"\")\n          ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1013,
      "alignment": 0.5233868865251834,
      "coherence": 0.5233868865251834,
      "comment_phi_k": 44.738173142217256,
      "code_phi_k": 500.6090298620052
    },
    {
      "comment": "Perturb field with question and return perturbed phi_k",
      "code": "        def query_perturb_field(env: Dict[str, Any], executor) -> Dict[str, Any]:\n            \"\"\"Perturb field with question and return perturbed phi_k\"\"\"\n            question = env.get(\"question\", \"\")\n            document_field = env.get(\"document_field\", {})\n            \n            # Get original phi_k\n            phi_k_doc = document_field.get(\"phi_k\", 0.0)\n            if isinstance(phi_k_doc, dict):\n                phi_k_doc = phi_k_doc.get(\"discourse\", {}).get(\"phi_k\", 0.0)\n            \n  ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1085,
      "alignment": 0.536156776451678,
      "coherence": 0.536156776451678,
      "comment_phi_k": 12.453769841269843,
      "code_phi_k": 92.33639925962596
    },
    {
      "comment": "Compute zero movements from perturbed field",
      "code": "        def zeros_movement(env: Dict[str, Any], executor) -> Dict[str, Any]:\n            \"\"\"Compute zero movements from perturbed field\"\"\"\n            phi_k_perturbed = env.get(\"phi_k_perturbed\", 0.0)\n            phi_k_original = env.get(\"phi_k_original\", 0.0)\n            \n            # Get original zeros from document field\n            document_field = env.get(\"document_field\", {})\n            zeros_original = document_field.get(\"zeros\", [])\n            \n            # Compute zeros for perturbe",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1104,
      "alignment": 0.5309327733408639,
      "coherence": 0.5309327733408639,
      "comment_phi_k": 9.600992063492063,
      "code_phi_k": 82.39612541238617
    },
    {
      "comment": "Extract provenance from witness chain",
      "code": "        def extract_provenance(env: Dict[str, Any]) -> Dict[str, Any]:\n            \"\"\"Extract provenance from witness chain\"\"\"\n            witness_chain = env.get(\"witness_chain\", env.get(\"input\", {}))\n            if isinstance(witness_chain, dict):\n                return {\n                    \"W0\": witness_chain.get(\"W0\", {}),\n                    \"W1\": witness_chain.get(\"W1\", {}),\n                    \"W2\": witness_chain.get(\"W2\", {}),\n                    \"provenance\": \"W0\u2192W1\u2192W2\"\n               ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1127,
      "alignment": 0.5525114593475305,
      "coherence": 0.5525114593475305,
      "comment_phi_k": 8.037103174603175,
      "code_phi_k": 42.28211955163935
    },
    {
      "comment": "Extract transformation history from witness chain",
      "code": "        def extract_history(env: Dict[str, Any]) -> list:\n            \"\"\"Extract transformation history from witness chain\"\"\"\n            witness_chain = env.get(\"witness_chain\", env.get(\"input\", {}))\n            if isinstance(witness_chain, dict):\n                return [\n                    {\"step\": \"W0\", \"type\": \"identity\", \"data\": witness_chain.get(\"W0\", {})},\n                    {\"step\": \"W1\", \"type\": \"structure\", \"data\": witness_chain.get(\"W1\", {})},\n                    {\"step\": \"W2\", \"typ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1139,
      "alignment": 0.556445900702881,
      "coherence": 0.556445900702881,
      "comment_phi_k": 9.824956987456988,
      "code_phi_k": 48.427405464127254
    },
    {
      "comment": "W0: identity \u2192 local identity (Points of being)",
      "code": "        def witness_W0(env: Dict[str, Any]) -> Dict[str, Any]:\n            \"\"\"W0: identity \u2192 local identity (Points of being)\"\"\"\n            input_data = env.get(\"input\", env.get(\"uniform_potential\", {}))\n            return {\"W0\": {\"type\": \"identity\", \"data\": input_data}}",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1150,
      "alignment": 0.5941177592409151,
      "coherence": 0.5941177592409151,
      "comment_phi_k": 10.130952380952381,
      "code_phi_k": 31.975786377047825
    },
    {
      "comment": "W1: locality \u2192 structure & boundary (Membranes, molecules)",
      "code": "        def witness_W1(env: Dict[str, Any]) -> Dict[str, Any]:\n            \"\"\"W1: locality \u2192 structure & boundary (Membranes, molecules)\"\"\"\n            input_data = env.get(\"input\", env.get(\"locality\", {}))\n            return {\"W1\": {\"type\": \"structure\", \"data\": input_data}}",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1155,
      "alignment": 0.5872216583466965,
      "coherence": 0.5872216583466965,
      "comment_phi_k": 9.036111111111111,
      "code_phi_k": 30.417904521948643
    },
    {
      "comment": "W2: structure \u2192 time & motion (Dynamics, causality)",
      "code": "        def witness_W2(env: Dict[str, Any]) -> Dict[str, Any]:\n            \"\"\"W2: structure \u2192 time & motion (Dynamics, causality)\"\"\"\n            input_data = env.get(\"input\", env.get(\"structure\", {}))\n            return {\"W2\": {\"type\": \"time\", \"data\": input_data}}",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1160,
      "alignment": 0.5827007908463586,
      "coherence": 0.5827007908463586,
      "comment_phi_k": 8.371626984126983,
      "code_phi_k": 29.492787278081394
    },
    {
      "comment": "Build witness chain: W0 \u2192 W1 \u2192 W2",
      "code": "        def witness_chain_build(env: Dict[str, Any]) -> Dict[str, Any]:\n            \"\"\"Build witness chain: W0 \u2192 W1 \u2192 W2\"\"\"\n            input_data = env.get(\"input\", {})\n            w0 = witness_W0({\"input\": input_data})\n            w1 = witness_W1({\"input\": w0.get(\"W0\", {})})\n            w2 = witness_W2({\"input\": w1.get(\"W1\", {})})\n            return {\n                \"W0\": w0.get(\"W0\", {}),\n                \"W1\": w1.get(\"W1\", {}),\n                \"W2\": w2.get(\"W2\", {}),\n                \"chain\":",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1165,
      "alignment": 0.5457831071386611,
      "coherence": 0.5457831071386611,
      "comment_phi_k": 6.1380952380952385,
      "code_phi_k": 36.58629678425328
    },
    {
      "comment": "Extract ions from intent/text.\nIons are minimal quanta: +1 (noun/emit) or -1 (verb/absorb)",
      "code": "        def extract_ions(env: Dict[str, Any]) -> list:\n            \"\"\"\n            Extract ions from intent/text.\n            Ions are minimal quanta: +1 (noun/emit) or -1 (verb/absorb)\n            \"\"\"\n            intent = env.get(\"intent\", env.get(\"text\", env.get(\"input\", \"\")))\n            if not isinstance(intent, str):\n                return []\n            \n            words = intent.split()\n            ions = []\n            \n            for word in words:\n                word_lower = word.lo",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1182,
      "alignment": 0.5281996502594658,
      "coherence": 0.5281996502594658,
      "comment_phi_k": 17.676424963924966,
      "code_phi_k": 165.54605106580723
    },
    {
      "comment": "Composer planning: ions \u2192 chain with zeros.on.critical \u2192 witnesses \u2192 plan\nFinds optimal coherence path through field state guided by critical zeros.",
      "code": "        def composer_plan(env: Dict[str, Any]) -> Dict[str, Any]:\n            \"\"\"\n            Composer planning: ions \u2192 chain with zeros.on.critical \u2192 witnesses \u2192 plan\n            Finds optimal coherence path through field state guided by critical zeros.\n            \"\"\"\n            ions = env.get(\"ions\", [])\n            if not ions:\n                # Extract ions from intent if not provided\n                ions = extract_ions(env)\n            \n            if not ions:\n                return {\"pl",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1235,
      "alignment": 0.5235192113378863,
      "coherence": 0.5235192113378863,
      "comment_phi_k": 29.8871373724315,
      "code_phi_k": 332.63212702115544
    },
    {
      "comment": "Maximize coherence of a plan.\nOptimizes ion ordering and selection for maximum field coherence.",
      "code": "        def coherence_maximization(env: Dict[str, Any]) -> Dict[str, Any]:\n            \"\"\"\n            Maximize coherence of a plan.\n            Optimizes ion ordering and selection for maximum field coherence.\n            \"\"\"\n            plan = env.get(\"plan\", [])\n            if not isinstance(plan, list):\n                return {\"optimal_plan\": plan, \"coherence\": 0.0}\n            \n            if not plan:\n                return {\"optimal_plan\": [], \"coherence\": 0.0}\n            \n            # ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1312,
      "alignment": 0.5375869939073443,
      "coherence": 0.5375869939073443,
      "comment_phi_k": 22.933928571428574,
      "code_phi_k": 164.00595575150555
    },
    {
      "comment": "Execute ion chain: convert plan into output text.\nChains ions together following the plan order.",
      "code": "        def execute_ion_chain(env: Dict[str, Any]) -> str:\n            \"\"\"\n            Execute ion chain: convert plan into output text.\n            Chains ions together following the plan order.\n            \"\"\"\n            plan = env.get(\"plan\", env.get(\"optimal_plan\", []))\n            if not isinstance(plan, list):\n                # Try to extract plan from dict structure\n                if isinstance(plan, dict):\n                    plan = plan.get(\"plan\", plan.get(\"optimal_plan\", []))\n      ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1350,
      "alignment": 0.5380703383251919,
      "coherence": 0.5380703383251919,
      "comment_phi_k": 24.130555555555556,
      "code_phi_k": 170.52562129663127
    },
    {
      "comment": "Check coherence of output against field state.\nReturns coherent output if coherence threshold met.",
      "code": "        def check_coherence(env: Dict[str, Any]) -> Dict[str, Any]:\n            \"\"\"\n            Check coherence of output against field state.\n            Returns coherent output if coherence threshold met.\n            \"\"\"\n            output = env.get(\"output\", \"\")\n            field_state = env.get(\"field_state\", {})\n            \n            # Compute output field potential\n            output_phi_k = compute_phi_k({\"text\": output})\n            \n            # Get field state phi_k\n            fie",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1392,
      "alignment": 0.5481411851861494,
      "coherence": 0.5481411851861494,
      "comment_phi_k": 23.136111111111113,
      "code_phi_k": 131.71523837651117
    },
    {
      "comment": "Generate coherent output: intent \u2192 composer plan \u2192 ion chain \u2192 field coherence \u2192 output\nFull generation pipeline.",
      "code": "        def generate_coherent(env: Dict[str, Any]) -> Dict[str, Any]:\n            \"\"\"\n            Generate coherent output: intent \u2192 composer plan \u2192 ion chain \u2192 field coherence \u2192 output\n            Full generation pipeline.\n            \"\"\"\n            intent = env.get(\"intent\", env.get(\"input\", \"\"))\n            \n            # Step 1: Extract ions from intent\n            ions = extract_ions({\"intent\": intent})\n            \n            if not ions:\n                return {\n                    \"out",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1422,
      "alignment": 0.5171010963367717,
      "coherence": 0.5171010963367717,
      "comment_phi_k": 24.484722222222224,
      "code_phi_k": 370.1831875359922
    },
    {
      "comment": "Zeta function constructed from spectrum",
      "code": "            def zeta_F(s: complex) -> complex:\n                \"\"\"Zeta function constructed from spectrum\"\"\"\n                result = 0.0 + 0.0j\n                for n, a_n in enumerate(spectrum, start=1):\n                    if n > len(spectrum):\n                        break\n                    # Use proper complex exponentiation: n^{-s} = exp(-s * log(n))\n                    result += a_n * cmath.exp(-s * cmath.log(n))\n                return result",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 796,
      "alignment": 0.5451260761319167,
      "coherence": 0.5451260761319167,
      "comment_phi_k": 7.8670815295815295,
      "code_phi_k": 47.51744060677884
    },
    {
      "comment": "Derivative of zeta function for Newton-Raphson",
      "code": "            def zeta_F_derivative(s: complex) -> complex:\n                \"\"\"Derivative of zeta function for Newton-Raphson\"\"\"\n                result = 0.0 + 0.0j\n                for n, a_n in enumerate(spectrum, start=1):\n                    if n > len(spectrum):\n                        break\n                    log_n = cmath.log(n)\n                    result -= a_n * log_n * cmath.exp(-s * log_n)\n                return result",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 806,
      "alignment": 0.5632296091398846,
      "coherence": 0.5632296091398846,
      "comment_phi_k": 9.630710955710956,
      "code_phi_k": 42.89368257301694
    },
    {
      "comment": "Newton-Raphson root finding on critical line",
      "code": "            def newton_raphson(s0: complex, max_iter: int = 15) -> complex:\n                \"\"\"Newton-Raphson root finding on critical line\"\"\"\n                s = s0\n                for _ in range(max_iter):\n                    zeta_val = zeta_F(s)\n                    if abs(zeta_val) < tolerance:\n                        return s\n                    zeta_deriv = zeta_F_derivative(s)\n                    if abs(zeta_deriv) < 1e-12:  # Avoid division by zero\n                        break\n          ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 816,
      "alignment": 0.5333075713940385,
      "coherence": 0.5333075713940385,
      "comment_phi_k": 9.466822066822067,
      "code_phi_k": 75.78949280853307
    },
    {
      "comment": "!/usr/bin/env python3",
      "code": "#!/usr/bin/env python3\n\"\"\"\nopic Voice Executor - Execute opic voices from Python",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1,
      "alignment": 0.5393097636886867,
      "coherence": 0.5393097636886867,
      "comment_phi_k": 2.306354756354756,
      "code_phi_k": 15.821001221001222
    },
    {
      "comment": "Import opic's parser",
      "code": "import hashlib\nimport math\n\n# Import opic's parser\nproject_root = Path(__file__).parent.parent\nsys.path.insert(0, str(project_root))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 14,
      "alignment": 0.5793540008540988,
      "coherence": 0.5793540008540988,
      "comment_phi_k": 5.216666666666667,
      "code_phi_k": 19.04312745372713
    },
    {
      "comment": "# Try alternative import",
      "code": "try:\n    from generate import parse_ops\nexcept ImportError:\n    # Try alternative import\n    import importlib.util\n    generate_path = Path(__file__).parent / \"generate.py\"",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 21,
      "alignment": 0.5533672568048423,
      "coherence": 0.5533672568048423,
      "comment_phi_k": 5.074044011544011,
      "code_phi_k": 26.30648438463841
    },
    {
      "comment": "Cache for semantic embeddings",
      "code": "self.embedding_cache = {}",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 42,
      "alignment": 0.5968808655322068,
      "coherence": 0.5968808655322068,
      "comment_phi_k": 6.624603174603174,
      "code_phi_k": 2.1505038154999454
    },
    {
      "comment": "# Load bootstrap",
      "code": "    \n    def _load_opic_systems(self):\n        \"\"\"Load opic's core systems including Field Spec 0.7\"\"\"\n        # Load bootstrap\n        bootstrap_path = self.project_root / \"core\" / \"bootstrap.ops\"\n        if bootstrap_path.exists():",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 48,
      "alignment": 0.5340640261242419,
      "coherence": 0.5340640261242419,
      "comment_phi_k": 3.351984126984127,
      "code_phi_k": 26.276608229344127
    },
    {
      "comment": "# Load core files (includes Field Spec 0.7 by default)",
      "code": "        if bootstrap_path.exists():\n            self._load_ops_file(bootstrap_path)\n        \n        # Load core files (includes Field Spec 0.7 by default)\n        core_files = [\"opic_field.ops\", \"planning.ops\", \"reasoning.ops\", \"ml.ops\"]\n        for core_file in core_files:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 53,
      "alignment": 0.6136262980583306,
      "coherence": 0.6136262980583306,
      "comment_phi_k": 10.990079365079364,
      "code_phi_k": 29.67535610769851
    },
    {
      "comment": "# Load SPEC seed system (Zeta Stack)",
      "code": "            if core_path.exists():\n                self._load_ops_file(core_path)\n        \n        # Load SPEC seed system (Zeta Stack)\n        spec_seed_path = self.project_root / \"systems\" / \"spec_seed.ops\"\n        if spec_seed_path.exists():",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 60,
      "alignment": 0.6025156558718171,
      "coherence": 0.6025156558718171,
      "comment_phi_k": 7.666666666666666,
      "code_phi_k": 22.529664643579416
    },
    {
      "comment": "# Load benchmark system",
      "code": "        if spec_seed_path.exists():\n            self._load_ops_file(spec_seed_path)\n        \n        # Load benchmark system\n        benchmark_path = self.project_root / \"systems\" / \"benchmark.ops\"\n        if benchmark_path.exists():",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 65,
      "alignment": 0.564645876559472,
      "coherence": 0.564645876559472,
      "comment_phi_k": 4.5192460317460315,
      "code_phi_k": 19.736553766392294
    },
    {
      "comment": "# Load math system",
      "code": "        if benchmark_path.exists():\n            self._load_ops_file(benchmark_path)\n        \n        # Load math system\n        math_path = self.project_root / \"systems\" / \"math.ops\"\n        if math_path.exists():",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 70,
      "alignment": 0.5614514254414679,
      "coherence": 0.5614514254414679,
      "comment_phi_k": 4.074999999999999,
      "code_phi_k": 18.615634562075424
    },
    {
      "comment": "# Load includes recursively",
      "code": "        self.defs.update(defs)\n        self.voices.update(voices)\n        \n        # Load includes recursively\n        for include_file in includes:\n            # Resolve include path relative to file's directory",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 90,
      "alignment": 0.5547111259659145,
      "coherence": 0.5547111259659145,
      "comment_phi_k": 5.500613275613276,
      "code_phi_k": 27.88510864791421
    },
    {
      "comment": "# Resolve include path relative to file's directory",
      "code": "        \n        # Load includes recursively\n        for include_file in includes:\n            # Resolve include path relative to file's directory\n            include_path = file_path.parent / include_file\n            if include_path.exists():",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 92,
      "alignment": 0.6001712919500675,
      "coherence": 0.6001712919500675,
      "comment_phi_k": 11.243055555555555,
      "code_phi_k": 33.68110287330489
    },
    {
      "comment": "# SPEC voices execute through their declarative chains",
      "code": "        \"\"\"\n        inputs = inputs or {}\n        \n        # SPEC voices execute through their declarative chains\n        # No fast-path - let opic execute them natively\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 104,
      "alignment": 0.6352816172720599,
      "coherence": 0.6352816172720599,
      "comment_phi_k": 11.588329725829723,
      "code_phi_k": 27.20936147186147
    },
    {
      "comment": "# No fast-path - let opic execute them natively",
      "code": "        inputs = inputs or {}\n        \n        # SPEC voices execute through their declarative chains\n        # No fast-path - let opic execute them natively\n        \n        if voice_name not in self.voices:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 105,
      "alignment": 0.5907564360761443,
      "coherence": 0.5907564360761443,
      "comment_phi_k": 10.671031746031746,
      "code_phi_k": 34.73021284271284
    },
    {
      "comment": "# Try to find similar voice",
      "code": "        # No fast-path - let opic execute them natively\n        \n        if voice_name not in self.voices:\n            # Try to find similar voice\n            similar = [v for v in self.voices.keys() if voice_name.split('.')[-1] in v]\n            if similar:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 108,
      "alignment": 0.5451405165051052,
      "coherence": 0.5451405165051052,
      "comment_phi_k": 6.621428571428571,
      "code_phi_k": 39.98191946941948
    },
    {
      "comment": "# If voice is a simple string, return it",
      "code": "        \n        voice_body = self.voices[voice_name]\n        \n        # If voice is a simple string, return it\n        if isinstance(voice_body, str) and not voice_body.startswith(\"{\"):\n            return voice_body",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 117,
      "alignment": 0.6187224785886566,
      "coherence": 0.6187224785886566,
      "comment_phi_k": 10.916666666666666,
      "code_phi_k": 28.446117105288938
    },
    {
      "comment": "# If voice is a chain, execute it using opic's chain execution",
      "code": "        if isinstance(voice_body, str) and not voice_body.startswith(\"{\"):\n            return voice_body\n        \n        # If voice is a chain, execute it using opic's chain execution\n        if isinstance(voice_body, str) and voice_body.startswith(\"{\") and voice_body.endswith(\"}\"):\n            return self._execute_opic_chain(voice_body, inputs)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 121,
      "alignment": 0.6078698725359967,
      "coherence": 0.6078698725359967,
      "comment_phi_k": 17.324603174603176,
      "code_phi_k": 48.81392772559581
    },
    {
      "comment": "# Context-based discovery patterns",
      "code": "        \"\"\"\n        discovered = []\n        \n        # Context-based discovery patterns\n        context_lower = context.lower()\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 225,
      "alignment": 0.6596066982615936,
      "coherence": 0.6596066982615936,
      "comment_phi_k": 5.514074814074814,
      "code_phi_k": 11.394010156510156
    },
    {
      "comment": "# Discover thermo.* voices for learning/energy contexts",
      "code": "        # Context-based discovery patterns\n        context_lower = context.lower()\n        \n        # Discover thermo.* voices for learning/energy contexts\n        if any(keyword in context_lower for keyword in ['learn', 'energy', 'density', 'critical', 'phase', 'resonance', 'cycle']):\n            thermo_voices = [v for v in self.voices.keys() if v.startswith('thermo.')]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 228,
      "alignment": 0.5593567710961999,
      "coherence": 0.5593567710961999,
      "comment_phi_k": 10.067844655344654,
      "code_phi_k": 47.43786575911189
    },
    {
      "comment": "# Discover field.* voices for energy/curvature contexts",
      "code": "            thermo_voices = [v for v in self.voices.keys() if v.startswith('thermo.')]\n            discovered.extend(thermo_voices)\n        \n        # Discover field.* voices for energy/curvature contexts\n        if any(keyword in context_lower for keyword in ['energy', 'curvature', 'potential', 'field', 'wave', 'flow', 'xi']):\n            field_voices = [v for v in self.voices.keys() if v.startswith('field.')]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 233,
      "alignment": 0.5573892565891272,
      "coherence": 0.5573892565891272,
      "comment_phi_k": 10.40574148074148,
      "code_phi_k": 50.53252867286659
    },
    {
      "comment": "# Discover cycle.* voices for cycle/promotion contexts",
      "code": "            field_voices = [v for v in self.voices.keys() if v.startswith('field.')]\n            discovered.extend(field_voices)\n        \n        # Discover cycle.* voices for cycle/promotion contexts\n        if any(keyword in context_lower for keyword in ['cycle', 'promote', 'dimension', 'operator', 'resonance']):\n            cycle_voices = [v for v in self.voices.keys() if v.startswith('cycle.')]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 238,
      "alignment": 0.5543146496058924,
      "coherence": 0.5543146496058924,
      "comment_phi_k": 9.490252802752803,
      "code_phi_k": 48.42695474609637
    },
    {
      "comment": "# Discover pascal.* voices for combinatorial contexts",
      "code": "            cycle_voices = [v for v in self.voices.keys() if v.startswith('cycle.')]\n            discovered.extend(cycle_voices)\n        \n        # Discover pascal.* voices for combinatorial contexts\n        if any(keyword in context_lower for keyword in ['combinatorial', 'mod', 'projection', 'pascal']):\n            pascal_voices = [v for v in self.voices.keys() if v.startswith('pascal.')]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 243,
      "alignment": 0.5596578797591278,
      "coherence": 0.5596578797591278,
      "comment_phi_k": 10.126791264291263,
      "code_phi_k": 47.500334831035886
    },
    {
      "comment": "# Discover trig.* voices for symmetry/curvature contexts",
      "code": "            pascal_voices = [v for v in self.voices.keys() if v.startswith('pascal.')]\n            discovered.extend(pascal_voices)\n        \n        # Discover trig.* voices for symmetry/curvature contexts\n        if any(keyword in context_lower for keyword in ['symmetry', 'curvature', 'theta', 'tan', 'sin', 'cos']):\n            trig_voices = [v for v in self.voices.keys() if v.startswith('trig.')]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 248,
      "alignment": 0.5554542490288424,
      "coherence": 0.5554542490288424,
      "comment_phi_k": 9.53814747344159,
      "code_phi_k": 47.76914875568233
    },
    {
      "comment": "# Discover flow.* voices for flow/equilibrium contexts",
      "code": "            trig_voices = [v for v in self.voices.keys() if v.startswith('trig.')]\n            discovered.extend(trig_voices)\n        \n        # Discover flow.* voices for flow/equilibrium contexts\n        if any(keyword in context_lower for keyword in ['flow', 'equilibrium', 'hermitian', 'forward', 'backward']):\n            flow_voices = [v for v in self.voices.keys() if v.startswith('flow.')]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 253,
      "alignment": 0.5557879124270406,
      "coherence": 0.5557879124270406,
      "comment_phi_k": 9.6788745976246,
      "code_phi_k": 48.21296651216395
    },
    {
      "comment": "# Discover nlp.* voices for language/attention contexts",
      "code": "            flow_voices = [v for v in self.voices.keys() if v.startswith('flow.')]\n            discovered.extend(flow_voices)\n        \n        # Discover nlp.* voices for language/attention contexts\n        if any(keyword in context_lower for keyword in ['language', 'attention', 'masked', 'token', 'semantic']):\n            nlp_voices = [v for v in self.voices.keys() if v.startswith('nlp.')]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 258,
      "alignment": 0.556155022666101,
      "coherence": 0.556155022666101,
      "comment_phi_k": 9.65124083432907,
      "code_phi_k": 47.79257322081479
    },
    {
      "comment": "# Discover dimension.* voices for dimensional contexts",
      "code": "            nlp_voices = [v for v in self.voices.keys() if v.startswith('nlp.')]\n            discovered.extend(nlp_voices)\n        \n        # Discover dimension.* voices for dimensional contexts\n        if any(keyword in context_lower for keyword in ['dimension', 'symmetry', 'witness', 'expand']):\n            dimension_voices = [v for v in self.voices.keys() if v.startswith('dimension.')]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 263,
      "alignment": 0.5609968163167922,
      "coherence": 0.5609968163167922,
      "comment_phi_k": 10.389898989898992,
      "code_phi_k": 47.77872524456469
    },
    {
      "comment": "# Discover zeta grammar voices for language/grammar contexts",
      "code": "            dimension_voices = [v for v in self.voices.keys() if v.startswith('dimension.')]\n            discovered.extend(dimension_voices)\n        \n        # Discover zeta grammar voices for language/grammar contexts\n        if any(keyword in context_lower for keyword in ['letter', 'syllable', 'word', 'sentence', 'grammar', 'phonetic', 'morphology', 'syntax']):\n            zeta_grammar_voices = [v for v in self.voices.keys() if any(v.startswith(prefix) for prefix in ['letter.', 'syllable.', 'w",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 268,
      "alignment": 0.5457490282196991,
      "coherence": 0.5457490282196991,
      "comment_phi_k": 11.56635656010656,
      "code_phi_k": 68.98865504210501
    },
    {
      "comment": "# Remove duplicates and return",
      "code": "            zeta_grammar_voices = [v for v in self.voices.keys() if any(v.startswith(prefix) for prefix in ['letter.', 'syllable.', 'word.', 'sentence.', 'grammar.', 'phrase.', 'discourse.', 'orbital.', 'zeta.', 'galois.'])]\n            discovered.extend(zeta_grammar_voices)\n        \n        # Remove duplicates and return\n        return list(set(discovered))\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 273,
      "alignment": 0.5473388255500731,
      "coherence": 0.5473388255500731,
      "comment_phi_k": 6.641468253968254,
      "code_phi_k": 38.39484177960842
    },
    {
      "comment": "# For now, return result as-is",
      "code": "        Enhance result using discovered voices when appropriate\n        Implements automatic composition of discovered voices\n        \"\"\"\n        # For now, return result as-is\n        # Future: intelligently compose discovered voices to enhance result\n        # This could use field operations, thermo operations, etc. based on context",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 281,
      "alignment": 0.5299033620563979,
      "coherence": 0.5299033620563979,
      "comment_phi_k": 7.133333333333333,
      "code_phi_k": 63.203216228216235
    },
    {
      "comment": "# Future: intelligently compose discovered voices to enhance result",
      "code": "        Implements automatic composition of discovered voices\n        \"\"\"\n        # For now, return result as-is\n        # Future: intelligently compose discovered voices to enhance result\n        # This could use field operations, thermo operations, etc. based on context\n        return result",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 282,
      "alignment": 0.5748451014548064,
      "coherence": 0.5748451014548064,
      "comment_phi_k": 14.019233544233545,
      "code_phi_k": 53.837108724608726
    },
    {
      "comment": "# This could use field operations, thermo operations, etc. based on context",
      "code": "        \"\"\"\n        # For now, return result as-is\n        # Future: intelligently compose discovered voices to enhance result\n        # This could use field operations, thermo operations, etc. based on context\n        return result\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 283,
      "alignment": 0.6346113130502441,
      "coherence": 0.6346113130502441,
      "comment_phi_k": 17.94325396825397,
      "code_phi_k": 42.29582084582085
    },
    {
      "comment": "# Target match (exact/semantic)",
      "code": "        \"\"\"\n        score = 0.0\n        \n        # Target match (exact/semantic)\n        target = env.get(\"target\") or env.get(\"answer\") or env.get(\"expected\") or None\n        if target is not None:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 311,
      "alignment": 0.5487062652710971,
      "coherence": 0.5487062652710971,
      "comment_phi_k": 4.566076978576978,
      "code_phi_k": 25.719843555137675
    },
    {
      "comment": "# Choices: reward if value equals/contained in one of the choices",
      "code": "            else:\n                score = max(score, self._string_similarity(value, target))\n        \n        # Choices: reward if value equals/contained in one of the choices\n        choices = env.get(\"choices\") or []\n        if isinstance(choices, (list, tuple)) and choices:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 319,
      "alignment": 0.6271229649367449,
      "coherence": 0.6271229649367449,
      "comment_phi_k": 15.555810162060162,
      "code_phi_k": 38.36995855028439
    },
    {
      "comment": "# Energy/consistency with previous result",
      "code": "                best = max(best, sim)\n            score = max(score, best)\n        \n        # Energy/consistency with previous result\n        if last_value is not None:\n            q_prev = self._get_last_charge(last_value)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 331,
      "alignment": 0.5807880697814212,
      "coherence": 0.5807880697814212,
      "comment_phi_k": 7.145371499415617,
      "code_phi_k": 25.68415443174221
    },
    {
      "comment": "# Map magnitude of energy to [0,1]",
      "code": "            q_new = self._get_last_charge(value)\n            dist = self._string_distance(str(last_value), str(value))\n            e = self._compute_energy_coupling(q_prev, q_new, str(last_value), str(value), dist, 1, 0.0)\n            # Map magnitude of energy to [0,1]\n            mag = abs(float(e))\n            energy_score = mag / (1.0 + mag)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 337,
      "alignment": 0.5635571756659277,
      "coherence": 0.5635571756659277,
      "comment_phi_k": 7.199801587301587,
      "code_phi_k": 31.920076729195575
    },
    {
      "comment": "# Blend with base score",
      "code": "            # Map magnitude of energy to [0,1]\n            mag = abs(float(e))\n            energy_score = mag / (1.0 + mag)\n            # Blend with base score\n            score = max(score, min(1.0, 0.5 * score + 0.5 * energy_score))\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 340,
      "alignment": 0.5530750351348891,
      "coherence": 0.5530750351348891,
      "comment_phi_k": 5.425,
      "code_phi_k": 28.26594516594517
    },
    {
      "comment": "deletion",
      "code": "dp[i - 1][j] + 1,",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 371,
      "alignment": 0.7120736086175942,
      "coherence": 0.7120736086175942,
      "comment_phi_k": 1.8886904761904764,
      "code_phi_k": 1.125
    },
    {
      "comment": "insertion",
      "code": "dp[i][j - 1] + 1,",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 372,
      "alignment": 0.6635570632420644,
      "coherence": 0.6635570632420644,
      "comment_phi_k": 2.1734126984126982,
      "code_phi_k": 1.0714285714285714
    },
    {
      "comment": "substitution",
      "code": "dp[i - 1][j - 1] + cost",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 373,
      "alignment": 0.8660521518790966,
      "coherence": 0.8660521518790966,
      "comment_phi_k": 2.042893217893218,
      "code_phi_k": 2.416666666666667
    },
    {
      "comment": "# Skip hidden and build dirs",
      "code": "            root = Path(str(env.get(\"path\", \".\")))\n            files = []\n            for dirpath, dirnames, filenames in os.walk(root):\n                # Skip hidden and build dirs\n                if any(part.startswith('.') for part in Path(dirpath).parts):\n                    continue",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 468,
      "alignment": 0.5601525869512967,
      "coherence": 0.5601525869512967,
      "comment_phi_k": 7.050000000000001,
      "code_phi_k": 32.825485470841514
    },
    {
      "comment": "# Compute zeta features",
      "code": "                if not line.strip():\n                    continue\n                \n                # Compute zeta features\n                phi_e = shannon_entropy({\"line\": line})\n                phi_c = ordinal_curvature({\"line\": line})",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 513,
      "alignment": 0.5681865991392195,
      "coherence": 0.5681865991392195,
      "comment_phi_k": 5.081547619047619,
      "code_phi_k": 21.17180865800044
    },
    {
      "comment": "# Placeholder: return ions as witnesses for now",
      "code": "        def chain_zeros_critical(env: Dict[str, Any]) -> Any:\n            \"\"\"SPEC \u00a712: chain with zeros.on.critical -> witnesses\"\"\"\n            ions = env.get(\"ions\", env.get(\"input\", []))\n            # Placeholder: return ions as witnesses for now\n            return {\"witnesses\": ions, \"chain\": \"zeros_on_critical\"}\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 539,
      "alignment": 0.5809586678811282,
      "coherence": 0.5809586678811282,
      "comment_phi_k": 10.700018037518037,
      "code_phi_k": 38.391616290598336
    },
    {
      "comment": "# Zeta Grammar primitives",
      "code": "            # Placeholder: return ions as witnesses for now\n            return {\"witnesses\": ions, \"chain\": \"zeros_on_critical\"}\n        \n        # Zeta Grammar primitives\n        def match_vowel(env: Dict[str, Any]) -> int:\n            \"\"\"Check if glyph is a vowel (zeta_order 1)\"\"\"",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 542,
      "alignment": 0.533992733752915,
      "coherence": 0.533992733752915,
      "comment_phi_k": 4.821230158730159,
      "code_phi_k": 37.868414632752874
    },
    {
      "comment": "Round, flow, line, curve",
      "code": "iconic = {\"o\": 3, \"s\": 3, \"i\": 3, \"c\": 3}",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 562,
      "alignment": 0.7071651090342679,
      "coherence": 0.7071651090342679,
      "comment_phi_k": 5.675000000000001,
      "code_phi_k": 3.3249999999999997
    },
    {
      "comment": "# Simple heuristics",
      "code": "        def classify_type(env: Dict[str, Any]) -> str:\n            \"\"\"Classify word type (simplified heuristic)\"\"\"\n            word = str(env.get(\"word\", \"\")).lower()\n            # Simple heuristics\n            if word.endswith((\"tion\", \"sion\", \"ness\", \"ment\", \"ity\")):\n                return \"N\"  # Noun",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 609,
      "alignment": 0.5314788753536944,
      "coherence": 0.5314788753536944,
      "comment_phi_k": 3.601984126984127,
      "code_phi_k": 30.40735177704992
    },
    {
      "comment": "Noun",
      "code": "return \"N\"",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 611,
      "alignment": 0.8252788104089219,
      "coherence": 0.8252788104089219,
      "comment_phi_k": 1.4583333333333333,
      "code_phi_k": 1.85
    },
    {
      "comment": "Verb",
      "code": "return \"V\"",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 613,
      "alignment": 0.7681660899653979,
      "coherence": 0.7681660899653979,
      "comment_phi_k": 1.2916666666666667,
      "code_phi_k": 1.85
    },
    {
      "comment": "Adverb",
      "code": "return \"Adv\"",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 615,
      "alignment": 0.8153409090909092,
      "coherence": 0.8153409090909092,
      "comment_phi_k": 1.85,
      "code_phi_k": 2.3916666666666666
    },
    {
      "comment": "Article/Adjective",
      "code": "return \"A\"",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 617,
      "alignment": 0.8586868814305262,
      "coherence": 0.8586868814305262,
      "comment_phi_k": 2.513672153010388,
      "code_phi_k": 2.1
    },
    {
      "comment": "Conjunction",
      "code": "return \"C\"",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 619,
      "alignment": 0.9445003033717604,
      "coherence": 0.9445003033717604,
      "comment_phi_k": 1.965494227994228,
      "code_phi_k": 1.85
    },
    {
      "comment": "Preposition",
      "code": "return \"P\"",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 621,
      "alignment": 0.949644892590969,
      "coherence": 0.949644892590969,
      "comment_phi_k": 1.953589466089466,
      "code_phi_k": 1.85
    },
    {
      "comment": "Default to noun",
      "code": "return \"N\"",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 622,
      "alignment": 0.639949567723343,
      "coherence": 0.639949567723343,
      "comment_phi_k": 4.229761904761904,
      "code_phi_k": 1.85
    },
    {
      "comment": "# Nouns have higher mass",
      "code": "        def compute_mass(env: Dict[str, Any]) -> float:\n            \"\"\"Compute semantic mass from type\"\"\"\n            type_name = str(env.get(\"type\", \"\"))\n            # Nouns have higher mass\n            mass_map = {\"N\": 1.0, \"V\": 0.8, \"A\": 0.6, \"Adv\": 0.5, \"P\": 0.4, \"C\": 0.3, \"T\": 0.7}\n            return mass_map.get(type_name, 0.5)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 627,
      "alignment": 0.5527613503379373,
      "coherence": 0.5527613503379373,
      "comment_phi_k": 5.841666666666667,
      "code_phi_k": 30.60050144858582
    },
    {
      "comment": "# Verbs have higher flow",
      "code": "        def compute_flow(env: Dict[str, Any]) -> float:\n            \"\"\"Compute kinetic flow from type\"\"\"\n            type_name = str(env.get(\"type\", \"\"))\n            # Verbs have higher flow\n            flow_map = {\"V\": 1.0, \"T\": 0.9, \"Adv\": 0.7, \"N\": 0.3, \"A\": 0.5, \"P\": 0.6, \"C\": 0.4}\n            return flow_map.get(type_name, 0.5)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 634,
      "alignment": 0.5513005838591779,
      "coherence": 0.5513005838591779,
      "comment_phi_k": 5.591666666666667,
      "code_phi_k": 30.045360755945122
    },
    {
      "comment": "# Adjectives modify curvature",
      "code": "        def compute_curvature(env: Dict[str, Any]) -> float:\n            \"\"\"Compute curvature from type\"\"\"\n            type_name = str(env.get(\"type\", \"\"))\n            # Adjectives modify curvature\n            curvature_map = {\"A\": 1.0, \"Adv\": 0.8, \"V\": 0.6, \"N\": 0.4, \"P\": 0.5, \"C\": 0.3, \"T\": 0.4}\n            return curvature_map.get(type_name, 0.5)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 641,
      "alignment": 0.5520966511253623,
      "coherence": 0.5520966511253623,
      "comment_phi_k": 5.707936507936508,
      "code_phi_k": 30.24505954600382
    },
    {
      "comment": "# Document field primitives",
      "code": "            slot = float(env.get(\"slot\", 0.0))\n            return f\"binding_invitation:{slot}\"\n        \n        # Document field primitives\n        def compute_movement(env: Dict[str, Any]) -> float:\n            \"\"\"Compute zero movement distance\"\"\"",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 682,
      "alignment": 0.556968483320351,
      "coherence": 0.556968483320351,
      "comment_phi_k": 5.233730158730159,
      "code_phi_k": 25.58452128893676
    },
    {
      "comment": "# Simple distance between first zeros",
      "code": "            zero2 = env.get(\"zero2\", env.get(\"zeros_perturbed\", []))\n            if isinstance(zero1, (list, tuple)) and isinstance(zero2, (list, tuple)):\n                if len(zero1) > 0 and len(zero2) > 0:\n                    # Simple distance between first zeros\n                    z1 = float(zero1[0]) if isinstance(zero1[0], (int, float)) else 0.0\n                    z2 = float(zero2[0]) if isinstance(zero2[0], (int, float)) else 0.0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 689,
      "alignment": 0.5417507414296467,
      "coherence": 0.5417507414296467,
      "comment_phi_k": 7.967857142857143,
      "code_phi_k": 51.69480070218812
    },
    {
      "comment": "# Simple compression: keep only essential fields",
      "code": "        def rbc_compress(env: Dict[str, Any]) -> Dict[str, Any]:\n            \"\"\"RBC-compress field state (simplified)\"\"\"\n            field_state = env.get(\"field_state\", {})\n            # Simple compression: keep only essential fields\n            compressed = {\n                \"phi_k\": field_state.get(\"phi_k\", 0.0),",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 698,
      "alignment": 0.5922685890140187,
      "coherence": 0.5922685890140187,
      "comment_phi_k": 10.322240259740258,
      "code_phi_k": 33.129035240645145
    },
    {
      "comment": "# If witness exists, output is deterministic",
      "code": "            \"\"\"Check if output is deterministic given witness\"\"\"\n            output = env.get(\"output\", \"\")\n            witness = env.get(\"witness\", {})\n            # If witness exists, output is deterministic\n            return witness is not None and len(str(witness)) > 0\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 710,
      "alignment": 0.5758099532658705,
      "coherence": 0.5758099532658705,
      "comment_phi_k": 10.246812909312908,
      "code_phi_k": 38.91452644577644
    },
    {
      "comment": "# Simple distance check",
      "code": "            \"\"\"Check distance for locality bounds\"\"\"\n            perturbation = env.get(\"perturbation\", {})\n            region = env.get(\"region\", {})\n            # Simple distance check\n            return float(env.get(\"distance\", 1.0))\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 724,
      "alignment": 0.5547183158124435,
      "coherence": 0.5547183158124435,
      "comment_phi_k": 4.6380952380952385,
      "code_phi_k": 23.509827932869396
    },
    {
      "comment": "# ============================================================================",
      "code": "            threshold = float(env.get(\"threshold\", 1.0))\n            return distance < threshold\n        \n        # ============================================================================\n        # Zeta Zero Solver & Field Computation\n        # ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 733,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 16.736246537802096
    },
    {
      "comment": "# Zeta Zero Solver & Field Computation",
      "code": "            return distance < threshold\n        \n        # ============================================================================\n        # Zeta Zero Solver & Field Computation\n        # ============================================================================\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 734,
      "alignment": 0.7227145009692207,
      "coherence": 0.7227145009692207,
      "comment_phi_k": 8.003589466089466,
      "code_phi_k": 12.985930735930737
    },
    {
      "comment": "# ============================================================================",
      "code": "        \n        # ============================================================================\n        # Zeta Zero Solver & Field Computation\n        # ============================================================================\n        \n        def compute_phi_k(env: Dict[str, Any]) -> float:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 735,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 15.609296463340579
    },
    {
      "comment": "# If we have text, process it hierarchically",
      "code": "            \"\"\"\n            import math\n            \n            # If we have text, process it hierarchically\n            text = env.get(\"text\", env.get(\"x\", env.get(\"input\", \"\")))\n            if isinstance(text, str) and text:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 744,
      "alignment": 0.6108279104458683,
      "coherence": 0.6108279104458683,
      "comment_phi_k": 10.014886502386503,
      "code_phi_k": 27.59851814851815
    },
    {
      "comment": "# Aperture chain: letter \u2192 syllable \u2192 word \u2192 sentence",
      "code": "            # If we have text, process it hierarchically\n            text = env.get(\"text\", env.get(\"x\", env.get(\"input\", \"\")))\n            if isinstance(text, str) and text:\n                # Aperture chain: letter \u2192 syllable \u2192 word \u2192 sentence\n                # Simple implementation: sum of character potentials\n                phi_k = 0.0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 747,
      "alignment": 0.5600631784713465,
      "coherence": 0.5600631784713465,
      "comment_phi_k": 9.764285714285716,
      "code_phi_k": 45.52387196137196
    },
    {
      "comment": "# Simple implementation: sum of character potentials",
      "code": "            text = env.get(\"text\", env.get(\"x\", env.get(\"input\", \"\")))\n            if isinstance(text, str) and text:\n                # Aperture chain: letter \u2192 syllable \u2192 word \u2192 sentence\n                # Simple implementation: sum of character potentials\n                phi_k = 0.0\n                for i, char in enumerate(text.lower()):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 748,
      "alignment": 0.5669611527975449,
      "coherence": 0.5669611527975449,
      "comment_phi_k": 10.119401431901432,
      "code_phi_k": 42.840566968721
    },
    {
      "comment": "# Vowel = potential well (higher contribution)",
      "code": "                phi_k = 0.0\n                for i, char in enumerate(text.lower()):\n                    if char.isalpha():\n                        # Vowel = potential well (higher contribution)\n                        if char in \"aeiou\":\n                            phi_k += 1.0 / (i + 1)  # Decay with position",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 752,
      "alignment": 0.5723639296302836,
      "coherence": 0.5723639296302836,
      "comment_phi_k": 7.821067821067821,
      "code_phi_k": 30.93044514609917
    },
    {
      "comment": "Decay with position",
      "code": "phi_k += 1.0 / (i + 1)",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 754,
      "alignment": 0.6091554732129072,
      "coherence": 0.6091554732129072,
      "comment_phi_k": 4.6970238095238095,
      "code_phi_k": 1.6833333333333333
    },
    {
      "comment": "Consonant = barrier",
      "code": "phi_k += 0.5 / (i + 1)",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 756,
      "alignment": 0.6544904945735306,
      "coherence": 0.6544904945735306,
      "comment_phi_k": 3.565674603174603,
      "code_phi_k": 1.6833333333333333
    },
    {
      "comment": "Space = small potential",
      "code": "phi_k += 0.1",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 758,
      "alignment": 0.5730739070770438,
      "coherence": 0.5730739070770438,
      "comment_phi_k": 4.640079365079365,
      "code_phi_k": 1.1833333333333333
    },
    {
      "comment": "# If we have coordinates or numeric input",
      "code": "                        phi_k += 0.1  # Space = small potential\n                return phi_k\n            \n            # If we have coordinates or numeric input\n            x = env.get(\"x\", env.get(\"input\", 0.0))\n            t = env.get(\"t\", 0.0)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 761,
      "alignment": 0.6284670390515299,
      "coherence": 0.6284670390515299,
      "comment_phi_k": 10.560533910533913,
      "code_phi_k": 25.83132423132423
    },
    {
      "comment": "# Simple field: \u03a6\u03ba(x,t) = sin(x) * exp(-t) for demonstration",
      "code": "            t = env.get(\"t\", 0.0)\n            \n            if isinstance(x, (int, float)):\n                # Simple field: \u03a6\u03ba(x,t) = sin(x) * exp(-t) for demonstration\n                return math.sin(float(x)) * math.exp(-float(t))\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 766,
      "alignment": 0.6365151404735767,
      "coherence": 0.6365151404735767,
      "comment_phi_k": 10.116076978576977,
      "code_phi_k": 23.583597162641283
    },
    {
      "comment": "# Get field spectrum (phi_k values)",
      "code": "            import math\n            import cmath\n            \n            # Get field spectrum (phi_k values)\n            phi_k = env.get(\"phi_k\", env.get(\"phi_k_doc\", env.get(\"spectrum\", 0.0)))\n            region = env.get(\"region\", {\"min\": 0.0, \"max\": 10.0})",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 780,
      "alignment": 0.5765971836498687,
      "coherence": 0.5765971836498687,
      "comment_phi_k": 6.77202380952381,
      "code_phi_k": 25.488729938362287
    },
    {
      "comment": "# If phi_k is a list/array, use it as spectrum",
      "code": "            region = env.get(\"region\", {\"min\": 0.0, \"max\": 10.0})\n            tolerance = float(env.get(\"tolerance\", 0.01))\n            \n            # If phi_k is a list/array, use it as spectrum\n            if isinstance(phi_k, (list, tuple)):\n                spectrum = [float(x) for x in phi_k]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 785,
      "alignment": 0.6085114006015755,
      "coherence": 0.6085114006015755,
      "comment_phi_k": 12.117063492063494,
      "code_phi_k": 33.975099555699224
    },
    {
      "comment": "# Single value: create expanded spectrum with harmonics for better zero detection",
      "code": "            if isinstance(phi_k, (list, tuple)):\n                spectrum = [float(x) for x in phi_k]\n            else:\n                # Single value: create expanded spectrum with harmonics for better zero detection\n                phi_k_val = float(phi_k)\n                # Use harmonic series: spectrum = phi_k * [1, 1/2, 1/3, 1/4, ...]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 789,
      "alignment": 0.6289869465824228,
      "coherence": 0.6289869465824228,
      "comment_phi_k": 17.636706349206346,
      "code_phi_k": 43.00147560772562
    },
    {
      "comment": "# Use harmonic series: spectrum = phi_k * [1, 1/2, 1/3, 1/4, ...]",
      "code": "            else:\n                # Single value: create expanded spectrum with harmonics for better zero detection\n                phi_k_val = float(phi_k)\n                # Use harmonic series: spectrum = phi_k * [1, 1/2, 1/3, 1/4, ...]\n                spectrum = [phi_k_val / (n + 1) for n in range(30)]  # More terms for better resolution\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 791,
      "alignment": 0.5475923131575388,
      "coherence": 0.5475923131575388,
      "comment_phi_k": 7.844047619047618,
      "code_phi_k": 45.126406926406915
    },
    {
      "comment": "More terms for better resolution",
      "code": "spectrum = [phi_k_val / (n + 1) for n in range(30)]",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 792,
      "alignment": 0.9544932887580461,
      "coherence": 0.9544932887580461,
      "comment_phi_k": 7.590873015873017,
      "code_phi_k": 7.2289682539682545
    },
    {
      "comment": "# Construct zeta function from spectrum",
      "code": "                # Use harmonic series: spectrum = phi_k * [1, 1/2, 1/3, 1/4, ...]\n                spectrum = [phi_k_val / (n + 1) for n in range(30)]  # More terms for better resolution\n            \n            # Construct zeta function from spectrum\n            # \u03b6_F(s) = \u03a3 a_n n^{-s} where a_n comes from spectrum\n            def zeta_F(s: complex) -> complex:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 794,
      "alignment": 0.5454815313451744,
      "coherence": 0.5454815313451744,
      "comment_phi_k": 7.721626984126983,
      "code_phi_k": 46.304563492063494
    },
    {
      "comment": "# \u03b6_F(s) = \u03a3 a_n n^{-s} where a_n comes from spectrum",
      "code": "                spectrum = [phi_k_val / (n + 1) for n in range(30)]  # More terms for better resolution\n            \n            # Construct zeta function from spectrum\n            # \u03b6_F(s) = \u03a3 a_n n^{-s} where a_n comes from spectrum\n            def zeta_F(s: complex) -> complex:\n                \"\"\"Zeta function constructed from spectrum\"\"\"",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 795,
      "alignment": 0.5613031286766745,
      "coherence": 0.5613031286766745,
      "comment_phi_k": 9.930357142857144,
      "code_phi_k": 45.46212121212122
    },
    {
      "comment": "# Use proper complex exponentiation: n^{-s} = exp(-s * log(n))",
      "code": "                for n, a_n in enumerate(spectrum, start=1):\n                    if n > len(spectrum):\n                        break\n                    # Use proper complex exponentiation: n^{-s} = exp(-s * log(n))\n                    result += a_n * cmath.exp(-s * cmath.log(n))\n                return result",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 802,
      "alignment": 0.5962610178244501,
      "coherence": 0.5962610178244501,
      "comment_phi_k": 10.59122682872683,
      "code_phi_k": 32.80214479148304
    },
    {
      "comment": "Avoid division by zero",
      "code": "if abs(zeta_deriv) < 1e-12:",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 824,
      "alignment": 0.7437144289768469,
      "coherence": 0.7437144289768469,
      "comment_phi_k": 5.9886904761904765,
      "code_phi_k": 3.924975024975025
    },
    {
      "comment": "# Keep on critical line: Re(s) = 0.5",
      "code": "                    if abs(zeta_deriv) < 1e-12:  # Avoid division by zero\n                        break\n                    s_new = s - zeta_val / zeta_deriv\n                    # Keep on critical line: Re(s) = 0.5\n                    s = 0.5 + 1j * s_new.imag\n                    # Check convergence",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 827,
      "alignment": 0.5685966886937608,
      "coherence": 0.5685966886937608,
      "comment_phi_k": 6.9470238095238095,
      "code_phi_k": 28.791876179376175
    },
    {
      "comment": "# Check convergence",
      "code": "                    s_new = s - zeta_val / zeta_deriv\n                    # Keep on critical line: Re(s) = 0.5\n                    s = 0.5 + 1j * s_new.imag\n                    # Check convergence\n                    if abs(s_new - s) < tolerance * 0.1:\n                        break",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 829,
      "alignment": 0.5361022727453422,
      "coherence": 0.5361022727453422,
      "comment_phi_k": 3.276226551226551,
      "code_phi_k": 24.325234487734487
    },
    {
      "comment": "# Search for zeros on critical line Re(s) = 1/2",
      "code": "                        break\n                return s\n            \n            # Search for zeros on critical line Re(s) = 1/2\n            zeros = []\n            min_im = float(region.get(\"min\", 0.0)) if isinstance(region, dict) else 0.0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 834,
      "alignment": 0.6206663210803139,
      "coherence": 0.6206663210803139,
      "comment_phi_k": 9.813690476190477,
      "code_phi_k": 25.239135118837133
    },
    {
      "comment": "# Finer search with adaptive refinement",
      "code": "            min_im = float(region.get(\"min\", 0.0)) if isinstance(region, dict) else 0.0\n            max_im = float(region.get(\"max\", 10.0)) if isinstance(region, dict) else 10.0\n            \n            # Finer search with adaptive refinement\n            step = 0.05  # Finer step size\n            prev_zeta = None",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 839,
      "alignment": 0.5643657421911471,
      "coherence": 0.5643657421911471,
      "comment_phi_k": 8.606746031746033,
      "code_phi_k": 37.73243690434092
    },
    {
      "comment": "Finer step size",
      "code": "step = 0.05",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 840,
      "alignment": 0.5853945818610129,
      "coherence": 0.5853945818610129,
      "comment_phi_k": 4.141666666666667,
      "code_phi_k": 1.2083333333333333
    },
    {
      "comment": "# Check if near zero",
      "code": "                s = 0.5 + 1j * im\n                zeta_val = zeta_F(s)\n                \n                # Check if near zero\n                if abs(zeta_val) < tolerance:\n                    # Refine with Newton-Raphson",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 847,
      "alignment": 0.574639424011623,
      "coherence": 0.574639424011623,
      "comment_phi_k": 5.433333333333334,
      "code_phi_k": 20.915270840270843
    },
    {
      "comment": "# Refine with Newton-Raphson",
      "code": "                \n                # Check if near zero\n                if abs(zeta_val) < tolerance:\n                    # Refine with Newton-Raphson\n                    refined_s = newton_raphson(s)\n                    refined_zeta = zeta_F(refined_s)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 849,
      "alignment": 0.5590946552942156,
      "coherence": 0.5590946552942156,
      "comment_phi_k": 4.973369685869686,
      "code_phi_k": 23.526530414030415
    },
    {
      "comment": "# Check for zero crossing using argument principle",
      "code": "                        \"value\": refined_zeta\n                    })\n                elif prev_zeta is not None:\n                    # Check for zero crossing using argument principle\n                    # Zero crossing if phase changes significantly\n                    prev_phase = cmath.phase(prev_zeta)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 858,
      "alignment": 0.5964135576413542,
      "coherence": 0.5964135576413542,
      "comment_phi_k": 11.09623015873016,
      "code_phi_k": 34.320599028164814
    },
    {
      "comment": "# Zero crossing if phase changes significantly",
      "code": "                    })\n                elif prev_zeta is not None:\n                    # Check for zero crossing using argument principle\n                    # Zero crossing if phase changes significantly\n                    prev_phase = cmath.phase(prev_zeta)\n                    curr_phase = cmath.phase(zeta_val)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 859,
      "alignment": 0.5767361360399909,
      "coherence": 0.5767361360399909,
      "comment_phi_k": 9.297408147408149,
      "code_phi_k": 34.9388927227743
    },
    {
      "comment": "# Normalize phase difference to [0, 2\u03c0]",
      "code": "                    prev_phase = cmath.phase(prev_zeta)\n                    curr_phase = cmath.phase(zeta_val)\n                    phase_diff = abs(curr_phase - prev_phase)\n                    # Normalize phase difference to [0, 2\u03c0]\n                    if phase_diff > math.pi:\n                        phase_diff = 2 * math.pi - phase_diff",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 863,
      "alignment": 0.5635483399204421,
      "coherence": 0.5635483399204421,
      "comment_phi_k": 6.485714285714286,
      "code_phi_k": 28.7577419291235
    },
    {
      "comment": "# Significant phase change indicates zero crossing",
      "code": "                    if phase_diff > math.pi:\n                        phase_diff = 2 * math.pi - phase_diff\n                    \n                    # Significant phase change indicates zero crossing\n                    if phase_diff > math.pi / 2:  # 90 degree phase change\n                        # Refine zero location with Newton-Raphson",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 867,
      "alignment": 0.579364736064327,
      "coherence": 0.579364736064327,
      "comment_phi_k": 10.08116883116883,
      "code_phi_k": 36.79640359640359
    },
    {
      "comment": "90 degree phase change",
      "code": "if phase_diff > math.pi / 2:",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 868,
      "alignment": 0.9862128392934081,
      "coherence": 0.9862128392934081,
      "comment_phi_k": 4.541666666666666,
      "code_phi_k": 4.478174603174603
    },
    {
      "comment": "# Refine zero location with Newton-Raphson",
      "code": "                    \n                    # Significant phase change indicates zero crossing\n                    if phase_diff > math.pi / 2:  # 90 degree phase change\n                        # Refine zero location with Newton-Raphson\n                        refined_s = newton_raphson(s)\n                        refined_zeta = zeta_F(refined_s)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 869,
      "alignment": 0.5665075710351488,
      "coherence": 0.5665075710351488,
      "comment_phi_k": 8.27872682872683,
      "code_phi_k": 35.25885364635366
    },
    {
      "comment": "Accept if reasonably close",
      "code": "if abs(refined_zeta) < tolerance * 10:",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 872,
      "alignment": 0.8568564191644067,
      "coherence": 0.8568564191644067,
      "comment_phi_k": 6.560912698412698,
      "code_phi_k": 5.464868464868466
    },
    {
      "comment": "# Remove duplicates (zeros very close to each other)",
      "code": "                \n                prev_zeta = zeta_val\n            \n            # Remove duplicates (zeros very close to each other)\n            unique_zeros = []\n            for zero in zeros:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 881,
      "alignment": 0.6743005225793572,
      "coherence": 0.6743005225793572,
      "comment_phi_k": 11.874801587301587,
      "code_phi_k": 22.96948051948052
    },
    {
      "comment": "# Keep the one closer to actual zero",
      "code": "                for existing in unique_zeros:\n                    if abs(zero[\"imaginary\"] - existing[\"imaginary\"]) < 0.2:\n                        is_duplicate = True\n                        # Keep the one closer to actual zero\n                        if abs(zero[\"value\"]) < abs(existing[\"value\"]):\n                            unique_zeros.remove(existing)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 888,
      "alignment": 0.5823115428120764,
      "coherence": 0.5823115428120764,
      "comment_phi_k": 9.983333333333333,
      "code_phi_k": 35.31345688060438
    },
    {
      "comment": "# Sort by imaginary part",
      "code": "                if not is_duplicate:\n                    unique_zeros.append(zero)\n            \n            # Sort by imaginary part\n            unique_zeros.sort(key=lambda z: z[\"imaginary\"])\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 896,
      "alignment": 0.5932943987329495,
      "coherence": 0.5932943987329495,
      "comment_phi_k": 5.585912698412699,
      "code_phi_k": 17.76146671605616
    },
    {
      "comment": "# Level 1: Letters",
      "code": "            if not text:\n                return {\"aperture\": {}, \"levels\": []}\n            \n            # Level 1: Letters\n            letters = []\n            for char in text:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 910,
      "alignment": 0.5506590571098089,
      "coherence": 0.5506590571098089,
      "comment_phi_k": 3.163095238095238,
      "code_phi_k": 17.191269841269843
    },
    {
      "comment": "# Level 2: Words (simple: split by spaces)",
      "code": "                        \"phi_k\": compute_phi_k({\"text\": char})\n                    })\n            \n            # Level 2: Words (simple: split by spaces)\n            words = []\n            word_texts = text.split()",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 921,
      "alignment": 0.6487784553243001,
      "coherence": 0.6487784553243001,
      "comment_phi_k": 7.451190476190476,
      "code_phi_k": 16.246209294661305
    },
    {
      "comment": "# Level 3: Sentences (simple: split by periods)",
      "code": "                    \"curvature\": compute_curvature({\"type\": word_type})\n                })\n            \n            # Level 3: Sentences (simple: split by periods)\n            sentences = []\n            sentence_texts = text.split('.')",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 936,
      "alignment": 0.6370619504096351,
      "coherence": 0.6370619504096351,
      "comment_phi_k": 8.166269841269841,
      "code_phi_k": 18.978351676385564
    },
    {
      "comment": "# Level 4: Discourse (entire text)",
      "code": "                        \"words\": [w for w in words if w[\"text\"] in sent_text]\n                    })\n            \n            # Level 4: Discourse (entire text)\n            discourse_phi_k = sum_field_potential({\"words\": words})\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 950,
      "alignment": 0.5768785974786624,
      "coherence": 0.5768785974786624,
      "comment_phi_k": 5.929563492063492,
      "code_phi_k": 22.24701271320449
    },
    {
      "comment": "# If lists are different lengths, add new zeros",
      "code": "                        \"magnitude\": abs(movement)\n                    })\n            \n            # If lists are different lengths, add new zeros\n            if len(zeros_perturbed) > len(zeros_original):\n                for i in range(len(zeros_original), len(zeros_perturbed)):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 993,
      "alignment": 0.6295385243020585,
      "coherence": 0.6295385243020585,
      "comment_phi_k": 11.70734126984127,
      "code_phi_k": 28.447994086031674
    },
    {
      "comment": "# Extract semantic context from question",
      "code": "            if abs(max_movement) < 0.01:\n                return \"No significant semantic change detected\"\n            \n            # Extract semantic context from question\n            question_lower = question.lower()\n            question_words = question_lower.split()",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1037,
      "alignment": 0.5816271684106147,
      "coherence": 0.5816271684106147,
      "comment_phi_k": 8.48690476190476,
      "code_phi_k": 30.236344597954506
    },
    {
      "comment": "# Analyze movement patterns with semantic interpretation",
      "code": "            question_lower = question.lower()\n            question_words = question_lower.split()\n            \n            # Analyze movement patterns with semantic interpretation\n            if movement_list:\n                positive_movements = [m for m in movement_list if m.get(\"movement\", 0.0) > 0]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1041,
      "alignment": 0.598510021362402,
      "coherence": 0.598510021362402,
      "comment_phi_k": 11.101147463647465,
      "code_phi_k": 33.72320863261266
    },
    {
      "comment": "# Semantic interpretation based on movement patterns",
      "code": "                negative_movements = [m for m in movement_list if m.get(\"movement\", 0.0) < 0]\n                new_zeros = [m for m in movement_list if m.get(\"new_zero\", False)]\n                \n                # Semantic interpretation based on movement patterns\n                if new_zeros:\n                    # New zeros indicate discovery of new semantic structure",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1047,
      "alignment": 0.5625382580387834,
      "coherence": 0.5625382580387834,
      "comment_phi_k": 10.541623654123654,
      "code_phi_k": 47.411510915555034
    },
    {
      "comment": "# New zeros indicate discovery of new semantic structure",
      "code": "                \n                # Semantic interpretation based on movement patterns\n                if new_zeros:\n                    # New zeros indicate discovery of new semantic structure\n                    return f\"Discovered {len(new_zeros)} new semantic structures in the field\"\n                ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1049,
      "alignment": 0.5955103302738621,
      "coherence": 0.5955103302738621,
      "comment_phi_k": 12.537500000000001,
      "code_phi_k": 39.08588078588079
    },
    {
      "comment": "# Large positive movement = semantic expansion/enrichment",
      "code": "                    # New zeros indicate discovery of new semantic structure\n                    return f\"Discovered {len(new_zeros)} new semantic structures in the field\"\n                \n                # Large positive movement = semantic expansion/enrichment\n                if max_movement > 0.5:\n                    if any(w in question_words for w in [\"what\", \"describe\", \"explain\"]):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1052,
      "alignment": 0.552570802185875,
      "coherence": 0.552570802185875,
      "comment_phi_k": 9.61079262799464,
      "code_phi_k": 50.50943842664045
    },
    {
      "comment": "# Question asking for description \u2192 field expansion = detailed answer",
      "code": "                # Large positive movement = semantic expansion/enrichment\n                if max_movement > 0.5:\n                    if any(w in question_words for w in [\"what\", \"describe\", \"explain\"]):\n                        # Question asking for description \u2192 field expansion = detailed answer\n                        return f\"The field expanded significantly (movement: {max_movement:.3f}), indicating rich semantic content available\"\n                    return f\"Semantic enrichment detected: fi",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1055,
      "alignment": 0.5507821586994321,
      "coherence": 0.5507821586994321,
      "comment_phi_k": 14.357954545454545,
      "code_phi_k": 77.8630271101709
    },
    {
      "comment": "# Large negative movement = semantic focus/contraction",
      "code": "                        return f\"The field expanded significantly (movement: {max_movement:.3f}), indicating rich semantic content available\"\n                    return f\"Semantic enrichment detected: field expanded with {len(positive_movements)} zeros moving forward\"\n                \n                # Large negative movement = semantic focus/contraction\n                if max_movement < -0.5:\n                    if any(w in question_words for w in [\"which\", \"where\", \"when\"]):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1059,
      "alignment": 0.5396940171059809,
      "coherence": 0.5396940171059809,
      "comment_phi_k": 9.174240547034666,
      "code_phi_k": 62.36812365835956
    },
    {
      "comment": "# Question asking for specific info \u2192 field contraction = focused answer",
      "code": "                # Large negative movement = semantic focus/contraction\n                if max_movement < -0.5:\n                    if any(w in question_words for w in [\"which\", \"where\", \"when\"]):\n                        # Question asking for specific info \u2192 field contraction = focused answer\n                        return f\"Field focused on specific semantic region (movement: {abs(max_movement):.3f}), indicating precise answer available\"\n                    return f\"Semantic focus detected: fiel",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1062,
      "alignment": 0.5542439624804323,
      "coherence": 0.5542439624804323,
      "comment_phi_k": 15.397637085137085,
      "code_phi_k": 78.6635691850551
    },
    {
      "comment": "# Balanced movement = semantic reconfiguration",
      "code": "                        return f\"Field focused on specific semantic region (movement: {abs(max_movement):.3f}), indicating precise answer available\"\n                    return f\"Semantic focus detected: field contracted with {len(negative_movements)} zeros moving backward\"\n                \n                # Balanced movement = semantic reconfiguration\n                if len(positive_movements) == len(negative_movements):\n                    return f\"Semantic reconfiguration: {len(movement_list)}",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1066,
      "alignment": 0.5295134067221593,
      "coherence": 0.5295134067221593,
      "comment_phi_k": 7.7087051837051845,
      "code_phi_k": 69.15268680548076
    },
    {
      "comment": "# Dominant direction",
      "code": "                if len(positive_movements) == len(negative_movements):\n                    return f\"Semantic reconfiguration: {len(movement_list)} zeros shifted, indicating structural reorganization\"\n                \n                # Dominant direction\n                if len(positive_movements) > len(negative_movements):\n                    return f\"Field expanded: {len(positive_movements)} zeros moved forward (semantic enrichment)\"",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1070,
      "alignment": 0.5211222236205196,
      "coherence": 0.5211222236205196,
      "comment_phi_k": 3.7406746031746034,
      "code_phi_k": 46.14449458705246
    },
    {
      "comment": "# Fallback with semantic hints",
      "code": "                else:\n                    return f\"Field contracted: {len(negative_movements)} zeros moved backward (semantic focus)\"\n            \n            # Fallback with semantic hints\n            if max_movement > 0:\n                magnitude_desc = \"significantly\" if max_movement > 0.3 else \"moderately\"",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1076,
      "alignment": 0.5489638873872698,
      "coherence": 0.5489638873872698,
      "comment_phi_k": 6.180952380952381,
      "code_phi_k": 34.64920605635373
    },
    {
      "comment": "# Helper functions for query resolution (need executor reference)",
      "code": "                magnitude_desc = \"significantly\" if abs(max_movement) > 0.3 else \"moderately\"\n                return f\"Field contracted {magnitude_desc} (movement: {abs(max_movement):.3f}) - semantic focus sharpened\"\n        \n        # Helper functions for query resolution (need executor reference)\n        def query_perturb_field(env: Dict[str, Any], executor) -> Dict[str, Any]:\n            \"\"\"Perturb field with question and return perturbed phi_k\"\"\"",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1084,
      "alignment": 0.5613604820495205,
      "coherence": 0.5613604820495205,
      "comment_phi_k": 13.218849206349207,
      "code_phi_k": 60.46676390699979
    },
    {
      "comment": "# Get original phi_k",
      "code": "            question = env.get(\"question\", \"\")\n            document_field = env.get(\"document_field\", {})\n            \n            # Get original phi_k\n            phi_k_doc = document_field.get(\"phi_k\", 0.0)\n            if isinstance(phi_k_doc, dict):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1090,
      "alignment": 0.5575912681392956,
      "coherence": 0.5575912681392956,
      "comment_phi_k": 4.54702380952381,
      "code_phi_k": 22.01185052983764
    },
    {
      "comment": "# Compute question field potential",
      "code": "            if isinstance(phi_k_doc, dict):\n                phi_k_doc = phi_k_doc.get(\"discourse\", {}).get(\"phi_k\", 0.0)\n            \n            # Compute question field potential\n            phi_k_question = compute_phi_k({\"text\": question})\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1095,
      "alignment": 0.5970455293396485,
      "coherence": 0.5970455293396485,
      "comment_phi_k": 7.129960317460317,
      "code_phi_k": 21.93254527475486
    },
    {
      "comment": "# Local deformation: combine question and document fields",
      "code": "            # Compute question field potential\n            phi_k_question = compute_phi_k({\"text\": question})\n            \n            # Local deformation: combine question and document fields\n            # Simple: weighted combination\n            phi_k_perturbed = float(phi_k_doc) + 0.3 * float(phi_k_question)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1098,
      "alignment": 0.6003596807524343,
      "coherence": 0.6003596807524343,
      "comment_phi_k": 12.10239898989899,
      "code_phi_k": 36.198761990073905
    },
    {
      "comment": "# Simple: weighted combination",
      "code": "            phi_k_question = compute_phi_k({\"text\": question})\n            \n            # Local deformation: combine question and document fields\n            # Simple: weighted combination\n            phi_k_perturbed = float(phi_k_doc) + 0.3 * float(phi_k_question)\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1099,
      "alignment": 0.5516391170110511,
      "coherence": 0.5516391170110511,
      "comment_phi_k": 5.442279942279942,
      "code_phi_k": 29.068801672613596
    },
    {
      "comment": "# Get original zeros from document field",
      "code": "            phi_k_perturbed = env.get(\"phi_k_perturbed\", 0.0)\n            phi_k_original = env.get(\"phi_k_original\", 0.0)\n            \n            # Get original zeros from document field\n            document_field = env.get(\"document_field\", {})\n            zeros_original = document_field.get(\"zeros\", [])",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1109,
      "alignment": 0.6084232909816754,
      "coherence": 0.6084232909816754,
      "comment_phi_k": 9.464285714285714,
      "code_phi_k": 26.55468123564789
    },
    {
      "comment": "# Compute zeros for perturbed field",
      "code": "            document_field = env.get(\"document_field\", {})\n            zeros_original = document_field.get(\"zeros\", [])\n            \n            # Compute zeros for perturbed field\n            region = {\"min\": 0.0, \"max\": 10.0}\n            zeros_perturbed = zeta_zero_solver({",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1113,
      "alignment": 0.597302222741147,
      "coherence": 0.597302222741147,
      "comment_phi_k": 7.786507936507936,
      "code_phi_k": 23.899240771922322
    },
    {
      "comment": "# Compare zeros",
      "code": "                \"tolerance\": 0.01\n            })\n            \n            # Compare zeros\n            return compare_zeros({\n                \"zeros_original\": zeros_original,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1121,
      "alignment": 0.5786369999561476,
      "coherence": 0.5786369999561476,
      "comment_phi_k": 3.2345238095238096,
      "code_phi_k": 11.900346875346875
    },
    {
      "comment": "# ============================================================================",
      "code": "                \"chain\": \"W0\u2192W1\u2192W2\"\n            }\n        \n        # ============================================================================\n        # Composer Planning & Generation Pipeline\n        # ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1178,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 8.672420634920636
    },
    {
      "comment": "# Composer Planning & Generation Pipeline",
      "code": "            }\n        \n        # ============================================================================\n        # Composer Planning & Generation Pipeline\n        # ============================================================================\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1179,
      "alignment": 1.0,
      "coherence": 1.0,
      "comment_phi_k": 7.309920634920635,
      "code_phi_k": 7.309920634920635
    },
    {
      "comment": "# ============================================================================",
      "code": "        \n        # ============================================================================\n        # Composer Planning & Generation Pipeline\n        # ============================================================================\n        \n        def extract_ions(env: Dict[str, Any]) -> list:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1180,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 15.024522005772004
    },
    {
      "comment": "# Classify word type",
      "code": "                if not word_lower:\n                    continue\n                \n                # Classify word type\n                word_type = classify_type({\"word\": word_lower})\n                ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1199,
      "alignment": 0.5761352315799,
      "coherence": 0.5761352315799,
      "comment_phi_k": 4.067261904761905,
      "code_phi_k": 15.389017874969886
    },
    {
      "comment": "# Map to ion charge",
      "code": "                # Classify word type\n                word_type = classify_type({\"word\": word_lower})\n                \n                # Map to ion charge\n                # Nouns (+1): emit/express semantic content\n                # Verbs (-1): absorb/act on semantic content",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1202,
      "alignment": 0.5482963448996279,
      "coherence": 0.5482963448996279,
      "comment_phi_k": 5.308333333333334,
      "code_phi_k": 30.13209146804348
    },
    {
      "comment": "# Nouns (+1): emit/express semantic content",
      "code": "                word_type = classify_type({\"word\": word_lower})\n                \n                # Map to ion charge\n                # Nouns (+1): emit/express semantic content\n                # Verbs (-1): absorb/act on semantic content\n                if word_type == \"N\":",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1203,
      "alignment": 0.5710429128768044,
      "coherence": 0.5710429128768044,
      "comment_phi_k": 7.261724386724386,
      "code_phi_k": 29.18486924582126
    },
    {
      "comment": "# Verbs (-1): absorb/act on semantic content",
      "code": "                \n                # Map to ion charge\n                # Nouns (+1): emit/express semantic content\n                # Verbs (-1): absorb/act on semantic content\n                if word_type == \"N\":\n                    charge = +1",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1204,
      "alignment": 0.5961552906448008,
      "coherence": 0.5961552906448008,
      "comment_phi_k": 8.174007936507937,
      "code_phi_k": 25.339105339105345
    },
    {
      "comment": "Neutral modifiers",
      "code": "charge = 0",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1212,
      "alignment": 0.6227867336152221,
      "coherence": 0.6227867336152221,
      "comment_phi_k": 3.7406746031746034,
      "code_phi_k": 1.475
    },
    {
      "comment": "# Compute field properties",
      "code": "                    charge = 0\n                    bias = \"other\"\n                \n                # Compute field properties\n                phi_k = compute_phi_k({\"text\": word_lower})\n                mass = compute_mass({\"type\": word_type})",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1218,
      "alignment": 0.5771980302343019,
      "coherence": 0.5771980302343019,
      "comment_phi_k": 5.125396825396825,
      "code_phi_k": 19.160909564721486
    },
    {
      "comment": "# Extract ions from intent if not provided",
      "code": "            \"\"\"\n            ions = env.get(\"ions\", [])\n            if not ions:\n                # Extract ions from intent if not provided\n                ions = extract_ions(env)\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1242,
      "alignment": 0.6544543833475189,
      "coherence": 0.6544543833475189,
      "comment_phi_k": 10.860119047619047,
      "code_phi_k": 23.008257714507717
    },
    {
      "comment": "# Compute field state from ions",
      "code": "            if not ions:\n                return {\"plan\": [], \"witnesses\": [], \"zeros\": [], \"coherence\": 0.0}\n            \n            # Compute field state from ions\n            ion_phi_k_values = [ion.get(\"phi_k\", 0.0) for ion in ions if isinstance(ion, dict)]\n            if not ion_phi_k_values:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1248,
      "alignment": 0.557629006213755,
      "coherence": 0.557629006213755,
      "comment_phi_k": 7.684523809523809,
      "code_phi_k": 37.17844239094239
    },
    {
      "comment": "# Find critical zeros",
      "code": "            if not ion_phi_k_values:\n                ion_phi_k_values = [0.0]\n            \n            # Find critical zeros\n            region = env.get(\"region\", {\"min\": 0.0, \"max\": 10.0})\n            zeros = zeta_zero_solver({",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1253,
      "alignment": 0.5621689324913492,
      "coherence": 0.5621689324913492,
      "comment_phi_k": 4.505357142857143,
      "code_phi_k": 20.37007645132645
    },
    {
      "comment": "# Chain ions guided by zeros.on.critical",
      "code": "                \"tolerance\": 0.01\n            })\n            \n            # Chain ions guided by zeros.on.critical\n            # Strategy: order ions to maximize coherence with zero positions\n            if zeros:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1261,
      "alignment": 0.5867429008489778,
      "coherence": 0.5867429008489778,
      "comment_phi_k": 7.852613562907681,
      "code_phi_k": 26.55816911846324
    },
    {
      "comment": "# Strategy: order ions to maximize coherence with zero positions",
      "code": "            })\n            \n            # Chain ions guided by zeros.on.critical\n            # Strategy: order ions to maximize coherence with zero positions\n            if zeros:\n                # Use zero positions to guide ordering",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1262,
      "alignment": 0.6322072676817506,
      "coherence": 0.6322072676817506,
      "comment_phi_k": 14.586309523809522,
      "code_phi_k": 34.87543102322515
    },
    {
      "comment": "# Use zero positions to guide ordering",
      "code": "            # Chain ions guided by zeros.on.critical\n            # Strategy: order ions to maximize coherence with zero positions\n            if zeros:\n                # Use zero positions to guide ordering\n                zero_positions = [z.get(\"imaginary\", 0.0) for z in zeros if isinstance(z, dict)]\n                if zero_positions:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1264,
      "alignment": 0.5525746116745849,
      "coherence": 0.5525746116745849,
      "comment_phi_k": 9.669841269841271,
      "code_phi_k": 50.8164360557743
    },
    {
      "comment": "# Sort ions by proximity to zero positions",
      "code": "                # Use zero positions to guide ordering\n                zero_positions = [z.get(\"imaginary\", 0.0) for z in zeros if isinstance(z, dict)]\n                if zero_positions:\n                    # Sort ions by proximity to zero positions\n                    def ion_zero_distance(ion):\n                        phi_k = ion.get(\"phi_k\", 0.0)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1267,
      "alignment": 0.5657413610777727,
      "coherence": 0.5657413610777727,
      "comment_phi_k": 9.946825396825396,
      "code_phi_k": 42.799011506209645
    },
    {
      "comment": "# No zeros: use natural ordering (nouns first, then verbs)",
      "code": "                else:\n                    ions_sorted = ions\n            else:\n                # No zeros: use natural ordering (nouns first, then verbs)\n                ions_sorted = sorted(ions, key=lambda i: (-i.get(\"q\", 0), i.get(\"phi_k\", 0.0)))\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1276,
      "alignment": 0.6388562502832876,
      "coherence": 0.6388562502832876,
      "comment_phi_k": 12.930357142857146,
      "code_phi_k": 29.745292207792208
    },
    {
      "comment": "# Build plan with witnesses",
      "code": "                # No zeros: use natural ordering (nouns first, then verbs)\n                ions_sorted = sorted(ions, key=lambda i: (-i.get(\"q\", 0), i.get(\"phi_k\", 0.0)))\n            \n            # Build plan with witnesses\n            plan = []\n            witnesses = []",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1279,
      "alignment": 0.5519594060471791,
      "coherence": 0.5519594060471791,
      "comment_phi_k": 5.88531746031746,
      "code_phi_k": 31.259559884559884
    },
    {
      "comment": "# Create witness for each step",
      "code": "                plan.append(step)\n                coherence_sum += abs(ion.get(\"phi_k\", 0.0))\n                \n                # Create witness for each step\n                witnesses.append({\n                    \"step\": i,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1294,
      "alignment": 0.6342411747448904,
      "coherence": 0.6342411747448904,
      "comment_phi_k": 7.413095238095238,
      "code_phi_k": 17.512101787101788
    },
    {
      "comment": "Cycle through W0, W1, W2",
      "code": "\"witness\": f\"W{i % 3}\"",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1298,
      "alignment": 0.6507950931394821,
      "coherence": 0.6507950931394821,
      "comment_phi_k": 4.263095238095238,
      "code_phi_k": 1.975595238095238
    },
    {
      "comment": "# Compute overall coherence",
      "code": "                    \"witness\": f\"W{i % 3}\"  # Cycle through W0, W1, W2\n                })\n            \n            # Compute overall coherence\n            coherence = coherence_sum / len(ions_sorted) if ions_sorted else 0.0\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1301,
      "alignment": 0.5702826555559667,
      "coherence": 0.5702826555559667,
      "comment_phi_k": 5.709325396825397,
      "code_phi_k": 23.16310633810634
    },
    {
      "comment": "# Compute coherence for each step",
      "code": "            if not plan:\n                return {\"optimal_plan\": [], \"coherence\": 0.0}\n            \n            # Compute coherence for each step\n            step_coherences = []\n            for step in plan:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1324,
      "alignment": 0.6059919788158761,
      "coherence": 0.6059919788158761,
      "comment_phi_k": 7.812896825396826,
      "code_phi_k": 22.334486346986345
    },
    {
      "comment": "# Optimize: try different orderings",
      "code": "                else:\n                    step_coherences.append(0.0)\n            \n            # Optimize: try different orderings\n            # Simple: sort by coherence (highest first)\n            plan_with_coherence = list(zip(plan, step_coherences))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1334,
      "alignment": 0.5831174716895711,
      "coherence": 0.5831174716895711,
      "comment_phi_k": 7.00515873015873,
      "code_phi_k": 24.57263415549019
    },
    {
      "comment": "# Simple: sort by coherence (highest first)",
      "code": "                    step_coherences.append(0.0)\n            \n            # Optimize: try different orderings\n            # Simple: sort by coherence (highest first)\n            plan_with_coherence = list(zip(plan, step_coherences))\n            plan_with_coherence.sort(key=lambda x: x[1], reverse=True)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1335,
      "alignment": 0.5828754279395497,
      "coherence": 0.5828754279395497,
      "comment_phi_k": 8.028968253968255,
      "code_phi_k": 28.234474459416173
    },
    {
      "comment": "# Try to extract plan from dict structure",
      "code": "            \"\"\"\n            plan = env.get(\"plan\", env.get(\"optimal_plan\", []))\n            if not isinstance(plan, list):\n                # Try to extract plan from dict structure\n                if isinstance(plan, dict):\n                    plan = plan.get(\"plan\", plan.get(\"optimal_plan\", []))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1357,
      "alignment": 0.5881042817698959,
      "coherence": 0.5881042817698959,
      "comment_phi_k": 9.187896825396825,
      "code_phi_k": 30.665033270393174
    },
    {
      "comment": "# Extract words from plan steps",
      "code": "            if not plan:\n                return \"\"\n            \n            # Extract words from plan steps\n            words = []\n            for step in plan:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1366,
      "alignment": 0.6172244995423251,
      "coherence": 0.6172244995423251,
      "comment_phi_k": 7.013095238095238,
      "code_phi_k": 18.46309523809524
    },
    {
      "comment": "# Also check if step itself has word",
      "code": "                            words.append(word)\n                    elif isinstance(ion, str):\n                        words.append(ion)\n                    # Also check if step itself has word\n                    elif step.get(\"word\"):\n                        words.append(step.get(\"word\"))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1377,
      "alignment": 0.6244854804557421,
      "coherence": 0.6244854804557421,
      "comment_phi_k": 9.741666666666665,
      "code_phi_k": 24.434694578440716
    },
    {
      "comment": "# Join words into output",
      "code": "                elif isinstance(step, str):\n                    words.append(step)\n            \n            # Join words into output\n            output = \" \".join(words)\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1383,
      "alignment": 0.6225700289467527,
      "coherence": 0.6225700289467527,
      "comment_phi_k": 6.591666666666667,
      "code_phi_k": 16.740528425822543
    },
    {
      "comment": "# Capitalize first letter",
      "code": "            # Join words into output\n            output = \" \".join(words)\n            \n            # Capitalize first letter\n            if output:\n                output = output[0].upper() + output[1:] if len(output) > 1 else output.upper()",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1386,
      "alignment": 0.5428437507947717,
      "coherence": 0.5428437507947717,
      "comment_phi_k": 5.001984126984127,
      "code_phi_k": 31.688353313353314
    },
    {
      "comment": "# Compute output field potential",
      "code": "            output = env.get(\"output\", \"\")\n            field_state = env.get(\"field_state\", {})\n            \n            # Compute output field potential\n            output_phi_k = compute_phi_k({\"text\": output})\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1400,
      "alignment": 0.5981375708755688,
      "coherence": 0.5981375708755688,
      "comment_phi_k": 7.2746031746031745,
      "code_phi_k": 22.168948309602335
    },
    {
      "comment": "# Get field state phi_k",
      "code": "            # Compute output field potential\n            output_phi_k = compute_phi_k({\"text\": output})\n            \n            # Get field state phi_k\n            field_phi_k = field_state.get(\"phi_k\", 0.0)\n            if isinstance(field_phi_k, dict):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1403,
      "alignment": 0.5517778851217003,
      "coherence": 0.5517778851217003,
      "comment_phi_k": 5.316666666666666,
      "code_phi_k": 28.328880972398775
    },
    {
      "comment": "# Check coherence: output should align with field state",
      "code": "            if isinstance(field_phi_k, dict):\n                field_phi_k = field_phi_k.get(\"discourse\", {}).get(\"phi_k\", 0.0)\n            \n            # Check coherence: output should align with field state\n            coherence = 1.0 - abs(output_phi_k - float(field_phi_k)) / (abs(field_phi_k) + 1.0)\n            coherence = max(0.0, min(1.0, coherence))  # Clamp to [0, 1]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1408,
      "alignment": 0.5993764511610091,
      "coherence": 0.5993764511610091,
      "comment_phi_k": 12.895039682539682,
      "code_phi_k": 38.88739752830662
    },
    {
      "comment": "Clamp to [0, 1]",
      "code": "coherence = max(0.0, min(1.0, coherence))",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1410,
      "alignment": 0.6145935936330326,
      "coherence": 0.6145935936330326,
      "comment_phi_k": 2.3083333333333336,
      "code_phi_k": 6.190079365079366
    },
    {
      "comment": "# Step 1: Extract ions from intent",
      "code": "            \"\"\"\n            intent = env.get(\"intent\", env.get(\"input\", \"\"))\n            \n            # Step 1: Extract ions from intent\n            ions = extract_ions({\"intent\": intent})\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1429,
      "alignment": 0.6240821108566612,
      "coherence": 0.6240821108566612,
      "comment_phi_k": 7.954761904761904,
      "code_phi_k": 20.00459440370431
    },
    {
      "comment": "# Step 2: Composer plan with zeros.on.critical",
      "code": "                    \"zeros\": []\n                }\n            \n            # Step 2: Composer plan with zeros.on.critical\n            plan_result = composer_plan({\"ions\": ions})\n            plan_steps = plan_result.get(\"plan\", [])",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1443,
      "alignment": 0.63585429469176,
      "coherence": 0.63585429469176,
      "comment_phi_k": 7.62463737243149,
      "code_phi_k": 17.843228400426543
    },
    {
      "comment": "# Step 3: Maximize coherence",
      "code": "                    \"zeros\": plan_result.get(\"zeros\", [])\n                }\n            \n            # Step 3: Maximize coherence\n            optimal_result = coherence_maximization({\"plan\": plan_steps})\n            optimal_plan = optimal_result.get(\"optimal_plan\", plan_steps)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1458,
      "alignment": 0.5671555107502125,
      "coherence": 0.5671555107502125,
      "comment_phi_k": 5.016468253968254,
      "code_phi_k": 21.183053951626636
    },
    {
      "comment": "# Step 4: Execute ion chain",
      "code": "            optimal_result = coherence_maximization({\"plan\": plan_steps})\n            optimal_plan = optimal_result.get(\"optimal_plan\", plan_steps)\n            \n            # Step 4: Execute ion chain\n            output = execute_ion_chain({\"plan\": optimal_plan, \"optimal_plan\": optimal_plan})\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1462,
      "alignment": 0.559289665466879,
      "coherence": 0.559289665466879,
      "comment_phi_k": 6.442857142857143,
      "code_phi_k": 30.388292695735014
    },
    {
      "comment": "# If output is empty, try direct extraction from plan steps",
      "code": "            # Step 4: Execute ion chain\n            output = execute_ion_chain({\"plan\": optimal_plan, \"optimal_plan\": optimal_plan})\n            \n            # If output is empty, try direct extraction from plan steps\n            if not output:\n                words = []",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1465,
      "alignment": 0.6202448381528028,
      "coherence": 0.6202448381528028,
      "comment_phi_k": 14.640873015873018,
      "code_phi_k": 37.76014860033402
    },
    {
      "comment": "# Fallback: extract directly from ions",
      "code": "                            if word:\n                                words.append(word)\n                if not words:\n                    # Fallback: extract directly from ions\n                    words = [ion.get(\"word\", \"\") for ion in ions if isinstance(ion, dict) and ion.get(\"word\")]\n                output = \" \".join(words)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1476,
      "alignment": 0.5631475026020494,
      "coherence": 0.5631475026020494,
      "comment_phi_k": 8.322619047619048,
      "code_phi_k": 37.11043143947557
    },
    {
      "comment": "# Step 5: Check coherence with field state (if provided)",
      "code": "                if output:\n                    output = output[0].upper() + output[1:] if len(output) > 1 else output.upper()\n            \n            # Step 5: Check coherence with field state (if provided)\n            field_state = env.get(\"field_state\", {})\n            coherence_result = check_coherence({",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1482,
      "alignment": 0.5895565078999743,
      "coherence": 0.5895565078999743,
      "comment_phi_k": 11.067063492063491,
      "code_phi_k": 36.42761122606324
    },
    {
      "comment": "Lower threshold for generation",
      "code": "\"threshold\": 0.3",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1487,
      "alignment": 0.5488157035305442,
      "coherence": 0.5488157035305442,
      "comment_phi_k": 6.335119047619048,
      "code_phi_k": 1.126984126984127
    },
    {
      "comment": "# For generation, always return output even if coherence check fails",
      "code": "                \"threshold\": 0.3  # Lower threshold for generation\n            })\n            \n            # For generation, always return output even if coherence check fails\n            # (coherence check is more relevant when checking against existing field)\n            final_output = coherence_result.get(\"coherent_output\", output)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1490,
      "alignment": 0.6078947460104934,
      "coherence": 0.6078947460104934,
      "comment_phi_k": 16.4859126984127,
      "code_phi_k": 46.442019111746575
    },
    {
      "comment": "# (coherence check is more relevant when checking against existing field)",
      "code": "            })\n            \n            # For generation, always return output even if coherence check fails\n            # (coherence check is more relevant when checking against existing field)\n            final_output = coherence_result.get(\"coherent_output\", output)\n            if not final_output and output:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1491,
      "alignment": 0.600618343444336,
      "coherence": 0.600618343444336,
      "comment_phi_k": 15.717460317460318,
      "code_phi_k": 46.910904393131865
    },
    {
      "comment": "Use generated output even if coherence low",
      "code": "final_output = output",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1494,
      "alignment": 0.606729822372229,
      "coherence": 0.606729822372229,
      "comment_phi_k": 11.647023809523809,
      "code_phi_k": 4.097655122655123
    },
    {
      "comment": "# Zeta Grammar primitives",
      "code": "            \"project \u03b6 features\": project_zeta_features,\n            \"chain_zeros_critical\": chain_zeros_critical,\n            \"chain with zeros.on.critical\": chain_zeros_critical,\n            # Zeta Grammar primitives\n            \"match_vowel\": match_vowel,\n            \"match_consonant\": match_consonant,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1525,
      "alignment": 0.5484357965133837,
      "coherence": 0.5484357965133837,
      "comment_phi_k": 4.821230158730159,
      "code_phi_k": 27.295258802514997
    },
    {
      "comment": "# Document field primitives",
      "code": "            \"negative_trend\": negative_trend,\n            \"compute_potential\": compute_potential,\n            \"emit_binding_invitation\": emit_binding_invitation,\n            # Document field primitives\n            \"compute_movement\": compute_movement,\n            \"interpret_movement\": interpret_movement,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1545,
      "alignment": 0.5576108186918531,
      "coherence": 0.5576108186918531,
      "comment_phi_k": 5.233730158730159,
      "code_phi_k": 25.328441991351703
    },
    {
      "comment": "# Zeta zero solver & field computation",
      "code": "            \"check_basin\": check_basin,\n            \"check_distance\": check_distance,\n            \"compare_threshold\": compare_threshold,\n            # Zeta zero solver & field computation\n            \"compute_phi_k\": compute_phi_k,\n            \"zeta_zero_solver\": zeta_zero_solver,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1553,
      "alignment": 0.5960417403227877,
      "coherence": 0.5960417403227877,
      "comment_phi_k": 8.003589466089466,
      "code_phi_k": 24.835417278799625
    },
    {
      "comment": "# Query resolution helpers (defined above)",
      "code": "            \"aperture.chain\": aperture_chain,\n            \"compare_zeros\": compare_zeros,\n            \"zeros.compare\": compare_zeros,\n            # Query resolution helpers (defined above)\n            \"perturb_field\": lambda env: query_perturb_field(env, self),\n            \"zeros.movement\": lambda env: zeros_movement(env, self),",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1561,
      "alignment": 0.5667362990043059,
      "coherence": 0.5667362990043059,
      "comment_phi_k": 8.350992063492065,
      "code_phi_k": 35.459041074276975
    },
    {
      "comment": "# Witness chain helpers",
      "code": "            \"zeros.movement\": lambda env: zeros_movement(env, self),\n            \"extract_provenance\": extract_provenance,\n            \"extract_history\": extract_history,\n            # Witness chain helpers\n            \"witness.W0\": witness_W0,\n            \"witness.W1\": witness_W1,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1566,
      "alignment": 0.5492562339253845,
      "coherence": 0.5492562339253845,
      "comment_phi_k": 4.726190476190476,
      "code_phi_k": 26.350873533071674
    },
    {
      "comment": "# Composer planning & generation",
      "code": "            \"witness.W1\": witness_W1,\n            \"witness.W2\": witness_W2,\n            \"witness.chain\": witness_chain_build,\n            # Composer planning & generation\n            \"extract_ions\": extract_ions,\n            \"composer.plan\": composer_plan,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1571,
      "alignment": 0.5711014101404167,
      "coherence": 0.5711014101404167,
      "comment_phi_k": 5.43015873015873,
      "code_phi_k": 21.808085816831948
    },
    {
      "comment": "# Literal string",
      "code": "        \"\"\"\n        t = token.strip()\n        \n        # Literal string\n        if (t.startswith('\"') and t.endswith('\"')) or (t.startswith(\"'\") and t.endswith(\"'\")):\n            return t[1:-1]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1604,
      "alignment": 0.5475344846704822,
      "coherence": 0.5475344846704822,
      "comment_phi_k": 3.104761904761905,
      "code_phi_k": 17.881378343878342
    },
    {
      "comment": "# Combined expression with '+'",
      "code": "        if (t.startswith('\"') and t.endswith('\"')) or (t.startswith(\"'\") and t.endswith(\"'\")):\n            return t[1:-1]\n        \n        # Combined expression with '+'\n        if \" + \" in t:\n            parts = [p.strip() for p in t.split(\"+\")]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1608,
      "alignment": 0.5541616483078662,
      "coherence": 0.5541616483078662,
      "comment_phi_k": 5.254563492063492,
      "code_phi_k": 26.881360306360307
    },
    {
      "comment": "# Combine heuristically",
      "code": "        if \" + \" in t:\n            parts = [p.strip() for p in t.split(\"+\")]\n            values = [self._evaluate_step_token(p, env, last_result) for p in parts]\n            # Combine heuristically\n            if all(isinstance(v, (int, float)) for v in values):\n                return sum(values)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1612,
      "alignment": 0.5274588656470198,
      "coherence": 0.5274588656470198,
      "comment_phi_k": 3.937090687090686,
      "code_phi_k": 37.81389614664736
    },
    {
      "comment": "# Primitive call - SPEC: primitives receive env + last_result as input",
      "code": "                return \"\".join(values)\n            return tuple(values)\n        \n        # Primitive call - SPEC: primitives receive env + last_result as input\n        if t in self.primitives:\n            prim_env = env.copy()",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1619,
      "alignment": 0.6648737528001316,
      "coherence": 0.6648737528001316,
      "comment_phi_k": 14.229383116883117,
      "code_phi_k": 28.690871628371628
    },
    {
      "comment": "# SPEC: last_result flows as input to next step",
      "code": "        # Primitive call - SPEC: primitives receive env + last_result as input\n        if t in self.primitives:\n            prim_env = env.copy()\n            # SPEC: last_result flows as input to next step\n            if last_result is not None:\n                # Map to common parameter names",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1622,
      "alignment": 0.5643624525560198,
      "coherence": 0.5643624525560198,
      "comment_phi_k": 10.820256132756132,
      "code_phi_k": 47.4387321012321
    },
    {
      "comment": "# Map to common parameter names",
      "code": "            prim_env = env.copy()\n            # SPEC: last_result flows as input to next step\n            if last_result is not None:\n                # Map to common parameter names\n                if \"path\" not in prim_env and isinstance(last_result, (str, Path)):\n                    prim_env[\"path\"] = last_result",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1624,
      "alignment": 0.5449667157543364,
      "coherence": 0.5449667157543364,
      "comment_phi_k": 7.193650793650794,
      "code_phi_k": 43.591133814585824
    },
    {
      "comment": "# Variable lookup",
      "code": "            if prim is not None:\n                return prim\n        \n        # Variable lookup\n        if t in env:\n            return env[t]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1636,
      "alignment": 0.5492903225806451,
      "coherence": 0.5492903225806451,
      "comment_phi_k": 3.6380952380952376,
      "code_phi_k": 20.271428571428576
    },
    {
      "comment": "# Assignment/bind last result",
      "code": "        if t in env:\n            return env[t]\n        \n        # Assignment/bind last result\n        if last_result is not None and t.replace(\"_\", \"\").replace(\".\", \"\").isalnum():\n            env[t] = last_result",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1640,
      "alignment": 0.5533842523695096,
      "coherence": 0.5533842523695096,
      "comment_phi_k": 5.231288156288157,
      "code_phi_k": 27.113918026418027
    },
    {
      "comment": "# Fallback: return token",
      "code": "            env[t] = last_result\n            return last_result\n        \n        # Fallback: return token\n        return t\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1645,
      "alignment": 0.6073903225572566,
      "coherence": 0.6073903225572566,
      "comment_phi_k": 4.808928571428572,
      "code_phi_k": 13.599440836940838
    },
    {
      "comment": "# Follow opic.execute_chain structure:",
      "code": "        \"\"\"\n        inputs = inputs or {}\n        \n        # Follow opic.execute_chain structure:\n        # Step 1: Parse chain (implements opic.parse_chain structure)\n        steps = self._parse_chain(chain_str)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1659,
      "alignment": 0.5695126934153639,
      "coherence": 0.5695126934153639,
      "comment_phi_k": 5.81538918597742,
      "code_phi_k": 23.82254086152676
    },
    {
      "comment": "# Step 1: Parse chain (implements opic.parse_chain structure)",
      "code": "        inputs = inputs or {}\n        \n        # Follow opic.execute_chain structure:\n        # Step 1: Parse chain (implements opic.parse_chain structure)\n        steps = self._parse_chain(chain_str)\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1660,
      "alignment": 0.6262916554239253,
      "coherence": 0.6262916554239253,
      "comment_phi_k": 9.607626401376402,
      "code_phi_k": 23.82254086152676
    },
    {
      "comment": "# Step 2: Resolve steps (implements opic.resolve_steps structure)",
      "code": "        # Step 1: Parse chain (implements opic.parse_chain structure)\n        steps = self._parse_chain(chain_str)\n        \n        # Step 2: Resolve steps (implements opic.resolve_steps structure)\n        resolved_steps = self._resolve_steps(steps, inputs)\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1663,
      "alignment": 0.6022235837235026,
      "coherence": 0.6022235837235026,
      "comment_phi_k": 9.807424030218147,
      "code_phi_k": 28.888940455019675
    },
    {
      "comment": "# Step 3: Execute steps (implements opic.execute_steps structure)",
      "code": "        # Step 2: Resolve steps (implements opic.resolve_steps structure)\n        resolved_steps = self._resolve_steps(steps, inputs)\n        \n        # Step 3: Execute steps (implements opic.execute_steps structure)\n        result = self._execute_steps(resolved_steps, inputs)\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1666,
      "alignment": 0.5958488609687658,
      "coherence": 0.5958488609687658,
      "comment_phi_k": 10.267939903234021,
      "code_phi_k": 31.915560779754323
    },
    {
      "comment": "# opic.remove_braces: strip \"{ }\"",
      "code": "        Parse chain following opic.parse_chain structure:\n        {chain -> remove_braces -> split_arrows -> steps}\n        \"\"\"\n        # opic.remove_braces: strip \"{ }\"\n        chain_body = chain_str.strip()\n        if chain_body.startswith(\"{\") and chain_body.endswith(\"}\"):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1676,
      "alignment": 0.5346990380084926,
      "coherence": 0.5346990380084926,
      "comment_phi_k": 3.7744044762427107,
      "code_phi_k": 29.08107195951623
    },
    {
      "comment": "# opic.split_arrows: split \"->\" and trim each",
      "code": "        if chain_body.startswith(\"{\") and chain_body.endswith(\"}\"):\n            chain_body = chain_body[1:-1].strip()\n        \n        # opic.split_arrows: split \"->\" and trim each\n        steps = [s.strip() for s in chain_body.split(\"->\")]\n        return steps",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1681,
      "alignment": 0.5827305568542309,
      "coherence": 0.5827305568542309,
      "comment_phi_k": 8.054877271421388,
      "code_phi_k": 28.368134436942487
    },
    {
      "comment": "# opic.find_voice: {step_name + voices -> lookup -> voice_body}",
      "code": "        \"\"\"\n        resolved = []\n        for step in steps:\n            # opic.find_voice: {step_name + voices -> lookup -> voice_body}\n            if step in inputs:\n                resolved.append(inputs[step])",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1692,
      "alignment": 0.6161589719063447,
      "coherence": 0.6161589719063447,
      "comment_phi_k": 8.922972860472859,
      "code_phi_k": 23.665713004459136
    },
    {
      "comment": "# opic.resolve_body: {voice_body -> if_chain_recurse -> if_string_return}",
      "code": "                resolved.append(inputs[step])\n            elif step in self.voices:\n                voice_body = self.voices[step]\n                # opic.resolve_body: {voice_body -> if_chain_recurse -> if_string_return}\n                resolved.append(voice_body)\n            elif step in self.primitives:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1697,
      "alignment": 0.581342853605047,
      "coherence": 0.581342853605047,
      "comment_phi_k": 8.179608789902908,
      "code_phi_k": 29.22910190969771
    },
    {
      "comment": "# Primitive: leave as string so it can be called during execution",
      "code": "                # opic.resolve_body: {voice_body -> if_chain_recurse -> if_string_return}\n                resolved.append(voice_body)\n            elif step in self.primitives:\n                # Primitive: leave as string so it can be called during execution\n                resolved.append(step)\n            else:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1700,
      "alignment": 0.639027507690732,
      "coherence": 0.639027507690732,
      "comment_phi_k": 15.973214285714283,
      "code_phi_k": 36.70972559443518
    },
    {
      "comment": "# Try discovered voices",
      "code": "                # Primitive: leave as string so it can be called during execution\n                resolved.append(step)\n            else:\n                # Try discovered voices\n                discovered = self._discover_relevant_voices(step)\n                if discovered and discovered[0] in self.voices:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1703,
      "alignment": 0.5317987339100413,
      "coherence": 0.5317987339100413,
      "comment_phi_k": 4.599801587301587,
      "code_phi_k": 38.4633027730694
    },
    {
      "comment": "# Leave as string - might be primitive or variable name",
      "code": "                if discovered and discovered[0] in self.voices:\n                    resolved.append(self.voices[discovered[0]])\n                else:\n                    # Leave as string - might be primitive or variable name\n                    resolved.append(step)\n        return resolved",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1708,
      "alignment": 0.6243958178849237,
      "coherence": 0.6243958178849237,
      "comment_phi_k": 13.021230158730157,
      "code_phi_k": 32.6795618738141
    },
    {
      "comment": "Initial available energy",
      "code": "available_energy = 1.0",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1726,
      "alignment": 0.6312789171888212,
      "coherence": 0.6312789171888212,
      "comment_phi_k": 6.38313492063492,
      "code_phi_k": 2.654836136086136
    },
    {
      "comment": "Stop when energy change < threshold",
      "code": "equilibrium_threshold = 0.001",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1727,
      "alignment": 0.6177646296079872,
      "coherence": 0.6177646296079872,
      "comment_phi_k": 7.3942460317460315,
      "code_phi_k": 2.8191340307439376
    },
    {
      "comment": "Safety limit",
      "code": "max_iterations = 100",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1728,
      "alignment": 0.7476805613851957,
      "coherence": 0.7476805613851957,
      "comment_phi_k": 3.116666666666667,
      "code_phi_k": 2.064886502386502
    },
    {
      "comment": "# Compute binding energy needed for next step BEFORE execution",
      "code": "            if iteration > max_iterations:\n                break\n            \n            # Compute binding energy needed for next step BEFORE execution\n            # SPEC: stop when needed > available\n            if result is not None and step_idx < len(resolved_steps) - 1:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1736,
      "alignment": 0.608542104985666,
      "coherence": 0.608542104985666,
      "comment_phi_k": 14.662698412698411,
      "code_phi_k": 41.10326291355702
    },
    {
      "comment": "# SPEC: stop when needed > available",
      "code": "                break\n            \n            # Compute binding energy needed for next step BEFORE execution\n            # SPEC: stop when needed > available\n            if result is not None and step_idx < len(resolved_steps) - 1:\n                # Estimate binding energy needed to bind next step",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1737,
      "alignment": 0.5439978702212506,
      "coherence": 0.5439978702212506,
      "comment_phi_k": 7.711706349206349,
      "code_phi_k": 47.67448752228164
    },
    {
      "comment": "# Estimate binding energy needed to bind next step",
      "code": "            # Compute binding energy needed for next step BEFORE execution\n            # SPEC: stop when needed > available\n            if result is not None and step_idx < len(resolved_steps) - 1:\n                # Estimate binding energy needed to bind next step\n                next_step = resolved_steps[step_idx + 1] if step_idx + 1 < len(resolved_steps) else None\n                if next_step is not None:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1739,
      "alignment": 0.5519910281301359,
      "coherence": 0.5519910281301359,
      "comment_phi_k": 12.201190476190474,
      "code_phi_k": 64.77028746677337
    },
    {
      "comment": "# If needed energy exceeds available, stop to prevent recursion",
      "code": "                        result, next_step,\n                        self._get_step_distance(str(result), str(next_step))\n                    ))\n                    # If needed energy exceeds available, stop to prevent recursion\n                    if needed_energy > available_energy:\n                        # Insufficient available energy - stop execution",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1747,
      "alignment": 0.6220436366624565,
      "coherence": 0.6220436366624565,
      "comment_phi_k": 14.944642857142858,
      "code_phi_k": 38.085639881372366
    },
    {
      "comment": "# Insufficient available energy - stop execution",
      "code": "                    ))\n                    # If needed energy exceeds available, stop to prevent recursion\n                    if needed_energy > available_energy:\n                        # Insufficient available energy - stop execution\n                        break\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1749,
      "alignment": 0.5919847110439244,
      "coherence": 0.5919847110439244,
      "comment_phi_k": 10.113708513708513,
      "code_phi_k": 32.54432581307581
    },
    {
      "comment": "# Compute energy coupling for flow direction (before execution)",
      "code": "                        # Insufficient available energy - stop execution\n                        break\n            \n            # Compute energy coupling for flow direction (before execution)\n            if result is not None and previous_charge is not None:\n                # Use field.energy_exchange to compute flow",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1752,
      "alignment": 0.5825411084746319,
      "coherence": 0.5825411084746319,
      "comment_phi_k": 13.216468253968253,
      "code_phi_k": 46.638191617893625
    },
    {
      "comment": "# Use field.energy_exchange to compute flow",
      "code": "            \n            # Compute energy coupling for flow direction (before execution)\n            if result is not None and previous_charge is not None:\n                # Use field.energy_exchange to compute flow\n                energy = self._compute_energy_coupling(\n                    previous_charge, self._get_step_charge(step_body),",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1754,
      "alignment": 0.5495462721314387,
      "coherence": 0.5495462721314387,
      "comment_phi_k": 7.841360671062682,
      "code_phi_k": 43.486526229349266
    },
    {
      "comment": "# Energy determines flow strength - higher energy = stronger coupling",
      "code": "                    previous_state, step_body,\n                    self._get_step_distance(str(previous_state), str(step_body))\n                )\n                # Energy determines flow strength - higher energy = stronger coupling\n                flow_bias_forward = energy > 0\n            else:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1760,
      "alignment": 0.6702439688797177,
      "coherence": 0.6702439688797177,
      "comment_phi_k": 13.431349206349205,
      "code_phi_k": 26.439353061115803
    },
    {
      "comment": "# Execute step with energy-coupled flow",
      "code": "            else:\n                flow_bias_forward = True\n            \n            # Execute step with energy-coupled flow\n            if isinstance(step_body, str) and step_body.startswith(\"{\") and step_body.endswith(\"}\"):\n                # Recurse into nested chain",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1765,
      "alignment": 0.5762631493426376,
      "coherence": 0.5762631493426376,
      "comment_phi_k": 8.207893495393495,
      "code_phi_k": 31.01043292792519
    },
    {
      "comment": "# Recurse into nested chain",
      "code": "            \n            # Execute step with energy-coupled flow\n            if isinstance(step_body, str) and step_body.startswith(\"{\") and step_body.endswith(\"}\"):\n                # Recurse into nested chain\n                step_inputs = {\"input\": result, **env} if result is not None else env.copy()\n                candidate_value = self._execute_opic_chain(step_body, step_inputs)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1767,
      "alignment": 0.5364778424234035,
      "coherence": 0.5364778424234035,
      "comment_phi_k": 6.417857142857144,
      "code_phi_k": 47.193555378328114
    },
    {
      "comment": "# Evaluate step: primitive call, variable lookup, or literal",
      "code": "                step_inputs = {\"input\": result, **env} if result is not None else env.copy()\n                candidate_value = self._execute_opic_chain(step_body, step_inputs)\n            elif isinstance(step_body, str):\n                # Evaluate step: primitive call, variable lookup, or literal\n                candidate_value = self._evaluate_step_token(step_body, env, result)\n            else:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1771,
      "alignment": 0.5782975172176585,
      "coherence": 0.5782975172176585,
      "comment_phi_k": 13.222420634920635,
      "code_phi_k": 48.82972855656282
    },
    {
      "comment": "# Small composable scoring: decide whether to accept candidate_value",
      "code": "            else:\n                candidate_value = step_body\n            \n            # Small composable scoring: decide whether to accept candidate_value\n            # SPEC: forward flow by default - accept new values unless clearly worse\n            step_score = self._score_candidate(candidate_value, env, result)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1776,
      "alignment": 0.5927468454527572,
      "coherence": 0.5927468454527572,
      "comment_phi_k": 13.083916083916083,
      "code_phi_k": 41.80977771831751
    },
    {
      "comment": "# SPEC: forward flow by default - accept new values unless clearly worse",
      "code": "                candidate_value = step_body\n            \n            # Small composable scoring: decide whether to accept candidate_value\n            # SPEC: forward flow by default - accept new values unless clearly worse\n            step_score = self._score_candidate(candidate_value, env, result)\n            if result is None:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1777,
      "alignment": 0.6080786678699841,
      "coherence": 0.6080786678699841,
      "comment_phi_k": 16.230952380952377,
      "code_phi_k": 45.65977771831751
    },
    {
      "comment": "# Bias acceptance by flow direction and score",
      "code": "            if result is None:\n                result = candidate_value\n            else:\n                # Bias acceptance by flow direction and score\n                bias = 0.1 if not flow_bias_forward else 0.0\n                accept = (step_score - bias) >= 0.5",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1782,
      "alignment": 0.5922601399409008,
      "coherence": 0.5922601399409008,
      "comment_phi_k": 10.375992063492063,
      "code_phi_k": 33.30412524566937
    },
    {
      "comment": "# Also accept if candidate is clearly better type (list > string for file operations)",
      "code": "                bias = 0.1 if not flow_bias_forward else 0.0\n                accept = (step_score - bias) >= 0.5\n                \n                # Also accept if candidate is clearly better type (list > string for file operations)\n                if not accept:\n                    if isinstance(candidate_value, list) and isinstance(result, str):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1786,
      "alignment": 0.6338704147120499,
      "coherence": 0.6338704147120499,
      "comment_phi_k": 19.344642857142855,
      "code_phi_k": 45.79800853194008
    },
    {
      "comment": "Lists are better than strings for file operations",
      "code": "accept = True",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1789,
      "alignment": 0.5755310334438084,
      "coherence": 0.5755310334438084,
      "comment_phi_k": 12.1281746031746,
      "code_phi_k": 3.1833333333333336
    },
    {
      "comment": "Dicts are better than strings for structured data",
      "code": "accept = True",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1791,
      "alignment": 0.5804856024882111,
      "coherence": 0.5804856024882111,
      "comment_phi_k": 11.47956349206349,
      "code_phi_k": 3.1833333333333336
    },
    {
      "comment": "# Combine numerics by weighted mix; strings by choose-best",
      "code": "                        accept = True  # Dicts are better than strings for structured data\n                \n                if accept:\n                    # Combine numerics by weighted mix; strings by choose-best\n                    if isinstance(result, (int, float)) and isinstance(candidate_value, (int, float)):\n                        alpha = max(0.0, min(1.0, step_score))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1794,
      "alignment": 0.5680931652957001,
      "coherence": 0.5680931652957001,
      "comment_phi_k": 11.339303751803753,
      "code_phi_k": 47.301230106117515
    },
    {
      "comment": "# Update environment bindings",
      "code": "                    else:\n                        result = candidate_value\n            \n            # Update environment bindings\n            env[\"last\"] = result\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1801,
      "alignment": 0.6255277126106269,
      "coherence": 0.6255277126106269,
      "comment_phi_k": 5.916089466089466,
      "code_phi_k": 14.74048174048174
    },
    {
      "comment": "# Update available energy AFTER execution: SPEC - binding energy curbs recursion",
      "code": "            # Update environment bindings\n            env[\"last\"] = result\n            \n            # Update available energy AFTER execution: SPEC - binding energy curbs recursion\n            # Available energy = binding energy actually used in this step\n            if result is not None and previous_state is not None and step_idx > 0:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1804,
      "alignment": 0.5904890283306832,
      "coherence": 0.5904890283306832,
      "comment_phi_k": 18.31329365079365,
      "code_phi_k": 59.751989676989666
    },
    {
      "comment": "# Available energy = binding energy actually used in this step",
      "code": "            env[\"last\"] = result\n            \n            # Update available energy AFTER execution: SPEC - binding energy curbs recursion\n            # Available energy = binding energy actually used in this step\n            if result is not None and previous_state is not None and step_idx > 0:\n                actual_binding_energy = abs(self._compute_energy_coupling(",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1805,
      "alignment": 0.5741305882225226,
      "coherence": 0.5741305882225226,
      "comment_phi_k": 15.23373015873016,
      "code_phi_k": 58.99150854301225
    },
    {
      "comment": "# Update available energy: subtract what was used, add what was generated",
      "code": "                    previous_state, result,\n                    self._get_step_distance(str(previous_state), str(result))\n                ))\n                # Update available energy: subtract what was used, add what was generated\n                # If binding was strong, we gain energy; if weak, we lose it\n                energy_change = actual_binding_energy - available_energy",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1812,
      "alignment": 0.610418486726505,
      "coherence": 0.610418486726505,
      "comment_phi_k": 17.672619047619047,
      "code_phi_k": 48.8491270590477
    },
    {
      "comment": "# If binding was strong, we gain energy; if weak, we lose it",
      "code": "                    self._get_step_distance(str(previous_state), str(result))\n                ))\n                # Update available energy: subtract what was used, add what was generated\n                # If binding was strong, we gain energy; if weak, we lose it\n                energy_change = actual_binding_energy - available_energy\n                available_energy = max(0.0, available_energy + energy_change * 0.1)  # Damped update",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1813,
      "alignment": 0.5817210057073788,
      "coherence": 0.5817210057073788,
      "comment_phi_k": 16.13809523809524,
      "code_phi_k": 57.438530710951355
    },
    {
      "comment": "Damped update",
      "code": "available_energy = max(0.0, available_energy + energy_change * 0.1)",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1815,
      "alignment": 0.6253703556425649,
      "coherence": 0.6253703556425649,
      "comment_phi_k": 3.5083333333333337,
      "code_phi_k": 8.750105450105451
    },
    {
      "comment": "# Check equilibrium: SPEC flow.equilibrium - stop when result stabilizes",
      "code": "                energy_change = actual_binding_energy - available_energy\n                available_energy = max(0.0, available_energy + energy_change * 0.1)  # Damped update\n            \n            # Check equilibrium: SPEC flow.equilibrium - stop when result stabilizes\n            # Equilibrium = perfect resonance, no change in state\n            if step_idx > 0 and step_idx < len(resolved_steps) - 1:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1817,
      "alignment": 0.571647679115614,
      "coherence": 0.571647679115614,
      "comment_phi_k": 12.9548846986347,
      "code_phi_k": 51.680876914623035
    },
    {
      "comment": "# Equilibrium = perfect resonance, no change in state",
      "code": "                available_energy = max(0.0, available_energy + energy_change * 0.1)  # Damped update\n            \n            # Check equilibrium: SPEC flow.equilibrium - stop when result stabilizes\n            # Equilibrium = perfect resonance, no change in state\n            if step_idx > 0 and step_idx < len(resolved_steps) - 1:\n                if result is not None and previous_state is not None:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1818,
      "alignment": 0.5532698212602444,
      "coherence": 0.5532698212602444,
      "comment_phi_k": 11.19862914862915,
      "code_phi_k": 58.15547528451939
    },
    {
      "comment": "# Check if result has stabilized (no meaningful change)",
      "code": "            # Equilibrium = perfect resonance, no change in state\n            if step_idx > 0 and step_idx < len(resolved_steps) - 1:\n                if result is not None and previous_state is not None:\n                    # Check if result has stabilized (no meaningful change)\n                    if isinstance(result, (int, float)) and isinstance(previous_state, (int, float)):\n                        if abs(result - previous_state) < equilibrium_threshold:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1821,
      "alignment": 0.5476700098964835,
      "coherence": 0.5476700098964835,
      "comment_phi_k": 11.278174603174602,
      "code_phi_k": 64.78620426078983
    },
    {
      "comment": "# Equilibrium reached - stop execution",
      "code": "                    # Check if result has stabilized (no meaningful change)\n                    if isinstance(result, (int, float)) and isinstance(previous_state, (int, float)):\n                        if abs(result - previous_state) < equilibrium_threshold:\n                            # Equilibrium reached - stop execution\n                            break\n                    elif isinstance(result, str) and isinstance(previous_state, str):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1824,
      "alignment": 0.5411359440926985,
      "coherence": 0.5411359440926985,
      "comment_phi_k": 7.8103354978354975,
      "code_phi_k": 51.37177918875219
    },
    {
      "comment": "# Equilibrium reached - stop execution",
      "code": "                            break\n                    elif isinstance(result, str) and isinstance(previous_state, str):\n                        if result == previous_state:\n                            # Equilibrium reached - stop execution\n                            break\n                    elif result == previous_state:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1828,
      "alignment": 0.5713864708394509,
      "coherence": 0.5713864708394509,
      "comment_phi_k": 7.8103354978354975,
      "code_phi_k": 31.257463660145213
    },
    {
      "comment": "# Equilibrium reached - stop execution",
      "code": "                            # Equilibrium reached - stop execution\n                            break\n                    elif result == previous_state:\n                        # Equilibrium reached - stop execution\n                        break\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1831,
      "alignment": 0.597827105890528,
      "coherence": 0.597827105890528,
      "comment_phi_k": 7.8103354978354975,
      "code_phi_k": 23.86470612720613
    },
    {
      "comment": "# Update state for next iteration (after equilibrium check)",
      "code": "                        # Equilibrium reached - stop execution\n                        break\n            \n            # Update state for next iteration (after equilibrium check)\n            previous_charge = self._get_step_charge(result)\n            previous_state = result",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1834,
      "alignment": 0.6374548627844434,
      "coherence": 0.6374548627844434,
      "comment_phi_k": 12.988906926406926,
      "code_phi_k": 30.11840292430059
    },
    {
      "comment": "# Skip recursive call to field.energy_exchange to avoid infinite recursion",
      "code": "        \n        Executes opic's native field.energy_exchange voice for actual computation\n        \"\"\"\n        # Skip recursive call to field.energy_exchange to avoid infinite recursion\n        # Use direct computation instead\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1847,
      "alignment": 0.6253676337430508,
      "coherence": 0.6253676337430508,
      "comment_phi_k": 14.734813052015065,
      "code_phi_k": 36.75061456001858
    },
    {
      "comment": "# Use direct computation instead",
      "code": "        Executes opic's native field.energy_exchange voice for actual computation\n        \"\"\"\n        # Skip recursive call to field.energy_exchange to avoid infinite recursion\n        # Use direct computation instead\n        \n        # Fallback: Direct computation following coulomb_yukawa structure",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1848,
      "alignment": 0.5407337605129705,
      "coherence": 0.5407337605129705,
      "comment_phi_k": 7.2000180375180385,
      "code_phi_k": 47.78950899891302
    },
    {
      "comment": "# Fallback: Direct computation following coulomb_yukawa structure",
      "code": "        # Skip recursive call to field.energy_exchange to avoid infinite recursion\n        # Use direct computation instead\n        \n        # Fallback: Direct computation following coulomb_yukawa structure\n        # This matches what coulomb.compute_force_mass_spin would compute\n        # E_ij = (q_i * q_j) / (R_ij^D) * exp(-mu * R_ij)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1850,
      "alignment": 0.5637633891456327,
      "coherence": 0.5637633891456327,
      "comment_phi_k": 11.038894438894442,
      "code_phi_k": 48.80013927018696
    },
    {
      "comment": "# This matches what coulomb.compute_force_mass_spin would compute",
      "code": "        # Use direct computation instead\n        \n        # Fallback: Direct computation following coulomb_yukawa structure\n        # This matches what coulomb.compute_force_mass_spin would compute\n        # E_ij = (q_i * q_j) / (R_ij^D) * exp(-mu * R_ij)\n        charge_product = q_i * q_j",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1851,
      "alignment": 0.5763825164022883,
      "coherence": 0.5763825164022883,
      "comment_phi_k": 9.928794694140356,
      "code_phi_k": 37.46134547669114
    },
    {
      "comment": "# E_ij = (q_i * q_j) / (R_ij^D) * exp(-mu * R_ij)",
      "code": "        \n        # Fallback: Direct computation following coulomb_yukawa structure\n        # This matches what coulomb.compute_force_mass_spin would compute\n        # E_ij = (q_i * q_j) / (R_ij^D) * exp(-mu * R_ij)\n        charge_product = q_i * q_j\n        distance_power = R_ij ** D if R_ij > 0 else 1.0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1852,
      "alignment": 0.5424747587111898,
      "coherence": 0.5424747587111898,
      "comment_phi_k": 5.897619047619047,
      "code_phi_k": 37.66130246414813
    },
    {
      "comment": "# If s_i and s_j are embeddings (lists), add semantic energy",
      "code": "        yukawa_factor = 1.0 if mu == 0 else (1.0 / (1.0 + mu * R_ij))\n        energy = (charge_product / distance_power) * yukawa_factor\n        \n        # If s_i and s_j are embeddings (lists), add semantic energy\n        if isinstance(s_i, list) and isinstance(s_j, list) and len(s_i) == len(s_j):\n            # Semantic energy: dot product of embeddings",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1858,
      "alignment": 0.5751996517481496,
      "coherence": 0.5751996517481496,
      "comment_phi_k": 13.916269841269838,
      "code_phi_k": 53.22254412254411
    },
    {
      "comment": "# Semantic energy: dot product of embeddings",
      "code": "        \n        # If s_i and s_j are embeddings (lists), add semantic energy\n        if isinstance(s_i, list) and isinstance(s_j, list) and len(s_i) == len(s_j):\n            # Semantic energy: dot product of embeddings\n            semantic_energy = sum(a * b for a, b in zip(s_i, s_j))\n            # Combine field energy with semantic energy",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1860,
      "alignment": 0.5463144355991846,
      "coherence": 0.5463144355991846,
      "comment_phi_k": 9.837698412698412,
      "code_phi_k": 58.021614496614475
    },
    {
      "comment": "# Combine field energy with semantic energy",
      "code": "        if isinstance(s_i, list) and isinstance(s_j, list) and len(s_i) == len(s_j):\n            # Semantic energy: dot product of embeddings\n            semantic_energy = sum(a * b for a, b in zip(s_i, s_j))\n            # Combine field energy with semantic energy\n            energy = energy * 0.5 + abs(semantic_energy) * 0.5\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1862,
      "alignment": 0.5562016262475732,
      "coherence": 0.5562016262475732,
      "comment_phi_k": 10.156547619047618,
      "code_phi_k": 50.25733844329044
    },
    {
      "comment": "# Simple heuristic: positive charge for forward flow, negative for reverse",
      "code": "        Extract charge from step (q \u2208 {+1, -1} for ions, or computed from step properties)\n        \"\"\"\n        if isinstance(step, str):\n            # Simple heuristic: positive charge for forward flow, negative for reverse\n            if step.startswith(\"+\") or \"forward\" in step.lower():\n                return 1.0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1872,
      "alignment": 0.6015357360205386,
      "coherence": 0.6015357360205386,
      "comment_phi_k": 15.717460317460315,
      "code_phi_k": 46.558061383061386
    },
    {
      "comment": "# Default: neutral charge",
      "code": "                return 1.0\n            elif step.startswith(\"-\") or \"reverse\" in step.lower():\n                return -1.0\n            # Default: neutral charge\n            return 0.0\n        # For non-string steps, return neutral",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1877,
      "alignment": 0.5531360722445949,
      "coherence": 0.5531360722445949,
      "comment_phi_k": 5.042857142857143,
      "code_phi_k": 26.24757603507604
    },
    {
      "comment": "# For non-string steps, return neutral",
      "code": "                return -1.0\n            # Default: neutral charge\n            return 0.0\n        # For non-string steps, return neutral\n        return 0.0\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1879,
      "alignment": 0.6382516370848951,
      "coherence": 0.6382516370848951,
      "comment_phi_k": 7.5234126984127,
      "code_phi_k": 17.36626984126984
    },
    {
      "comment": "Very close",
      "code": "return 0.1",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1889,
      "alignment": 0.7105263157894737,
      "coherence": 0.7105263157894737,
      "comment_phi_k": 2.7,
      "code_phi_k": 1.6
    },
    {
      "comment": "# Use semantic embeddings for distance",
      "code": "            if step1 == step2:\n                return 0.1  # Very close\n            \n            # Use semantic embeddings for distance\n            emb1 = self._get_semantic_embedding(step1)\n            emb2 = self._get_semantic_embedding(step2)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1891,
      "alignment": 0.6083684916905502,
      "coherence": 0.6083684916905502,
      "comment_phi_k": 8.487698412698412,
      "code_phi_k": 23.824490867708008
    },
    {
      "comment": "# Euclidean distance in embedding space",
      "code": "            emb1 = self._get_semantic_embedding(step1)\n            emb2 = self._get_semantic_embedding(step2)\n            \n            # Euclidean distance in embedding space\n            distance = math.sqrt(sum((a - b) ** 2 for a, b in zip(emb1, emb2)))\n            return max(0.1, distance)  # Minimum distance 0.1",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1895,
      "alignment": 0.5725001406449403,
      "coherence": 0.5725001406449403,
      "comment_phi_k": 8.9390873015873,
      "code_phi_k": 35.29392282463998
    },
    {
      "comment": "Minimum distance 0.1",
      "code": "return max(0.1, distance)",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1897,
      "alignment": 0.8176748176748176,
      "coherence": 0.8176748176748176,
      "comment_phi_k": 3.526190476190476,
      "code_phi_k": 4.538095238095238
    },
    {
      "comment": "# Default distance",
      "code": "            distance = math.sqrt(sum((a - b) ** 2 for a, b in zip(emb1, emb2)))\n            return max(0.1, distance)  # Minimum distance 0.1\n        \n        # Default distance\n        return 1.0\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1899,
      "alignment": 0.5396183935519443,
      "coherence": 0.5396183935519443,
      "comment_phi_k": 3.5428571428571427,
      "code_phi_k": 24.12756687756688
    },
    {
      "comment": "# Cache embeddings",
      "code": "        Generate semantic embedding using Field Spec 0.7 principles\n        Uses zeta-trace, Pascal mod 10, and field potential\n        \"\"\"\n        # Cache embeddings\n        cache_key = f\"{text}:{dim}\"\n        if cache_key in self.embedding_cache:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1907,
      "alignment": 0.5265044006216176,
      "coherence": 0.5265044006216176,
      "comment_phi_k": 3.6525793650793648,
      "code_phi_k": 36.27886434386048
    },
    {
      "comment": "# Convert text to embedding using Field Spec operations",
      "code": "        if cache_key in self.embedding_cache:\n            return self.embedding_cache[cache_key]\n        \n        # Convert text to embedding using Field Spec operations\n        # 1. Token quantization (NLP cycle)\n        tokens = text.lower().split()",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1912,
      "alignment": 0.6254177917197303,
      "coherence": 0.6254177917197303,
      "comment_phi_k": 12.9890873015873,
      "code_phi_k": 32.38617976453949
    },
    {
      "comment": "# 1. Token quantization (NLP cycle)",
      "code": "            return self.embedding_cache[cache_key]\n        \n        # Convert text to embedding using Field Spec operations\n        # 1. Token quantization (NLP cycle)\n        tokens = text.lower().split()\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1913,
      "alignment": 0.5592750973064116,
      "coherence": 0.5592750973064116,
      "comment_phi_k": 5.509559884559884,
      "code_phi_k": 25.99202515538876
    },
    {
      "comment": "# 2. Compute field potential for each token",
      "code": "        # 1. Token quantization (NLP cycle)\n        tokens = text.lower().split()\n        \n        # 2. Compute field potential for each token\n        # Using zeta-trace and Pascal mod 10\n        embedding = [0.0] * dim",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1916,
      "alignment": 0.5968566078568477,
      "coherence": 0.5968566078568477,
      "comment_phi_k": 9.674603174603176,
      "code_phi_k": 29.808760398098634
    },
    {
      "comment": "# Using zeta-trace and Pascal mod 10",
      "code": "        tokens = text.lower().split()\n        \n        # 2. Compute field potential for each token\n        # Using zeta-trace and Pascal mod 10\n        embedding = [0.0] * dim\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1917,
      "alignment": 0.5958643781398388,
      "coherence": 0.5958643781398388,
      "comment_phi_k": 7.818650793650795,
      "code_phi_k": 24.29920051353875
    },
    {
      "comment": "# Hash token to get seed",
      "code": "        embedding = [0.0] * dim\n        \n        for i, token in enumerate(tokens):\n            # Hash token to get seed\n            token_hash = int(hashlib.md5(token.encode()).hexdigest(), 16)\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1921,
      "alignment": 0.5870525438720369,
      "coherence": 0.5870525438720369,
      "comment_phi_k": 6.433333333333334,
      "code_phi_k": 21.6920984208209
    },
    {
      "comment": "# Map to embedding dimensions using Pascal mod 10",
      "code": "            # Hash token to get seed\n            token_hash = int(hashlib.md5(token.encode()).hexdigest(), 16)\n            \n            # Map to embedding dimensions using Pascal mod 10\n            for j in range(dim):\n                # Use Pascal mod 10 pattern: (i+j) mod 10",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1924,
      "alignment": 0.5941059599957533,
      "coherence": 0.5941059599957533,
      "comment_phi_k": 10.800992063492062,
      "code_phi_k": 34.09419424166672
    },
    {
      "comment": "# Use Pascal mod 10 pattern: (i+j) mod 10",
      "code": "            \n            # Map to embedding dimensions using Pascal mod 10\n            for j in range(dim):\n                # Use Pascal mod 10 pattern: (i+j) mod 10\n                pascal_val = (i + j) % 10\n                # Use zeta-trace: 7-trace cycle",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1926,
      "alignment": 0.5704805343593956,
      "coherence": 0.5704805343593956,
      "comment_phi_k": 7.7630952380952385,
      "code_phi_k": 31.41785714285714
    },
    {
      "comment": "# Use zeta-trace: 7-trace cycle",
      "code": "            for j in range(dim):\n                # Use Pascal mod 10 pattern: (i+j) mod 10\n                pascal_val = (i + j) % 10\n                # Use zeta-trace: 7-trace cycle\n                trace7_val = (token_hash + j) % 7\n                if trace7_val == 0:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1928,
      "alignment": 0.5557455012565989,
      "coherence": 0.5557455012565989,
      "comment_phi_k": 5.394841269841269,
      "code_phi_k": 26.891486291486288
    },
    {
      "comment": "# Field potential: combination of Pascal and trace7",
      "code": "                if trace7_val == 0:\n                    trace7_val = 7\n                \n                # Field potential: combination of Pascal and trace7\n                field_potential = (pascal_val * trace7_val) / 70.0\n                ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1933,
      "alignment": 0.6842196300842791,
      "coherence": 0.6842196300842791,
      "comment_phi_k": 11.16866883116883,
      "code_phi_k": 20.74106449106449
    },
    {
      "comment": "# Add to embedding with position weighting",
      "code": "                # Field potential: combination of Pascal and trace7\n                field_potential = (pascal_val * trace7_val) / 70.0\n                \n                # Add to embedding with position weighting\n                position_weight = 1.0 / (1.0 + i * 0.1)\n                embedding[j] += field_potential * position_weight",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1936,
      "alignment": 0.5779851309132965,
      "coherence": 0.5779851309132965,
      "comment_phi_k": 9.610515873015874,
      "code_phi_k": 35.61406648906649
    },
    {
      "comment": "# Normalize using field operations",
      "code": "                position_weight = 1.0 / (1.0 + i * 0.1)\n                embedding[j] += field_potential * position_weight\n        \n        # Normalize using field operations\n        # Compute magnitude (field energy)\n        magnitude = math.sqrt(sum(x ** 2 for x in embedding))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1940,
      "alignment": 0.5661972825417082,
      "coherence": 0.5661972825417082,
      "comment_phi_k": 7.623214285714285,
      "code_phi_k": 32.60136252636252
    },
    {
      "comment": "# Compute magnitude (field energy)",
      "code": "                embedding[j] += field_potential * position_weight\n        \n        # Normalize using field operations\n        # Compute magnitude (field energy)\n        magnitude = math.sqrt(sum(x ** 2 for x in embedding))\n        if magnitude > 0:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1941,
      "alignment": 0.5556806731076168,
      "coherence": 0.5556806731076168,
      "comment_phi_k": 6.51765873015873,
      "code_phi_k": 32.52238872238872
    },
    {
      "comment": "# Apply dimensional expansion (Field Spec \u00a78)",
      "code": "        if magnitude > 0:\n            embedding = [x / magnitude for x in embedding]\n        \n        # Apply dimensional expansion (Field Spec \u00a78)\n        # Add curvature component\n        for j in range(dim):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1946,
      "alignment": 0.5771391194650847,
      "coherence": 0.5771391194650847,
      "comment_phi_k": 8.108946608946608,
      "code_phi_k": 30.334740259740258
    },
    {
      "comment": "# Add curvature component",
      "code": "            embedding = [x / magnitude for x in embedding]\n        \n        # Apply dimensional expansion (Field Spec \u00a78)\n        # Add curvature component\n        for j in range(dim):\n            # Curvature from ordinal differences",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1947,
      "alignment": 0.5405590137019967,
      "coherence": 0.5405590137019967,
      "comment_phi_k": 5.144047619047619,
      "code_phi_k": 34.27920274170274
    },
    {
      "comment": "# Curvature from ordinal differences",
      "code": "        # Apply dimensional expansion (Field Spec \u00a78)\n        # Add curvature component\n        for j in range(dim):\n            # Curvature from ordinal differences\n            if j > 0:\n                curvature = embedding[j] - embedding[j-1]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1949,
      "alignment": 0.5602330426484361,
      "coherence": 0.5602330426484361,
      "comment_phi_k": 7.085930735930736,
      "code_phi_k": 32.95344516594516
    },
    {
      "comment": "# Store code-output pair for learning",
      "code": "        Learn from coupling code with its output.\n        Updates field based on successful patterns.\n        \"\"\"\n        # Store code-output pair for learning\n        correctness = 1.0 if output == correct_answer else 0.0\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1963,
      "alignment": 0.5586634224490781,
      "coherence": 0.5586634224490781,
      "comment_phi_k": 7.881962481962482,
      "code_phi_k": 37.53074703074704
    },
    {
      "comment": "# Only learn from successful outputs (or track failures)",
      "code": "        # Store code-output pair for learning\n        correctness = 1.0 if output == correct_answer else 0.0\n        \n        # Only learn from successful outputs (or track failures)\n        if correctness > 0.5:\n            # Successful pattern: update field to reinforce this path",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1966,
      "alignment": 0.5793938853590452,
      "coherence": 0.5793938853590452,
      "comment_phi_k": 12.246825396825397,
      "code_phi_k": 44.686915861915864
    },
    {
      "comment": "# Successful pattern: update field to reinforce this path",
      "code": "        \n        # Only learn from successful outputs (or track failures)\n        if correctness > 0.5:\n            # Successful pattern: update field to reinforce this path\n            # Extract field properties that led to success\n            successful_phi_k = field_state.get(\"phi_k\", 0.0)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1968,
      "alignment": 0.5860706783128626,
      "coherence": 0.5860706783128626,
      "comment_phi_k": 12.478174603174605,
      "code_phi_k": 42.4830639024718
    },
    {
      "comment": "# Extract field properties that led to success",
      "code": "        # Only learn from successful outputs (or track failures)\n        if correctness > 0.5:\n            # Successful pattern: update field to reinforce this path\n            # Extract field properties that led to success\n            successful_phi_k = field_state.get(\"phi_k\", 0.0)\n            successful_zeros = zeros",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1969,
      "alignment": 0.5630223093855088,
      "coherence": 0.5630223093855088,
      "comment_phi_k": 10.325396825396826,
      "code_phi_k": 46.12199094764884
    },
    {
      "comment": "# Store successful pattern (could update knowledge base or field)",
      "code": "            successful_phi_k = field_state.get(\"phi_k\", 0.0)\n            successful_zeros = zeros\n            \n            # Store successful pattern (could update knowledge base or field)\n            # For now, we'll use this to improve future generations\n            pass  # TODO: Implement field update from successful patterns",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1973,
      "alignment": 0.5843151317993479,
      "coherence": 0.5843151317993479,
      "comment_phi_k": 13.81984126984127,
      "code_phi_k": 47.886673487331386
    },
    {
      "comment": "# For now, we'll use this to improve future generations",
      "code": "            successful_zeros = zeros\n            \n            # Store successful pattern (could update knowledge base or field)\n            # For now, we'll use this to improve future generations\n            pass  # TODO: Implement field update from successful patterns\n        else:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1974,
      "alignment": 0.5844521457007222,
      "coherence": 0.5844521457007222,
      "comment_phi_k": 13.087518037518038,
      "code_phi_k": 45.2861673049173
    },
    {
      "comment": "TODO: Implement field update from successful patterns",
      "code": "pass",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1975,
      "alignment": 0.5289982895018175,
      "coherence": 0.5289982895018175,
      "comment_phi_k": 11.781547619047618,
      "code_phi_k": 1.2916666666666667
    },
    {
      "comment": "# Failed pattern: learn what to avoid",
      "code": "            # For now, we'll use this to improve future generations\n            pass  # TODO: Implement field update from successful patterns\n        else:\n            # Failed pattern: learn what to avoid\n            # Could update field to avoid similar patterns\n            pass  # TODO: Implement field update from failed patterns",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1977,
      "alignment": 0.5400262729912506,
      "coherence": 0.5400262729912506,
      "comment_phi_k": 9.088095238095237,
      "code_phi_k": 61.30735930735929
    },
    {
      "comment": "# Could update field to avoid similar patterns",
      "code": "            pass  # TODO: Implement field update from successful patterns\n        else:\n            # Failed pattern: learn what to avoid\n            # Could update field to avoid similar patterns\n            pass  # TODO: Implement field update from failed patterns\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1978,
      "alignment": 0.5673412502947267,
      "coherence": 0.5673412502947267,
      "comment_phi_k": 11.44702380952381,
      "code_phi_k": 48.21984126984127
    },
    {
      "comment": "TODO: Implement field update from failed patterns",
      "code": "pass",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1979,
      "alignment": 0.5293364817852443,
      "coherence": 0.5293364817852443,
      "comment_phi_k": 11.653174603174605,
      "code_phi_k": 1.2916666666666667
    },
    {
      "comment": "# Step 0: Query knowledge base if available",
      "code": "        if not choices:\n            return 0\n        \n        # Step 0: Query knowledge base if available\n        knowledge_results = None\n        query_region = None  # Will be set if knowledge base is queried",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1993,
      "alignment": 0.5837374824975587,
      "coherence": 0.5837374824975587,
      "comment_phi_k": 9.498412698412698,
      "code_phi_k": 33.10691551095963
    },
    {
      "comment": "Will be set if knowledge base is queried",
      "code": "query_region = None",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 1995,
      "alignment": 0.593383618842849,
      "coherence": 0.593383618842849,
      "comment_phi_k": 10.991468253968254,
      "code_phi_k": 3.4595598845598845
    },
    {
      "comment": "# Query knowledge base using improved semantic matching",
      "code": "                with open(knowledge_file) as f:\n                    knowledge_base = json.load(f)\n                \n                # Query knowledge base using improved semantic matching\n                # Proper zeta calibration: use FULL hierarchical spectrum for question\n                query_field = self._call_primitive(\"aperture.chain\", {\"text\": question})",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2003,
      "alignment": 0.581919951992442,
      "coherence": 0.581919951992442,
      "comment_phi_k": 12.031349206349207,
      "code_phi_k": 42.732460055695476
    },
    {
      "comment": "# Proper zeta calibration: use FULL hierarchical spectrum for question",
      "code": "                    knowledge_base = json.load(f)\n                \n                # Query knowledge base using improved semantic matching\n                # Proper zeta calibration: use FULL hierarchical spectrum for question\n                query_field = self._call_primitive(\"aperture.chain\", {\"text\": question})\n                query_aperture = query_field.get(\"aperture\", {})",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2004,
      "alignment": 0.6069539503535678,
      "coherence": 0.6069539503535678,
      "comment_phi_k": 14.708585858585856,
      "code_phi_k": 41.73494415807476
    },
    {
      "comment": "# Construct full hierarchical spectrum for question",
      "code": "                query_aperture = query_field.get(\"aperture\", {})\n                query_phi_k = query_aperture.get(\"discourse\", {}).get(\"phi_k\", 0.0)\n                \n                # Construct full hierarchical spectrum for question\n                query_spectrum = []\n                # Letters",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2009,
      "alignment": 0.636315945610641,
      "coherence": 0.636315945610641,
      "comment_phi_k": 9.89090909090909,
      "code_phi_k": 23.085131907852926
    },
    {
      "comment": "# Letters",
      "code": "                \n                # Construct full hierarchical spectrum for question\n                query_spectrum = []\n                # Letters\n                for letter in query_aperture.get(\"letters\", []):\n                    if isinstance(letter, dict) and letter.get(\"phi_k\"):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2011,
      "alignment": 0.5148652779877714,
      "coherence": 0.5148652779877714,
      "comment_phi_k": 1.6464285714285714,
      "code_phi_k": 28.512379816001946
    },
    {
      "comment": "# Words",
      "code": "                for letter in query_aperture.get(\"letters\", []):\n                    if isinstance(letter, dict) and letter.get(\"phi_k\"):\n                        query_spectrum.append(float(letter[\"phi_k\"]))\n                # Words\n                for word in query_aperture.get(\"words\", []):\n                    if isinstance(word, dict) and word.get(\"phi_k\"):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2015,
      "alignment": 0.5106981531928576,
      "coherence": 0.5106981531928576,
      "comment_phi_k": 1.3916666666666668,
      "code_phi_k": 33.21702277553945
    },
    {
      "comment": "# Sentences",
      "code": "                for word in query_aperture.get(\"words\", []):\n                    if isinstance(word, dict) and word.get(\"phi_k\"):\n                        query_spectrum.append(float(word[\"phi_k\"]))\n                # Sentences\n                for sentence in query_aperture.get(\"sentences\", []):\n                    if isinstance(sentence, dict) and sentence.get(\"phi_k\"):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2019,
      "alignment": 0.5137731713115933,
      "coherence": 0.5137731713115933,
      "comment_phi_k": 1.826984126984127,
      "code_phi_k": 34.07550111812245
    },
    {
      "comment": "# Discourse",
      "code": "                for sentence in query_aperture.get(\"sentences\", []):\n                    if isinstance(sentence, dict) and sentence.get(\"phi_k\"):\n                        query_spectrum.append(float(sentence[\"phi_k\"]))\n                # Discourse\n                if query_phi_k:\n                    query_spectrum.append(float(query_phi_k))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2023,
      "alignment": 0.5192828017885943,
      "coherence": 0.5192828017885943,
      "comment_phi_k": 1.903373015873016,
      "code_phi_k": 25.628767109870232
    },
    {
      "comment": "# Dimensional scale matching: use Cycle-to-Dimension Principle",
      "code": "                if not query_spectrum:\n                    query_spectrum = [float(query_phi_k)] if query_phi_k else [0.0]\n                \n                # Dimensional scale matching: use Cycle-to-Dimension Principle\n                # D = active dimensionality from hierarchical structure\n                # Aperture chain: Letter \u2192 Word \u2192 Sentence \u2192 Discourse = 4 levels",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2030,
      "alignment": 0.5659127010769969,
      "coherence": 0.5659127010769969,
      "comment_phi_k": 10.388578496666732,
      "code_phi_k": 44.59708388017211
    },
    {
      "comment": "# D = active dimensionality from hierarchical structure",
      "code": "                    query_spectrum = [float(query_phi_k)] if query_phi_k else [0.0]\n                \n                # Dimensional scale matching: use Cycle-to-Dimension Principle\n                # D = active dimensionality from hierarchical structure\n                # Aperture chain: Letter \u2192 Word \u2192 Sentence \u2192 Discourse = 4 levels\n                # Dimensionality D comes from number of active hierarchical levels",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2031,
      "alignment": 0.5492534536067614,
      "coherence": 0.5492534536067614,
      "comment_phi_k": 9.703793428793428,
      "code_phi_k": 54.1062774643657
    },
    {
      "comment": "# Aperture chain: Letter \u2192 Word \u2192 Sentence \u2192 Discourse = 4 levels",
      "code": "                \n                # Dimensional scale matching: use Cycle-to-Dimension Principle\n                # D = active dimensionality from hierarchical structure\n                # Aperture chain: Letter \u2192 Word \u2192 Sentence \u2192 Discourse = 4 levels\n                # Dimensionality D comes from number of active hierarchical levels\n                ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2032,
      "alignment": 0.5735159807937585,
      "coherence": 0.5735159807937585,
      "comment_phi_k": 11.746230158730159,
      "code_phi_k": 45.81759392568217
    },
    {
      "comment": "# Dimensionality D comes from number of active hierarchical levels",
      "code": "                # Dimensional scale matching: use Cycle-to-Dimension Principle\n                # D = active dimensionality from hierarchical structure\n                # Aperture chain: Letter \u2192 Word \u2192 Sentence \u2192 Discourse = 4 levels\n                # Dimensionality D comes from number of active hierarchical levels\n                \n                # Count active hierarchical levels",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2033,
      "alignment": 0.5758259978162954,
      "coherence": 0.5758259978162954,
      "comment_phi_k": 13.97899184149184,
      "code_phi_k": 53.07854269913094
    },
    {
      "comment": "# Count active hierarchical levels",
      "code": "                # Aperture chain: Letter \u2192 Word \u2192 Sentence \u2192 Discourse = 4 levels\n                # Dimensionality D comes from number of active hierarchical levels\n                \n                # Count active hierarchical levels\n                has_letters = len(query_aperture.get(\"letters\", [])) > 0\n                has_words = len(query_aperture.get(\"words\", [])) > 0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2035,
      "alignment": 0.5484609271854103,
      "coherence": 0.5484609271854103,
      "comment_phi_k": 7.2609487734487725,
      "code_phi_k": 41.08822228364645
    },
    {
      "comment": "# Dimensionality D = number of active levels (Cycle-to-Dimension Principle)",
      "code": "                has_sentences = len(query_aperture.get(\"sentences\", [])) > 0\n                has_discourse = query_phi_k != 0.0\n                \n                # Dimensionality D = number of active levels (Cycle-to-Dimension Principle)\n                D = sum([has_letters, has_words, has_sentences, has_discourse])\n                if D == 0:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2041,
      "alignment": 0.6287459660987194,
      "coherence": 0.6287459660987194,
      "comment_phi_k": 12.230650058146189,
      "code_phi_k": 29.864904197961412
    },
    {
      "comment": "Minimum dimension",
      "code": "D = 1",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2044,
      "alignment": 0.5364625535362889,
      "coherence": 0.5364625535362889,
      "comment_phi_k": 3.6781746031746034,
      "code_phi_k": 0.5
    },
    {
      "comment": "# Dimensional Coulomb Law: scale determined by D",
      "code": "                if D == 0:\n                    D = 1  # Minimum dimension\n                \n                # Dimensional Coulomb Law: scale determined by D\n                # Higher D \u2192 larger search space (more degrees of freedom)\n                # Base scale from D: D=1 \u2192 small, D=4 \u2192 large",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2046,
      "alignment": 0.5771215379469402,
      "coherence": 0.5771215379469402,
      "comment_phi_k": 9.673430735930735,
      "code_phi_k": 36.194462481962475
    },
    {
      "comment": "# Higher D \u2192 larger search space (more degrees of freedom)",
      "code": "                    D = 1  # Minimum dimension\n                \n                # Dimensional Coulomb Law: scale determined by D\n                # Higher D \u2192 larger search space (more degrees of freedom)\n                # Base scale from D: D=1 \u2192 small, D=4 \u2192 large\n                # Use golden ratio growth: \u03c6^D for dimensional scaling",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2047,
      "alignment": 0.5767243298355537,
      "coherence": 0.5767243298355537,
      "comment_phi_k": 12.25952380952381,
      "code_phi_k": 46.07642496392496
    },
    {
      "comment": "# Base scale from D: D=1 \u2192 small, D=4 \u2192 large",
      "code": "                \n                # Dimensional Coulomb Law: scale determined by D\n                # Higher D \u2192 larger search space (more degrees of freedom)\n                # Base scale from D: D=1 \u2192 small, D=4 \u2192 large\n                # Use golden ratio growth: \u03c6^D for dimensional scaling\n                phi = (1 + math.sqrt(5)) / 2  # Golden ratio",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2048,
      "alignment": 0.547814603532071,
      "coherence": 0.547814603532071,
      "comment_phi_k": 8.333333333333334,
      "code_phi_k": 47.73773448773448
    },
    {
      "comment": "# Use golden ratio growth: \u03c6^D for dimensional scaling",
      "code": "                # Dimensional Coulomb Law: scale determined by D\n                # Higher D \u2192 larger search space (more degrees of freedom)\n                # Base scale from D: D=1 \u2192 small, D=4 \u2192 large\n                # Use golden ratio growth: \u03c6^D for dimensional scaling\n                phi = (1 + math.sqrt(5)) / 2  # Golden ratio\n                dimensional_scale = phi ** D  # Dimensional growth",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2049,
      "alignment": 0.5590270331482002,
      "coherence": 0.5590270331482002,
      "comment_phi_k": 11.631962481962482,
      "code_phi_k": 55.081384995723226
    },
    {
      "comment": "Golden ratio",
      "code": "phi = (1 + math.sqrt(5)) / 2",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2050,
      "alignment": 0.854411217931694,
      "coherence": 0.854411217931694,
      "comment_phi_k": 3.1916666666666664,
      "code_phi_k": 2.6478174603174605
    },
    {
      "comment": "Dimensional growth",
      "code": "dimensional_scale = phi ** D",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2051,
      "alignment": 0.9018550393302285,
      "coherence": 0.9018550393302285,
      "comment_phi_k": 3.4605339105339104,
      "code_phi_k": 3.8831165974548325
    },
    {
      "comment": "# Also consider spectrum size (more terms = richer field)",
      "code": "                phi = (1 + math.sqrt(5)) / 2  # Golden ratio\n                dimensional_scale = phi ** D  # Dimensional growth\n                \n                # Also consider spectrum size (more terms = richer field)\n                spectrum_size = len(query_spectrum)\n                spectrum_factor = max(1.0, spectrum_size / 10.0)  # Normalize to ~1-3",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2053,
      "alignment": 0.5963257022598375,
      "coherence": 0.5963257022598375,
      "comment_phi_k": 11.894047619047619,
      "code_phi_k": 36.81637472005119
    },
    {
      "comment": "Normalize to ~1-3",
      "code": "spectrum_factor = max(1.0, spectrum_size / 10.0)",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2055,
      "alignment": 0.7065170319105902,
      "coherence": 0.7065170319105902,
      "comment_phi_k": 2.891468253968254,
      "code_phi_k": 4.946012321012321
    },
    {
      "comment": "# Final scale: dimensional scale \u00d7 spectrum factor",
      "code": "                spectrum_size = len(query_spectrum)\n                spectrum_factor = max(1.0, spectrum_size / 10.0)  # Normalize to ~1-3\n                \n                # Final scale: dimensional scale \u00d7 spectrum factor\n                search_max = dimensional_scale * spectrum_factor\n                # Clamp to reasonable range",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2057,
      "alignment": 0.5839350409641,
      "coherence": 0.5839350409641,
      "comment_phi_k": 9.574224386724385,
      "code_phi_k": 33.30388027005673
    },
    {
      "comment": "# Clamp to reasonable range",
      "code": "                \n                # Final scale: dimensional scale \u00d7 spectrum factor\n                search_max = dimensional_scale * spectrum_factor\n                # Clamp to reasonable range\n                search_max = max(5.0, min(30.0, search_max))\n                ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2059,
      "alignment": 0.5597976933464941,
      "coherence": 0.5597976933464941,
      "comment_phi_k": 5.902579365079365,
      "code_phi_k": 27.628576692914926
    },
    {
      "comment": "# Compute query zeros using FULL spectrum with adaptive scale",
      "code": "                \n                query_region = {\"min\": 0.0, \"max\": search_max}\n                \n                # Compute query zeros using FULL spectrum with adaptive scale\n                query_zeros = self._call_primitive(\"zeta.zero.solver\", {\n                    \"phi_k\": query_spectrum,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2064,
      "alignment": 0.6849625150201003,
      "coherence": 0.6849625150201003,
      "comment_phi_k": 14.361309523809522,
      "code_phi_k": 26.591762902179624
    },
    {
      "comment": "# Extract query words for semantic matching",
      "code": "                })\n                query_zero_positions = [z.get(\"imaginary\", 0.0) for z in query_zeros if isinstance(z, dict)]\n                \n                # Extract query words for semantic matching\n                query_words = set(question.lower().split())\n                ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2072,
      "alignment": 0.6072897473182293,
      "coherence": 0.6072897473182293,
      "comment_phi_k": 9.510714285714286,
      "code_phi_k": 26.916641243715382
    },
    {
      "comment": "# Score knowledge entries with multiple signals",
      "code": "                # Extract query words for semantic matching\n                query_words = set(question.lower().split())\n                \n                # Score knowledge entries with multiple signals\n                scored_entries = []\n                for entry_hash, entry in knowledge_base.items():",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2075,
      "alignment": 0.5854600243041607,
      "coherence": 0.5854600243041607,
      "comment_phi_k": 9.81765873015873,
      "code_phi_k": 33.62886194784785
    },
    {
      "comment": "# Signal 1: Field coherence (improved normalization)",
      "code": "                    entry_zeros = entry.get(\"zeros\", [])\n                    entry_zero_positions = [z.get(\"imaginary\", 0.0) for z in entry_zeros if isinstance(z, dict)]\n                    \n                    # Signal 1: Field coherence (improved normalization)\n                    phi_k_diff = abs(query_phi_k - float(entry_phi_k))\n                    phi_k_avg = (abs(query_phi_k) + abs(entry_phi_k)) / 2.0 + 1.0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2084,
      "alignment": 0.5658037106188846,
      "coherence": 0.5658037106188846,
      "comment_phi_k": 8.526196026196025,
      "code_phi_k": 36.65563312246749
    },
    {
      "comment": "# Signal 1b: Zero proximity (using proper zeta calibration)",
      "code": "                    phi_k_avg = (abs(query_phi_k) + abs(entry_phi_k)) / 2.0 + 1.0\n                    coherence = 1.0 - min(1.0, phi_k_diff / phi_k_avg)\n                    \n                    # Signal 1b: Zero proximity (using proper zeta calibration)\n                    zero_proximity = 0.0\n                    if query_zero_positions and entry_zero_positions:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2089,
      "alignment": 0.6064689048913681,
      "coherence": 0.6064689048913681,
      "comment_phi_k": 11.064502164502164,
      "code_phi_k": 31.512846486588746
    },
    {
      "comment": "# Signal 2: Word overlap (semantic matching)",
      "code": "                        zero_proximity = 1.0 / (1.0 + min_zero_dist)\n                        coherence = (coherence + zero_proximity) / 2.0\n                    \n                    # Signal 2: Word overlap (semantic matching)\n                    entry_words = set(entry_text.split())\n                    word_overlap = len(query_words & entry_words)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2100,
      "alignment": 0.5854032425394857,
      "coherence": 0.5854032425394857,
      "comment_phi_k": 7.849007936507936,
      "code_phi_k": 26.900821093681003
    },
    {
      "comment": "# Signal 3: Domain relevance (if domain matches question topic)",
      "code": "                    word_overlap = len(query_words & entry_words)\n                    word_score = min(1.0, word_overlap / max(len(query_words), 1))\n                    \n                    # Signal 3: Domain relevance (if domain matches question topic)\n                    domain_keywords = {\n                        \"biology\": [\"mitochondria\", \"cell\", \"organism\", \"dna\", \"protein\", \"energy\"],",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2105,
      "alignment": 0.6103104007951035,
      "coherence": 0.6103104007951035,
      "comment_phi_k": 12.646825396825397,
      "code_phi_k": 34.9853187962708
    },
    {
      "comment": "# Combined score (weighted)",
      "code": "                        if entry_domain == domain and any(kw in question.lower() for kw in keywords):\n                            domain_score = 0.3\n                    \n                    # Combined score (weighted)\n                    total_score = (coherence * 0.3) + (word_score * 0.5) + (domain_score * 0.2)\n                    scored_entries.append((entry, total_score, coherence, word_score, domain_score))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2117,
      "alignment": 0.5304984843190735,
      "coherence": 0.5304984843190735,
      "comment_phi_k": 4.457341269841269,
      "code_phi_k": 38.76607052018043
    },
    {
      "comment": "Top 5",
      "code": "knowledge_results = [entry for entry, score, c, w, d in scored_entries[:5]]",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2122,
      "alignment": 0.525641716409169,
      "coherence": 0.525641716409169,
      "comment_phi_k": 1.1666666666666667,
      "code_phi_k": 11.958026899571017
    },
    {
      "comment": "Continue without knowledge base",
      "code": "pass",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2124,
      "alignment": 0.553255890052356,
      "coherence": 0.553255890052356,
      "comment_phi_k": 6.709325396825397,
      "code_phi_k": 1.2916666666666667
    },
    {
      "comment": "# Enhanced approach: Use zero interpretation and composer planning",
      "code": "        except Exception:\n            pass  # Continue without knowledge base\n        \n        # Enhanced approach: Use zero interpretation and composer planning\n        try:\n            # Step 1: Create document field from question + choices",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2126,
      "alignment": 0.6152975096961066,
      "coherence": 0.6152975096961066,
      "comment_phi_k": 14.346980796980798,
      "code_phi_k": 38.28209984459985
    },
    {
      "comment": "# Step 1: Create document field from question + choices",
      "code": "        \n        # Enhanced approach: Use zero interpretation and composer planning\n        try:\n            # Step 1: Create document field from question + choices\n            # Proper zeta calibration: use FULL hierarchical spectrum\n            doc_text = question + \" \" + \" \".join(choices)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2128,
      "alignment": 0.5742176685939059,
      "coherence": 0.5742176685939059,
      "comment_phi_k": 10.994047619047619,
      "code_phi_k": 42.53014485514486
    },
    {
      "comment": "# Proper zeta calibration: use FULL hierarchical spectrum",
      "code": "        # Enhanced approach: Use zero interpretation and composer planning\n        try:\n            # Step 1: Create document field from question + choices\n            # Proper zeta calibration: use FULL hierarchical spectrum\n            doc_text = question + \" \" + \" \".join(choices)\n            doc_field = self._call_primitive(\"aperture.chain\", {\"text\": doc_text})",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2129,
      "alignment": 0.5676361838205453,
      "coherence": 0.5676361838205453,
      "comment_phi_k": 11.611562049062048,
      "code_phi_k": 48.72497528255669
    },
    {
      "comment": "# Construct full hierarchical spectrum for document",
      "code": "            doc_field = self._call_primitive(\"aperture.chain\", {\"text\": doc_text})\n            doc_aperture = doc_field.get(\"aperture\", {})\n            \n            # Construct full hierarchical spectrum for document\n            doc_spectrum = []\n            # Letters",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2134,
      "alignment": 0.6311580930349922,
      "coherence": 0.6311580930349922,
      "comment_phi_k": 9.777813852813853,
      "code_phi_k": 23.526365024789744
    },
    {
      "comment": "# Letters",
      "code": "            \n            # Construct full hierarchical spectrum for document\n            doc_spectrum = []\n            # Letters\n            for letter in doc_aperture.get(\"letters\", []):\n                if isinstance(letter, dict) and letter.get(\"phi_k\"):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2136,
      "alignment": 0.5151738940254539,
      "coherence": 0.5151738940254539,
      "comment_phi_k": 1.6464285714285714,
      "code_phi_k": 27.94922044910789
    },
    {
      "comment": "# Words",
      "code": "            for letter in doc_aperture.get(\"letters\", []):\n                if isinstance(letter, dict) and letter.get(\"phi_k\"):\n                    doc_spectrum.append(float(letter[\"phi_k\"]))\n            # Words\n            for word in doc_aperture.get(\"words\", []):\n                if isinstance(word, dict) and word.get(\"phi_k\"):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2140,
      "alignment": 0.5108969106311977,
      "coherence": 0.5108969106311977,
      "comment_phi_k": 1.3916666666666668,
      "code_phi_k": 32.62384288042333
    },
    {
      "comment": "# Sentences",
      "code": "            for word in doc_aperture.get(\"words\", []):\n                if isinstance(word, dict) and word.get(\"phi_k\"):\n                    doc_spectrum.append(float(word[\"phi_k\"]))\n            # Sentences\n            for sentence in doc_aperture.get(\"sentences\", []):\n                if isinstance(sentence, dict) and sentence.get(\"phi_k\"):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2144,
      "alignment": 0.5140233537804315,
      "coherence": 0.5140233537804315,
      "comment_phi_k": 1.826984126984127,
      "code_phi_k": 33.483877072489314
    },
    {
      "comment": "# Discourse",
      "code": "            for sentence in doc_aperture.get(\"sentences\", []):\n                if isinstance(sentence, dict) and sentence.get(\"phi_k\"):\n                    doc_spectrum.append(float(sentence[\"phi_k\"]))\n            # Discourse\n            doc_phi_k = doc_aperture.get(\"discourse\", {}).get(\"phi_k\", 0.0)\n            if doc_phi_k:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2148,
      "alignment": 0.5184092378131852,
      "coherence": 0.5184092378131852,
      "comment_phi_k": 1.903373015873016,
      "code_phi_k": 26.799755765178826
    },
    {
      "comment": "# Step 2: Use zero interpretation for semantic understanding",
      "code": "            if not doc_spectrum:\n                doc_spectrum = [float(doc_phi_k)] if doc_phi_k else [0.0]\n            \n            # Step 2: Use zero interpretation for semantic understanding\n            # Dimensional scale matching: use Cycle-to-Dimension Principle\n            # Count active hierarchical levels for document",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2156,
      "alignment": 0.5777138247025201,
      "coherence": 0.5777138247025201,
      "comment_phi_k": 11.946787934287935,
      "code_phi_k": 44.40538460722284
    },
    {
      "comment": "# Dimensional scale matching: use Cycle-to-Dimension Principle",
      "code": "                doc_spectrum = [float(doc_phi_k)] if doc_phi_k else [0.0]\n            \n            # Step 2: Use zero interpretation for semantic understanding\n            # Dimensional scale matching: use Cycle-to-Dimension Principle\n            # Count active hierarchical levels for document\n            doc_has_letters = len(doc_aperture.get(\"letters\", [])) > 0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2157,
      "alignment": 0.5662897034657477,
      "coherence": 0.5662897034657477,
      "comment_phi_k": 10.388578496666732,
      "code_phi_k": 44.37299255191119
    },
    {
      "comment": "# Count active hierarchical levels for document",
      "code": "            \n            # Step 2: Use zero interpretation for semantic understanding\n            # Dimensional scale matching: use Cycle-to-Dimension Principle\n            # Count active hierarchical levels for document\n            doc_has_letters = len(doc_aperture.get(\"letters\", [])) > 0\n            doc_has_words = len(doc_aperture.get(\"words\", [])) > 0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2158,
      "alignment": 0.5718390162222513,
      "coherence": 0.5718390162222513,
      "comment_phi_k": 10.244877344877343,
      "code_phi_k": 40.774643712323794
    },
    {
      "comment": "# Dimensionality D from hierarchical structure",
      "code": "            doc_has_sentences = len(doc_aperture.get(\"sentences\", [])) > 0\n            doc_has_discourse = doc_phi_k != 0.0\n            \n            # Dimensionality D from hierarchical structure\n            doc_D = sum([doc_has_letters, doc_has_words, doc_has_sentences, doc_has_discourse])\n            if doc_D == 0:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2164,
      "alignment": 0.5835404854711042,
      "coherence": 0.5835404854711042,
      "comment_phi_k": 7.770460095460094,
      "code_phi_k": 27.138805998482155
    },
    {
      "comment": "# Dimensional scale: \u03c6^D",
      "code": "            if doc_D == 0:\n                doc_D = 1\n            \n            # Dimensional scale: \u03c6^D\n            phi = (1 + math.sqrt(5)) / 2\n            doc_dimensional_scale = phi ** doc_D",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2169,
      "alignment": 0.5791520812238773,
      "coherence": 0.5791520812238773,
      "comment_phi_k": 4.143867243867244,
      "code_phi_k": 15.160241534351442
    },
    {
      "comment": "# Spectrum factor",
      "code": "            phi = (1 + math.sqrt(5)) / 2\n            doc_dimensional_scale = phi ** doc_D\n            \n            # Spectrum factor\n            doc_spectrum_size = len(doc_spectrum)\n            doc_spectrum_factor = max(1.0, doc_spectrum_size / 10.0)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2173,
      "alignment": 0.5442748162787143,
      "coherence": 0.5442748162787143,
      "comment_phi_k": 3.172023809523809,
      "code_phi_k": 19.49700553574393
    },
    {
      "comment": "# Final scale",
      "code": "            doc_spectrum_size = len(doc_spectrum)\n            doc_spectrum_factor = max(1.0, doc_spectrum_size / 10.0)\n            \n            # Final scale\n            doc_search_max = doc_dimensional_scale * doc_spectrum_factor\n            doc_search_max = max(5.0, min(30.0, doc_search_max))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2177,
      "alignment": 0.531992317048202,
      "coherence": 0.531992317048202,
      "comment_phi_k": 2.925,
      "code_phi_k": 24.31955030049071
    },
    {
      "comment": "# Compute zeros using FULL spectrum with adaptive scale",
      "code": "            \n            doc_region = {\"min\": 0.0, \"max\": doc_search_max}\n            \n            # Compute zeros using FULL spectrum with adaptive scale\n            doc_zeros = self._call_primitive(\"zeta.zero.solver\", {\n                \"phi_k\": doc_spectrum,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2183,
      "alignment": 0.6789815404465888,
      "coherence": 0.6789815404465888,
      "comment_phi_k": 12.802976190476189,
      "code_phi_k": 24.284583970000693
    },
    {
      "comment": "# Perturb field with question and observe zero movements",
      "code": "                \"tolerance\": 0.001\n            })\n            \n            # Perturb field with question and observe zero movements\n            zero_movements = self._call_primitive(\"zeros.movement\", {\n                \"question\": question,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2190,
      "alignment": 0.7107202595607254,
      "coherence": 0.7107202595607254,
      "comment_phi_k": 13.125793650793652,
      "code_phi_k": 22.135430854820633
    },
    {
      "comment": "# Step 3: Interpret zero movements for semantic guidance",
      "code": "                \"document_field\": doc_field\n            })\n            \n            # Step 3: Interpret zero movements for semantic guidance\n            semantic_guidance = self._call_primitive(\"interpret_movement\", {\n                \"movements\": zero_movements,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2196,
      "alignment": 0.6693114123521685,
      "coherence": 0.6693114123521685,
      "comment_phi_k": 11.509920634920636,
      "code_phi_k": 22.750153486985045
    },
    {
      "comment": "# Step 4: Use composer planning to generate answer reasoning",
      "code": "                \"document_field\": doc_field\n            })\n            \n            # Step 4: Use composer planning to generate answer reasoning\n            # Create intent from question + semantic guidance\n            intent = f\"{question} {semantic_guidance}\"",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2203,
      "alignment": 0.6294109613341581,
      "coherence": 0.6294109613341581,
      "comment_phi_k": 12.888293650793651,
      "code_phi_k": 31.342141396185514
    },
    {
      "comment": "# Create intent from question + semantic guidance",
      "code": "            })\n            \n            # Step 4: Use composer planning to generate answer reasoning\n            # Create intent from question + semantic guidance\n            intent = f\"{question} {semantic_guidance}\"\n            composer_result = self._call_primitive(\"composer.plan\", {\"intent\": intent})",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2204,
      "alignment": 0.5859356316353798,
      "coherence": 0.5859356316353798,
      "comment_phi_k": 10.332142857142857,
      "code_phi_k": 35.223867771366606
    },
    {
      "comment": "# Step 5: Score each choice using conjugate relationship + knowledge base",
      "code": "            intent = f\"{question} {semantic_guidance}\"\n            composer_result = self._call_primitive(\"composer.plan\", {\"intent\": intent})\n            \n            # Step 5: Score each choice using conjugate relationship + knowledge base\n            # Questions and answers have conjugate relationship: answer zeros \u2248 conjugate(question zeros)\n            choice_scores = []",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2208,
      "alignment": 0.5950408140300705,
      "coherence": 0.5950408140300705,
      "comment_phi_k": 14.97166305916306,
      "code_phi_k": 46.86802541111248
    },
    {
      "comment": "# Questions and answers have conjugate relationship: answer zeros \u2248 conjugate(question zeros)",
      "code": "            composer_result = self._call_primitive(\"composer.plan\", {\"intent\": intent})\n            \n            # Step 5: Score each choice using conjugate relationship + knowledge base\n            # Questions and answers have conjugate relationship: answer zeros \u2248 conjugate(question zeros)\n            choice_scores = []\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2209,
      "alignment": 0.6356059286843414,
      "coherence": 0.6356059286843414,
      "comment_phi_k": 17.90762611571435,
      "code_phi_k": 41.967904494447446
    },
    {
      "comment": "# Get question zeros (from query spectrum if available, else from doc zeros)",
      "code": "            # Questions and answers have conjugate relationship: answer zeros \u2248 conjugate(question zeros)\n            choice_scores = []\n            \n            # Get question zeros (from query spectrum if available, else from doc zeros)\n            question_zero_positions = []\n            if 'query_zero_positions' in locals() and query_zero_positions:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2212,
      "alignment": 0.6082702602534706,
      "coherence": 0.6082702602534706,
      "comment_phi_k": 17.689087301587303,
      "code_phi_k": 49.68929469363662
    },
    {
      "comment": "# Create choice intent",
      "code": "                question_zero_positions = [z.get(\"imaginary\", 0.0) for z in doc_zeros if isinstance(z, dict)]\n            \n            for i, choice in enumerate(choices):\n                # Create choice intent\n                choice_intent = f\"{question} {choice}\"\n                ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2220,
      "alignment": 0.5453222564739596,
      "coherence": 0.5453222564739596,
      "comment_phi_k": 5.050000000000001,
      "code_phi_k": 30.381071127557032
    },
    {
      "comment": "# Get choice ions",
      "code": "                # Create choice intent\n                choice_intent = f\"{question} {choice}\"\n                \n                # Get choice ions\n                choice_ions = self._call_primitive(\"extract_ions\", {\"intent\": choice_intent})\n                ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2223,
      "alignment": 0.5603937315160604,
      "coherence": 0.5603937315160604,
      "comment_phi_k": 4.558333333333334,
      "code_phi_k": 21.14839869996611
    },
    {
      "comment": "# Compute choice field with proper zeta calibration",
      "code": "                # Get choice ions\n                choice_ions = self._call_primitive(\"extract_ions\", {\"intent\": choice_intent})\n                \n                # Compute choice field with proper zeta calibration\n                choice_field = self._call_primitive(\"aperture.chain\", {\"text\": choice})\n                choice_aperture = choice_field.get(\"aperture\", {})",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2226,
      "alignment": 0.5987558367170622,
      "coherence": 0.5987558367170622,
      "comment_phi_k": 11.138113275613275,
      "code_phi_k": 33.765145208055465
    },
    {
      "comment": "# Construct full hierarchical spectrum for choice",
      "code": "                choice_aperture = choice_field.get(\"aperture\", {})\n                choice_phi_k = choice_aperture.get(\"discourse\", {}).get(\"phi_k\", 0.0)\n                \n                # Construct full hierarchical spectrum for choice\n                choice_spectrum = []\n                for letter in choice_aperture.get(\"letters\", []):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2231,
      "alignment": 0.605323857275294,
      "coherence": 0.605323857275294,
      "comment_phi_k": 9.560551948051948,
      "code_phi_k": 27.47350093601798
    },
    {
      "comment": "# Dimensional scale matching: answer should match question's dimensionality",
      "code": "                if not choice_spectrum:\n                    choice_spectrum = [float(choice_phi_k)] if choice_phi_k else [0.0]\n                \n                # Dimensional scale matching: answer should match question's dimensionality\n                # Conjugate relationship: answer operates in same dimensional space as question\n                if query_region is not None:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2248,
      "alignment": 0.5795124129590926,
      "coherence": 0.5795124129590926,
      "comment_phi_k": 14.10952935952936,
      "code_phi_k": 51.41742716992329
    },
    {
      "comment": "# Conjugate relationship: answer operates in same dimensional space as question",
      "code": "                    choice_spectrum = [float(choice_phi_k)] if choice_phi_k else [0.0]\n                \n                # Dimensional scale matching: answer should match question's dimensionality\n                # Conjugate relationship: answer operates in same dimensional space as question\n                if query_region is not None:\n                    # Match question's dimensional scale exactly (conjugate relationship)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2249,
      "alignment": 0.5859014552766592,
      "coherence": 0.5859014552766592,
      "comment_phi_k": 17.364538239538238,
      "code_phi_k": 59.21848583348195
    },
    {
      "comment": "# Match question's dimensional scale exactly (conjugate relationship)",
      "code": "                # Dimensional scale matching: answer should match question's dimensionality\n                # Conjugate relationship: answer operates in same dimensional space as question\n                if query_region is not None:\n                    # Match question's dimensional scale exactly (conjugate relationship)\n                    choice_region = query_region\n                else:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2251,
      "alignment": 0.5607483765327067,
      "coherence": 0.5607483765327067,
      "comment_phi_k": 12.266125541125543,
      "code_phi_k": 56.612294649794634
    },
    {
      "comment": "# Compute choice dimensionality from hierarchical structure",
      "code": "                    # Match question's dimensional scale exactly (conjugate relationship)\n                    choice_region = query_region\n                else:\n                    # Compute choice dimensionality from hierarchical structure\n                    choice_has_letters = len(choice_aperture.get(\"letters\", [])) > 0\n                    choice_has_words = len(choice_aperture.get(\"words\", [])) > 0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2254,
      "alignment": 0.5820367511523256,
      "coherence": 0.5820367511523256,
      "comment_phi_k": 10.588317238317238,
      "code_phi_k": 37.56115203853747
    },
    {
      "comment": "# Dimensional scale: \u03c6^D",
      "code": "                    if choice_D == 0:\n                        choice_D = 1\n                    \n                    # Dimensional scale: \u03c6^D\n                    phi = (1 + math.sqrt(5)) / 2\n                    choice_dimensional_scale = phi ** choice_D",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2264,
      "alignment": 0.5716989148520962,
      "coherence": 0.5716989148520962,
      "comment_phi_k": 4.143867243867244,
      "code_phi_k": 16.520782856316742
    },
    {
      "comment": "# Spectrum factor",
      "code": "                    phi = (1 + math.sqrt(5)) / 2\n                    choice_dimensional_scale = phi ** choice_D\n                    \n                    # Spectrum factor\n                    choice_spectrum_size = len(choice_spectrum)\n                    choice_spectrum_factor = max(1.0, choice_spectrum_size / 10.0)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2268,
      "alignment": 0.5410249909451047,
      "coherence": 0.5410249909451047,
      "comment_phi_k": 3.172023809523809,
      "code_phi_k": 20.915838288930225
    },
    {
      "comment": "# Choice scale should match question scale (conjugate relationship)",
      "code": "                    choice_spectrum_size = len(choice_spectrum)\n                    choice_spectrum_factor = max(1.0, choice_spectrum_size / 10.0)\n                    \n                    # Choice scale should match question scale (conjugate relationship)\n                    # Use document scale as reference\n                    choice_search_max = choice_dimensional_scale * choice_spectrum_factor",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2272,
      "alignment": 0.6022573480419255,
      "coherence": 0.6022573480419255,
      "comment_phi_k": 12.70916305916306,
      "code_phi_k": 37.426096932934996
    },
    {
      "comment": "# Use document scale as reference",
      "code": "                    choice_spectrum_factor = max(1.0, choice_spectrum_size / 10.0)\n                    \n                    # Choice scale should match question scale (conjugate relationship)\n                    # Use document scale as reference\n                    choice_search_max = choice_dimensional_scale * choice_spectrum_factor\n                    choice_search_max = max(5.0, min(30.0, min(choice_search_max, doc_search_max)))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2273,
      "alignment": 0.5530565408673257,
      "coherence": 0.5530565408673257,
      "comment_phi_k": 7.987301587301588,
      "code_phi_k": 41.62945147313163
    },
    {
      "comment": "# Compute choice zeros using FULL spectrum with scale-matched region",
      "code": "                    \n                    choice_region = {\"min\": 0.0, \"max\": choice_search_max}\n                \n                # Compute choice zeros using FULL spectrum with scale-matched region\n                choice_zeros = self._call_primitive(\"zeta.zero.solver\", {\n                    \"phi_k\": choice_spectrum,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2279,
      "alignment": 0.6829450215386106,
      "coherence": 0.6829450215386106,
      "comment_phi_k": 14.400781163281163,
      "code_phi_k": 26.879501062711906
    },
    {
      "comment": "# Base coherence: field alignment",
      "code": "                })\n                choice_zero_positions = [z.get(\"imaginary\", 0.0) for z in choice_zeros if isinstance(z, dict)]\n                \n                # Base coherence: field alignment\n                question_phi_k = doc_aperture.get(\"discourse\", {}).get(\"phi_k\", 0.0)\n                coherence = 1.0 - abs(choice_phi_k - float(question_phi_k)) / (abs(question_phi_k) + 1.0)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2287,
      "alignment": 0.5593747836661157,
      "coherence": 0.5593747836661157,
      "comment_phi_k": 7.05595238095238,
      "code_phi_k": 33.23735762010109
    },
    {
      "comment": "# CONJUGATE RELATIONSHIP: Answer zeros complement question zeros",
      "code": "                coherence = 1.0 - abs(choice_phi_k - float(question_phi_k)) / (abs(question_phi_k) + 1.0)\n                coherence = max(0.0, min(1.0, coherence))\n                \n                # CONJUGATE RELATIONSHIP: Answer zeros complement question zeros\n                # Hermitian relationship: answer field = conjugate(question field)\n                # For zeros on critical line: answer zeros should complement question zeros",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2292,
      "alignment": 0.5647114748651215,
      "coherence": 0.5647114748651215,
      "comment_phi_k": 12.667297979797981,
      "code_phi_k": 55.271252429630884
    },
    {
      "comment": "# Hermitian relationship: answer field = conjugate(question field)",
      "code": "                coherence = max(0.0, min(1.0, coherence))\n                \n                # CONJUGATE RELATIONSHIP: Answer zeros complement question zeros\n                # Hermitian relationship: answer field = conjugate(question field)\n                # For zeros on critical line: answer zeros should complement question zeros\n                # This means: answer zeros near question zeros OR at conjugate positions",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2293,
      "alignment": 0.5477570081154228,
      "coherence": 0.5477570081154228,
      "comment_phi_k": 11.282229290317526,
      "code_phi_k": 64.70170980979803
    },
    {
      "comment": "# For zeros on critical line: answer zeros should complement question zeros",
      "code": "                \n                # CONJUGATE RELATIONSHIP: Answer zeros complement question zeros\n                # Hermitian relationship: answer field = conjugate(question field)\n                # For zeros on critical line: answer zeros should complement question zeros\n                # This means: answer zeros near question zeros OR at conjugate positions\n                conjugate_boost = 0.0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2294,
      "alignment": 0.5826397153243533,
      "coherence": 0.5826397153243533,
      "comment_phi_k": 17.212698412698415,
      "code_phi_k": 60.67785727344551
    },
    {
      "comment": "# This means: answer zeros near question zeros OR at conjugate positions",
      "code": "                # CONJUGATE RELATIONSHIP: Answer zeros complement question zeros\n                # Hermitian relationship: answer field = conjugate(question field)\n                # For zeros on critical line: answer zeros should complement question zeros\n                # This means: answer zeros near question zeros OR at conjugate positions\n                conjugate_boost = 0.0\n                if question_zero_positions and choice_zero_positions:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2295,
      "alignment": 0.5728776351527034,
      "coherence": 0.5728776351527034,
      "comment_phi_k": 17.349404761904765,
      "code_phi_k": 68.1902338795797
    },
    {
      "comment": "# Check conjugate relationship: answer zeros should complement question zeros",
      "code": "                # This means: answer zeros near question zeros OR at conjugate positions\n                conjugate_boost = 0.0\n                if question_zero_positions and choice_zero_positions:\n                    # Check conjugate relationship: answer zeros should complement question zeros\n                    total_conjugate_match = 0.0\n                    for qz in question_zero_positions:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2298,
      "alignment": 0.5905547993999243,
      "coherence": 0.5905547993999243,
      "comment_phi_k": 15.492297979797984,
      "code_phi_k": 50.516653928511175
    },
    {
      "comment": "# Direct match: answer zero near question zero (completes question)",
      "code": "                    # Check conjugate relationship: answer zeros should complement question zeros\n                    total_conjugate_match = 0.0\n                    for qz in question_zero_positions:\n                        # Direct match: answer zero near question zero (completes question)\n                        min_direct_dist = min(abs(cz - qz) for cz in choice_zero_positions)\n                        direct_match = 1.0 / (1.0 + min_direct_dist)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2301,
      "alignment": 0.5804537765115235,
      "coherence": 0.5804537765115235,
      "comment_phi_k": 14.227182539682541,
      "code_phi_k": 51.322773102482685
    },
    {
      "comment": "# Conjugate match: answer zero at conjugate position",
      "code": "                        min_direct_dist = min(abs(cz - qz) for cz in choice_zero_positions)\n                        direct_match = 1.0 / (1.0 + min_direct_dist)\n                        \n                        # Conjugate match: answer zero at conjugate position\n                        # For critical line zeros: conjugate(0.5 + i*t) = 0.5 - i*t\n                        conjugate_pos = -qz  # Conjugate on critical line",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2305,
      "alignment": 0.5757468003386268,
      "coherence": 0.5757468003386268,
      "comment_phi_k": 11.554960317460317,
      "code_phi_k": 43.914273613383514
    },
    {
      "comment": "# For critical line zeros: conjugate(0.5 + i*t) = 0.5 - i*t",
      "code": "                        direct_match = 1.0 / (1.0 + min_direct_dist)\n                        \n                        # Conjugate match: answer zero at conjugate position\n                        # For critical line zeros: conjugate(0.5 + i*t) = 0.5 - i*t\n                        conjugate_pos = -qz  # Conjugate on critical line\n                        min_conj_dist = min(abs(cz - conjugate_pos) for cz in choice_zero_positions)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2306,
      "alignment": 0.562515405530312,
      "coherence": 0.562515405530312,
      "comment_phi_k": 10.021825396825395,
      "code_phi_k": 45.088335662445566
    },
    {
      "comment": "Conjugate on critical line",
      "code": "conjugate_pos = -qz",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2307,
      "alignment": 0.6233383574998924,
      "coherence": 0.6233383574998924,
      "comment_phi_k": 6.255158730158731,
      "code_phi_k": 2.4753843378843374
    },
    {
      "comment": "# Use best match (answer completes question through direct or conjugate)",
      "code": "                        min_conj_dist = min(abs(cz - conjugate_pos) for cz in choice_zero_positions)\n                        conj_match = 1.0 / (1.0 + min_conj_dist)\n                        \n                        # Use best match (answer completes question through direct or conjugate)\n                        best_match = max(direct_match, conj_match * 0.7)\n                        total_conjugate_match += best_match",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2311,
      "alignment": 0.6225174396013341,
      "coherence": 0.6225174396013341,
      "comment_phi_k": 15.4,
      "code_phi_k": 39.12409776540969
    },
    {
      "comment": "# Average conjugate match",
      "code": "                        best_match = max(direct_match, conj_match * 0.7)\n                        total_conjugate_match += best_match\n                    \n                    # Average conjugate match\n                    conjugate_boost = total_conjugate_match / len(question_zero_positions)\n                    # Add conjugate boost to coherence (complementary, not replacement)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2315,
      "alignment": 0.5432944617888507,
      "coherence": 0.5432944617888507,
      "comment_phi_k": 5.41765873015873,
      "code_phi_k": 33.992615479461286
    },
    {
      "comment": "# Add conjugate boost to coherence (complementary, not replacement)",
      "code": "                    \n                    # Average conjugate match\n                    conjugate_boost = total_conjugate_match / len(question_zero_positions)\n                    # Add conjugate boost to coherence (complementary, not replacement)\n                    coherence = coherence + (conjugate_boost * 0.3)  # 30% boost from conjugate\n                    coherence = min(1.0, coherence)  # Cap at 1.0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2317,
      "alignment": 0.5861250601207089,
      "coherence": 0.5861250601207089,
      "comment_phi_k": 12.40952935952936,
      "code_phi_k": 42.22659543998923
    },
    {
      "comment": "30% boost from conjugate",
      "code": "coherence = coherence + (conjugate_boost * 0.3)",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2318,
      "alignment": 0.8745367393321192,
      "coherence": 0.8745367393321192,
      "comment_phi_k": 4.658134920634921,
      "code_phi_k": 5.438331807081807
    },
    {
      "comment": "Cap at 1.0",
      "code": "coherence = min(1.0, coherence)",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2319,
      "alignment": 0.6583628042438111,
      "coherence": 0.6583628042438111,
      "comment_phi_k": 2.416666666666667,
      "code_phi_k": 5.023412698412699
    },
    {
      "comment": "# Also check zero proximity from composer result",
      "code": "                    coherence = coherence + (conjugate_boost * 0.3)  # 30% boost from conjugate\n                    coherence = min(1.0, coherence)  # Cap at 1.0\n                \n                # Also check zero proximity from composer result\n                zeros = composer_result.get(\"zeros\", [])\n                if zeros:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2321,
      "alignment": 0.5907945697792524,
      "coherence": 0.5907945697792524,
      "comment_phi_k": 10.732936507936508,
      "code_phi_k": 34.9192722763656
    },
    {
      "comment": "# Boost coherence if choice matches knowledge base entries (improved)",
      "code": "                        zero_proximity = 1.0 / (1.0 + min_zero_dist)\n                        coherence = (coherence + zero_proximity) / 2.0\n                \n                # Boost coherence if choice matches knowledge base entries (improved)\n                if knowledge_results:\n                    knowledge_boost = 0.0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2330,
      "alignment": 0.6655478948789241,
      "coherence": 0.6655478948789241,
      "comment_phi_k": 14.393253968253967,
      "code_phi_k": 28.932412236456358
    },
    {
      "comment": "# Compute choice field (full aperture chain for better semantics)",
      "code": "                if knowledge_results:\n                    knowledge_boost = 0.0\n                    \n                    # Compute choice field (full aperture chain for better semantics)\n                    choice_field = self._call_primitive(\"aperture.chain\", {\"text\": choice})\n                    choice_field_phi_k = choice_field.get(\"aperture\", {}).get(\"discourse\", {}).get(\"phi_k\", choice_phi_k)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2334,
      "alignment": 0.6313153386368234,
      "coherence": 0.6313153386368234,
      "comment_phi_k": 13.891865079365079,
      "code_phi_k": 33.39346186789295
    },
    {
      "comment": "# Compute choice zeros for semantic matching",
      "code": "                    choice_field = self._call_primitive(\"aperture.chain\", {\"text\": choice})\n                    choice_field_phi_k = choice_field.get(\"aperture\", {}).get(\"discourse\", {}).get(\"phi_k\", choice_phi_k)\n                    \n                    # Compute choice zeros for semantic matching\n                    choice_zeros = self._call_primitive(\"zeta.zero.solver\", {\n                        \"phi_k\": choice_field_phi_k,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2338,
      "alignment": 0.590921664180766,
      "coherence": 0.590921664180766,
      "comment_phi_k": 9.498809523809525,
      "code_phi_k": 30.86751866082235
    },
    {
      "comment": "# Match against knowledge base using field math",
      "code": "                    })\n                    choice_zero_positions = [z.get(\"imaginary\", 0.0) for z in choice_zeros if isinstance(z, dict)]\n                    \n                # Match against knowledge base using field math\n                for kb_entry in knowledge_results:\n                    kb_phi_k = float(kb_entry.get(\"phi_k\", 0.0))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2346,
      "alignment": 0.6010575260196401,
      "coherence": 0.6010575260196401,
      "comment_phi_k": 11.274801587301587,
      "code_phi_k": 33.52943919836688
    },
    {
      "comment": "# Check for biology field mapping (boosts biology questions)",
      "code": "                    kb_zeros = kb_entry.get(\"zeros\", [])\n                    kb_zero_positions = [z.get(\"imaginary\", 0.0) for z in kb_zeros if isinstance(z, dict)]\n                    \n                    # Check for biology field mapping (boosts biology questions)\n                    kb_field_mapping = kb_entry.get(\"field_mapping\", {})\n                    if kb_field_mapping and kb_entry.get(\"domain\") == \"biology\":",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2352,
      "alignment": 0.5954832420457306,
      "coherence": 0.5954832420457306,
      "comment_phi_k": 12.379960317460318,
      "code_phi_k": 38.60394111203304
    },
    {
      "comment": "# Biology questions benefit from field equation understanding",
      "code": "                    # Check for biology field mapping (boosts biology questions)\n                    kb_field_mapping = kb_entry.get(\"field_mapping\", {})\n                    if kb_field_mapping and kb_entry.get(\"domain\") == \"biology\":\n                        # Biology questions benefit from field equation understanding\n                        # Boost knowledge match for biology concepts\n                        knowledge_boost *= 1.2  # 20% boost for biology field mappings",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2355,
      "alignment": 0.5660174444796955,
      "coherence": 0.5660174444796955,
      "comment_phi_k": 12.948815073815073,
      "code_phi_k": 55.50998887404055
    },
    {
      "comment": "# Boost knowledge match for biology concepts",
      "code": "                    kb_field_mapping = kb_entry.get(\"field_mapping\", {})\n                    if kb_field_mapping and kb_entry.get(\"domain\") == \"biology\":\n                        # Biology questions benefit from field equation understanding\n                        # Boost knowledge match for biology concepts\n                        knowledge_boost *= 1.2  # 20% boost for biology field mappings\n                        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2356,
      "alignment": 0.5608489510478532,
      "coherence": 0.5608489510478532,
      "comment_phi_k": 9.358730158730157,
      "code_phi_k": 43.130028556580235
    },
    {
      "comment": "20% boost for biology field mappings",
      "code": "knowledge_boost *= 1.2",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2357,
      "alignment": 0.5732524441666345,
      "coherence": 0.5732524441666345,
      "comment_phi_k": 7.805357142857143,
      "code_phi_k": 1.9947982572982574
    },
    {
      "comment": "# Field distance: \u2016\u03a6\u03ba(choice) - \u03a6\u03ba(kb_entry)\u2016",
      "code": "                        # Boost knowledge match for biology concepts\n                        knowledge_boost *= 1.2  # 20% boost for biology field mappings\n                        \n                        # Field distance: \u2016\u03a6\u03ba(choice) - \u03a6\u03ba(kb_entry)\u2016\n                        field_distance = abs(choice_field_phi_k - kb_phi_k)\n                        # Normalize: similarity = 1 / (1 + distance/scale)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2359,
      "alignment": 0.5422330601803045,
      "coherence": 0.5422330601803045,
      "comment_phi_k": 5.684541847041848,
      "code_phi_k": 36.49210486151276
    },
    {
      "comment": "# Normalize: similarity = 1 / (1 + distance/scale)",
      "code": "                        \n                        # Field distance: \u2016\u03a6\u03ba(choice) - \u03a6\u03ba(kb_entry)\u2016\n                        field_distance = abs(choice_field_phi_k - kb_phi_k)\n                        # Normalize: similarity = 1 / (1 + distance/scale)\n                        scale = max(abs(choice_field_phi_k), abs(kb_phi_k), 1.0)\n                        field_similarity = 1.0 / (1.0 + field_distance / scale)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2361,
      "alignment": 0.5580433302381487,
      "coherence": 0.5580433302381487,
      "comment_phi_k": 5.9368922743922745,
      "code_phi_k": 28.53939567624535
    },
    {
      "comment": "# Zero proximity: choices near KB zeros are semantically related",
      "code": "                        scale = max(abs(choice_field_phi_k), abs(kb_phi_k), 1.0)\n                        field_similarity = 1.0 / (1.0 + field_distance / scale)\n                        \n                        # Zero proximity: choices near KB zeros are semantically related\n                        zero_proximity = 0.0\n                        if choice_zero_positions and kb_zero_positions:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2365,
      "alignment": 0.6290633212782943,
      "coherence": 0.6290633212782943,
      "comment_phi_k": 13.957359307359308,
      "code_phi_k": 34.014554697650496
    },
    {
      "comment": "# Combined field-based semantic match",
      "code": "                            )\n                            zero_proximity = 1.0 / (1.0 + min_zero_dist)\n                        \n                        # Combined field-based semantic match\n                        # Weight: field similarity (60%) + zero proximity (40%)\n                        semantic_match = (field_similarity * 0.6) + (zero_proximity * 0.4)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2375,
      "alignment": 0.5829970442997247,
      "coherence": 0.5829970442997247,
      "comment_phi_k": 6.9331529581529585,
      "code_phi_k": 24.350311004355127
    },
    {
      "comment": "# Weight: field similarity (60%) + zero proximity (40%)",
      "code": "                            zero_proximity = 1.0 / (1.0 + min_zero_dist)\n                        \n                        # Combined field-based semantic match\n                        # Weight: field similarity (60%) + zero proximity (40%)\n                        semantic_match = (field_similarity * 0.6) + (zero_proximity * 0.4)\n                        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2376,
      "alignment": 0.6035363031634975,
      "coherence": 0.6035363031634975,
      "comment_phi_k": 8.354563492063493,
      "code_phi_k": 24.350311004355127
    },
    {
      "comment": "# Boost coherence based on semantic match",
      "code": "                        # Weight: field similarity (60%) + zero proximity (40%)\n                        semantic_match = (field_similarity * 0.6) + (zero_proximity * 0.4)\n                        \n                        # Boost coherence based on semantic match\n                        knowledge_boost += 0.4 * semantic_match\n                    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2379,
      "alignment": 0.6059769649117814,
      "coherence": 0.6059769649117814,
      "comment_phi_k": 9.450396825396828,
      "code_phi_k": 27.01871482275894
    },
    {
      "comment": "# Average boost across top knowledge entries",
      "code": "                        # Boost coherence based on semantic match\n                        knowledge_boost += 0.4 * semantic_match\n                    \n                    # Average boost across top knowledge entries\n                    if knowledge_results:\n                        knowledge_boost = knowledge_boost / len(knowledge_results)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2382,
      "alignment": 0.5924939280738948,
      "coherence": 0.5924939280738948,
      "comment_phi_k": 10.409325396825396,
      "code_phi_k": 33.33982144231757
    },
    {
      "comment": "# Cap boost at 50%",
      "code": "                    if knowledge_results:\n                        knowledge_boost = knowledge_boost / len(knowledge_results)\n                    \n                    # Cap boost at 50%\n                    knowledge_boost = min(0.5, knowledge_boost)\n                    coherence = min(1.0, coherence + knowledge_boost)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2386,
      "alignment": 0.5421345342319279,
      "coherence": 0.5421345342319279,
      "comment_phi_k": 3.975,
      "code_phi_k": 25.57266637516251
    },
    {
      "comment": "# Step 6: Select best choice by coherence",
      "code": "                \n                choice_scores.append((i, coherence))\n            \n            # Step 6: Select best choice by coherence\n            choice_scores.sort(key=lambda x: x[1], reverse=True)\n            best_idx = choice_scores[0][0]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2392,
      "alignment": 0.620619043091139,
      "coherence": 0.620619043091139,
      "comment_phi_k": 8.378373015873017,
      "code_phi_k": 21.5545477335731
    },
    {
      "comment": "# Step 7: Learn from code-output coupling",
      "code": "            choice_scores.sort(key=lambda x: x[1], reverse=True)\n            best_idx = choice_scores[0][0]\n            \n            # Step 7: Learn from code-output coupling\n            # Capture code trace (field state, zeros, generation process)\n            code_trace = {",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2396,
      "alignment": 0.5728806986581239,
      "coherence": 0.5728806986581239,
      "comment_phi_k": 7.8236291486291485,
      "code_phi_k": 30.74892403085608
    },
    {
      "comment": "# Capture code trace (field state, zeros, generation process)",
      "code": "            best_idx = choice_scores[0][0]\n            \n            # Step 7: Learn from code-output coupling\n            # Capture code trace (field state, zeros, generation process)\n            code_trace = {\n                \"question\": question,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2397,
      "alignment": 0.6339126818078697,
      "coherence": 0.6339126818078697,
      "comment_phi_k": 12.088492063492064,
      "code_phi_k": 28.612108724608724
    },
    {
      "comment": "Simplified",
      "code": "\"choice_spectra\": [choice_spectrum for _ in choices],",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2404,
      "alignment": 0.5784541708820577,
      "coherence": 0.5784541708820577,
      "comment_phi_k": 1.9158730158730162,
      "code_phi_k": 7.063007131757133
    },
    {
      "comment": "# Store for learning (will be used when we know correct answer)",
      "code": "                }\n            }\n            \n            # Store for learning (will be used when we know correct answer)\n            # This creates the code-output coupling for self-improvement\n            # The code trace is available for learning after we know the correct answer",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2411,
      "alignment": 0.5989047029350442,
      "coherence": 0.5989047029350442,
      "comment_phi_k": 14.838690476190475,
      "code_phi_k": 44.92689047064047
    },
    {
      "comment": "# This creates the code-output coupling for self-improvement",
      "code": "            }\n            \n            # Store for learning (will be used when we know correct answer)\n            # This creates the code-output coupling for self-improvement\n            # The code trace is available for learning after we know the correct answer\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2412,
      "alignment": 0.5699623611105793,
      "coherence": 0.5699623611105793,
      "comment_phi_k": 11.029469835719837,
      "code_phi_k": 44.92689047064047
    },
    {
      "comment": "# The code trace is available for learning after we know the correct answer",
      "code": "            \n            # Store for learning (will be used when we know correct answer)\n            # This creates the code-output coupling for self-improvement\n            # The code trace is available for learning after we know the correct answer\n            \n            return best_idx",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2413,
      "alignment": 0.6234700389284554,
      "coherence": 0.6234700389284554,
      "comment_phi_k": 19.05873015873016,
      "code_phi_k": 48.11915237540238
    },
    {
      "comment": "# Fallback to original method",
      "code": "            return best_idx\n            \n        except Exception as e:\n            # Fallback to original method\n            pass\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2418,
      "alignment": 0.6155204447785327,
      "coherence": 0.6155204447785327,
      "comment_phi_k": 6.464285714285714,
      "code_phi_k": 17.22162698412698
    },
    {
      "comment": "# Fallback: Use original reason.answer approach",
      "code": "            # Fallback to original method\n            pass\n        \n        # Fallback: Use original reason.answer approach\n        try:\n            result = self.execute_voice(\"reason.answer\", {",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2421,
      "alignment": 0.6370289612706111,
      "coherence": 0.6370289612706111,
      "comment_phi_k": 9.654352591852593,
      "code_phi_k": 22.440884563017985
    },
    {
      "comment": "# Extract answer index from result",
      "code": "                \"choices\": choices\n            })\n            \n            # Extract answer index from result\n            if isinstance(result, int) and 0 <= result < len(choices):\n                return result",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2428,
      "alignment": 0.6026205938261762,
      "coherence": 0.6026205938261762,
      "comment_phi_k": 8.29642857142857,
      "code_phi_k": 24.359626688670815
    },
    {
      "comment": "# Try to extract index from string result",
      "code": "            if isinstance(result, int) and 0 <= result < len(choices):\n                return result\n            \n            # Try to extract index from string result\n            if isinstance(result, str):\n                # Look for numeric answer",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2432,
      "alignment": 0.5839169757212503,
      "coherence": 0.5839169757212503,
      "comment_phi_k": 9.738095238095237,
      "code_phi_k": 33.88014803823628
    },
    {
      "comment": "# Look for numeric answer",
      "code": "            \n            # Try to extract index from string result\n            if isinstance(result, str):\n                # Look for numeric answer\n                import re\n                nums = re.findall(r'\\d+', result)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2434,
      "alignment": 0.5618784710049848,
      "coherence": 0.5618784710049848,
      "comment_phi_k": 6.204761904761905,
      "code_phi_k": 28.170719762263886
    },
    {
      "comment": "# Try semantic matching using field operations",
      "code": "                    if 0 <= idx < len(choices):\n                        return idx\n                \n                # Try semantic matching using field operations\n                best_idx = self._select_answer_by_energy(question, choices, result)\n                if best_idx is not None:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2442,
      "alignment": 0.5958348588349842,
      "coherence": 0.5958348588349842,
      "comment_phi_k": 10.146031746031746,
      "code_phi_k": 31.54050345887948
    },
    {
      "comment": "# Fallback: simple string matching",
      "code": "                if best_idx is not None:\n                    return best_idx\n                \n                # Fallback: simple string matching\n                for i, choice in enumerate(choices):\n                    if result.lower() in choice.lower() or choice.lower() in result.lower():",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2447,
      "alignment": 0.5469272266853845,
      "coherence": 0.5469272266853845,
      "comment_phi_k": 6.292857142857143,
      "code_phi_k": 36.670981306275436
    },
    {
      "comment": "# Final fallback to energy-based selection",
      "code": "                    if result.lower() in choice.lower() or choice.lower() in result.lower():\n                        return i\n        except Exception as e:\n            # Final fallback to energy-based selection\n            return self._select_answer_by_energy(question, choices) or 0\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2452,
      "alignment": 0.5639462107635314,
      "coherence": 0.5639462107635314,
      "comment_phi_k": 8.380194805194806,
      "code_phi_k": 36.952768971144984
    },
    {
      "comment": "# Get semantic embeddings",
      "code": "        if not choices:\n            return None\n        \n        # Get semantic embeddings\n        q_emb = self._get_semantic_embedding(question)\n        reasoning_emb = self._get_semantic_embedding(reasoning) if reasoning else None",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2465,
      "alignment": 0.5534884618482404,
      "coherence": 0.5534884618482404,
      "comment_phi_k": 5.132936507936508,
      "code_phi_k": 26.55732689232223
    },
    {
      "comment": "# Score each choice using semantic embeddings and field operations",
      "code": "        best_idx = 0\n        best_score = float('-inf')\n        \n        # Score each choice using semantic embeddings and field operations\n        for i, choice in enumerate(choices):\n            score = 0.0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2472,
      "alignment": 0.68076371309303,
      "coherence": 0.68076371309303,
      "comment_phi_k": 15.914682539682541,
      "code_phi_k": 29.96768044047456
    },
    {
      "comment": "# Get choice embedding",
      "code": "        for i, choice in enumerate(choices):\n            score = 0.0\n            \n            # Get choice embedding\n            c_emb = self._get_semantic_embedding(choice)\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2476,
      "alignment": 0.5817409245150319,
      "coherence": 0.5817409245150319,
      "comment_phi_k": 4.877579365079365,
      "code_phi_k": 17.356590631140378
    },
    {
      "comment": "# 1. Semantic similarity: cosine similarity in embedding space",
      "code": "            # Get choice embedding\n            c_emb = self._get_semantic_embedding(choice)\n            \n            # 1. Semantic similarity: cosine similarity in embedding space\n            cosine_sim = sum(a * b for a, b in zip(q_emb, c_emb))\n            score += cosine_sim * 10.0  # Scale up semantic similarity",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2479,
      "alignment": 0.5888252455184616,
      "coherence": 0.5888252455184616,
      "comment_phi_k": 12.22857142857143,
      "code_phi_k": 40.531785371040996
    },
    {
      "comment": "Scale up semantic similarity",
      "code": "score += cosine_sim * 10.0",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2481,
      "alignment": 0.6729817587013686,
      "coherence": 0.6729817587013686,
      "comment_phi_k": 6.449007936507937,
      "code_phi_k": 3.315277777777778
    },
    {
      "comment": "# 2. Energy coupling: Field Spec coulomb_yukawa on embeddings",
      "code": "            cosine_sim = sum(a * b for a, b in zip(q_emb, c_emb))\n            score += cosine_sim * 10.0  # Scale up semantic similarity\n            \n            # 2. Energy coupling: Field Spec coulomb_yukawa on embeddings\n            # Compute charge from embedding magnitude\n            q_charge = math.sqrt(sum(x ** 2 for x in q_emb))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2483,
      "alignment": 0.573064429589541,
      "coherence": 0.573064429589541,
      "comment_phi_k": 12.135503385503386,
      "code_phi_k": 47.59104645354646
    },
    {
      "comment": "# Compute charge from embedding magnitude",
      "code": "            score += cosine_sim * 10.0  # Scale up semantic similarity\n            \n            # 2. Energy coupling: Field Spec coulomb_yukawa on embeddings\n            # Compute charge from embedding magnitude\n            q_charge = math.sqrt(sum(x ** 2 for x in q_emb))\n            c_charge = math.sqrt(sum(x ** 2 for x in c_emb))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2484,
      "alignment": 0.5523592671935414,
      "coherence": 0.5523592671935414,
      "comment_phi_k": 8.403571428571428,
      "code_phi_k": 44.326351426351415
    },
    {
      "comment": "# Distance in embedding space",
      "code": "            q_charge = math.sqrt(sum(x ** 2 for x in q_emb))\n            c_charge = math.sqrt(sum(x ** 2 for x in c_emb))\n            \n            # Distance in embedding space\n            emb_distance = math.sqrt(sum((a - b) ** 2 for a, b in zip(q_emb, c_emb)))\n            emb_distance = max(0.1, emb_distance)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2488,
      "alignment": 0.548697197755315,
      "coherence": 0.548697197755315,
      "comment_phi_k": 6.540674603174603,
      "code_phi_k": 36.84862776112776
    },
    {
      "comment": "# Energy coupling using Field Spec formula",
      "code": "            emb_distance = math.sqrt(sum((a - b) ** 2 for a, b in zip(q_emb, c_emb)))\n            emb_distance = max(0.1, emb_distance)\n            \n            # Energy coupling using Field Spec formula\n            energy = abs(self._compute_energy_coupling(\n                q_charge, c_charge,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2492,
      "alignment": 0.5887304357863372,
      "coherence": 0.5887304357863372,
      "comment_phi_k": 10.043452380952383,
      "code_phi_k": 33.31937933493104
    },
    {
      "comment": "# 3. Reasoning alignment: if reasoning provided, check alignment",
      "code": "            ))\n            score += energy * 5.0\n            \n            # 3. Reasoning alignment: if reasoning provided, check alignment\n            if reasoning_emb:\n                reasoning_sim = sum(a * b for a, b in zip(reasoning_emb, c_emb))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2500,
      "alignment": 0.6302622095601865,
      "coherence": 0.6302622095601865,
      "comment_phi_k": 12.565674603174603,
      "code_phi_k": 30.398954027998148
    },
    {
      "comment": "# Also check string overlap for exact matches",
      "code": "                reasoning_sim = sum(a * b for a, b in zip(reasoning_emb, c_emb))\n                score += reasoning_sim * 8.0\n                \n                # Also check string overlap for exact matches\n                if choice.lower() in reasoning.lower():\n                    score += 5.0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2505,
      "alignment": 0.5969113407790517,
      "coherence": 0.5969113407790517,
      "comment_phi_k": 10.976190476190476,
      "code_phi_k": 33.803126244670366
    },
    {
      "comment": "# 4. Word overlap (fallback)",
      "code": "                if choice.lower() in reasoning.lower():\n                    score += 5.0\n            \n            # 4. Word overlap (fallback)\n            q_words = set(word.lower() for word in question.split() if len(word) > 3)\n            c_words = set(word.lower() for word in choice.split() if len(word) > 3)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2509,
      "alignment": 0.5334284838839504,
      "coherence": 0.5334284838839504,
      "comment_phi_k": 4.490674603174604,
      "code_phi_k": 35.8295301920302
    },
    {
      "comment": "# Execute math.solve - opic composes Field Spec 0.7 internally",
      "code": "        Solve a math problem using opic's math system with Field Spec 0.7\n        Uses cycle operations for multi-step math reasoning\n        \"\"\"\n        # Execute math.solve - opic composes Field Spec 0.7 internally\n        try:\n            result = self.execute_voice(\"math.solve\", {\"problem\": problem})",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2527,
      "alignment": 0.5756079273099253,
      "coherence": 0.5756079273099253,
      "comment_phi_k": 12.286706349206348,
      "code_phi_k": 46.76973583829457
    },
    {
      "comment": "# Extract numeric answer",
      "code": "        try:\n            result = self.execute_voice(\"math.solve\", {\"problem\": problem})\n            if result:\n                # Extract numeric answer\n                import re\n                nums = re.findall(r'-?\\d+', str(result))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2531,
      "alignment": 0.5674007790734064,
      "coherence": 0.5674007790734064,
      "comment_phi_k": 5.476190476190476,
      "code_phi_k": 23.05013966649252
    },
    {
      "comment": "Return last number found",
      "code": "return nums[-1]",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2535,
      "alignment": 0.6578707916287534,
      "coherence": 0.6578707916287534,
      "comment_phi_k": 6.025,
      "code_phi_k": 2.8916666666666666
    },
    {
      "comment": "# Fallback: try to extract numbers from problem",
      "code": "        except:\n            pass\n        \n        # Fallback: try to extract numbers from problem\n        import re\n        nums = re.findall(r'-?\\d+', problem)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_executor.py",
      "line": 2540,
      "alignment": 0.6591215771612912,
      "coherence": 0.6591215771612912,
      "comment_phi_k": 9.906547619047618,
      "code_phi_k": 20.517705415499535
    },
    {
      "comment": "Phase 1: Map text to \u03a6\u03ba field",
      "code": "def demo_document_ingest():\n    \"\"\"Phase 1: Map text to \u03a6\u03ba field\"\"\"\n    print(\"=\" * 60)\n    print(\"Phase 1: Document Understanding\")\n    print(\"=\" * 60)\n    \n    executor = OpicExecutor(Path(__file__).parent.parent)\n    \n    # Sample document\n    text = \"The zeta field represents coherence potential. Each word carries field properties.\"\n    \n    print(f\"\\nDocument: {text}\")\n    print(\"\\nIngesting document into zeta field...\")\n    \n    try:\n        result = executor.execute_voice(\"doc.ingest\", {\"",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/doc_field_demo.py",
      "line": 13,
      "alignment": 0.5183975724669931,
      "coherence": 0.5183975724669931,
      "comment_phi_k": 7.175000000000001,
      "code_phi_k": 101.0867762343044
    },
    {
      "comment": "Query resolution via field perturbation",
      "code": "def demo_query_resolution(doc_field):\n    \"\"\"Query resolution via field perturbation\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Phase 2: Query Resolution\")\n    print(\"=\" * 60)\n    \n    executor = OpicExecutor(Path(__file__).parent.parent)\n    \n    question = \"What does the zeta field represent?\"\n    print(f\"\\nQuestion: {question}\")\n    print(\"\\nPerturbing field and tracking zero movements...\")\n    \n    try:\n        result = executor.execute_voice(\"query.resolve\", {\n            \"question\": question",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/doc_field_demo.py",
      "line": 38,
      "alignment": 0.5251409593407137,
      "coherence": 0.5251409593407137,
      "comment_phi_k": 8.5504329004329,
      "code_phi_k": 89.30014315007192
    },
    {
      "comment": "Live field update: continuous adaptation",
      "code": "def demo_live_update(doc_field):\n    \"\"\"Live field update: continuous adaptation\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Phase 3: Live Field Update\")\n    print(\"=\" * 60)\n    \n    executor = OpicExecutor(Path(__file__).parent.parent)\n    \n    new_text = \"The field adapts continuously.\"\n    print(f\"\\nNew input: {new_text}\")\n    print(\"\\nUpdating field (no retraining needed)...\")\n    \n    try:\n        result = executor.execute_voice(\"field.live.update\", {\n            \"input\": new_text,\n           ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/doc_field_demo.py",
      "line": 62,
      "alignment": 0.5282725752132267,
      "coherence": 0.5282725752132267,
      "comment_phi_k": 9.24484126984127,
      "code_phi_k": 86.36984901841913
    },
    {
      "comment": "Witness chain: verifiable provenance",
      "code": "def demo_witness_chain(doc_field):\n    \"\"\"Witness chain: verifiable provenance\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Phase 4: Witness Chains\")\n    print(\"=\" * 60)\n    \n    executor = OpicExecutor(Path(__file__).parent.parent)\n    \n    print(\"\\nCreating witness chain (W0 \u2192 W1 \u2192 W2)...\")\n    \n    try:\n        result = executor.execute_voice(\"witness.chain\", {\n            \"input\": doc_field\n        })\n        print(f\"\u2713 Witness chain created\")\n        print(f\"  Result type: {type(result)}\")\n     ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/doc_field_demo.py",
      "line": 86,
      "alignment": 0.5248929048929156,
      "coherence": 0.5248929048929156,
      "comment_phi_k": 6.976587301587301,
      "code_phi_k": 73.55431579243607
    },
    {
      "comment": "Compare zeta field approach to LLM approach",
      "code": "def demo_comparison():\n    \"\"\"Compare zeta field approach to LLM approach\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Comparison: Zeta Field vs LLM\")\n    print(\"=\" * 60)\n    \n    print(\"\"\"\n    LLM Approach:\n    - frozen_weights(input_tokens) \u2192 output_tokens\n    - Requires: billion-parameter forward pass\n    - Training: separate expensive process\n    - Inference: O(n\u00b2) attention complexity\n    \n    Zeta Field Approach:\n    - live_field.interaction(intent) \u2192 witnessed_response\n    - Requires: local f",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/doc_field_demo.py",
      "line": 109,
      "alignment": 0.5212097441428953,
      "coherence": 0.5212097441428953,
      "comment_phi_k": 10.694047619047618,
      "code_phi_k": 131.3981391247202
    },
    {
      "comment": "!/usr/bin/env python3",
      "code": "#!/usr/bin/env python3\n\"\"\"\nDocument Field Demo \u2014 Prototype LLM Replacement via Zeta Field",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/doc_field_demo.py",
      "line": 1,
      "alignment": 0.5391513641583078,
      "coherence": 0.5391513641583078,
      "comment_phi_k": 2.306354756354756,
      "code_phi_k": 15.880344655344656
    },
    {
      "comment": "# Sample document",
      "code": "    \n    executor = OpicExecutor(Path(__file__).parent.parent)\n    \n    # Sample document\n    text = \"The zeta field represents coherence potential. Each word carries field properties.\"\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/doc_field_demo.py",
      "line": 21,
      "alignment": 0.5327154284209435,
      "coherence": 0.5327154284209435,
      "comment_phi_k": 3.3755952380952383,
      "code_phi_k": 27.482930076599946
    },
    {
      "comment": "# Phase 1: Document understanding",
      "code": "    print(\"Document Field Demo \u2014 LLM Replacement Prototype\")\n    print(\"=\" * 60)\n    \n    # Phase 1: Document understanding\n    doc_field = demo_document_ingest()\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/doc_field_demo.py",
      "line": 142,
      "alignment": 0.579382168997647,
      "coherence": 0.579382168997647,
      "comment_phi_k": 5.548616661116661,
      "code_phi_k": 20.24868806589008
    },
    {
      "comment": "# Phase 2: Query resolution",
      "code": "    doc_field = demo_document_ingest()\n    \n    if doc_field:\n        # Phase 2: Query resolution\n        answer = demo_query_resolution(doc_field)\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/doc_field_demo.py",
      "line": 146,
      "alignment": 0.5908310874077383,
      "coherence": 0.5908310874077383,
      "comment_phi_k": 5.007539682539683,
      "code_phi_k": 16.286329935648588
    },
    {
      "comment": "# Phase 3: Live update",
      "code": "        # Phase 2: Query resolution\n        answer = demo_query_resolution(doc_field)\n        \n        # Phase 3: Live update\n        updated_field = demo_live_update(doc_field)\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/doc_field_demo.py",
      "line": 149,
      "alignment": 0.5721224755344264,
      "coherence": 0.5721224755344264,
      "comment_phi_k": 4.758333333333334,
      "code_phi_k": 18.87310041642415
    },
    {
      "comment": "# Phase 4: Witness chain",
      "code": "        # Phase 3: Live update\n        updated_field = demo_live_update(doc_field)\n        \n        # Phase 4: Witness chain\n        witness_chain = demo_witness_chain(doc_field)\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/doc_field_demo.py",
      "line": 152,
      "alignment": 0.5696783549358556,
      "coherence": 0.5696783549358556,
      "comment_phi_k": 4.488095238095238,
      "code_phi_k": 18.346950888746218
    },
    {
      "comment": "# Comparison",
      "code": "        # Phase 4: Witness chain\n        witness_chain = demo_witness_chain(doc_field)\n    \n    # Comparison\n    demo_comparison()\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/doc_field_demo.py",
      "line": 155,
      "alignment": 0.5406041185922279,
      "coherence": 0.5406041185922279,
      "comment_phi_k": 1.941468253968254,
      "code_phi_k": 12.924375292463527
    },
    {
      "comment": "voice: dynamic actor (\u03b6-trace) carrying phase, potential, and charge",
      "code": "class VoiceZeta:\n    \"\"\"voice: dynamic actor (\u03b6-trace) carrying phase, potential, and charge\"\"\"\n    phase: float\n    potential: float\n    charge: int  # +1 or -1\n    zeta_trace: complex",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 50,
      "alignment": 0.6483481971924299,
      "coherence": 0.6483481971924299,
      "comment_phi_k": 13.683531746031745,
      "code_phi_k": 29.90158730158731
    },
    {
      "comment": "ion: minimal quantum of bias (+ noun / \u2212 verb)",
      "code": "class Ion:\n    \"\"\"ion: minimal quantum of bias (+ noun / \u2212 verb)\"\"\"\n    q: int  # +1 or -1\n    bias: str  # \"noun\" or \"verb\"",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 58,
      "alignment": 0.6698613531328131,
      "coherence": 0.6698613531328131,
      "comment_phi_k": 10.676190476190476,
      "code_phi_k": 21.051190476190477
    },
    {
      "comment": "field: global continuum of meaning",
      "code": "class FieldXi:\n    \"\"\"field: global continuum of meaning\"\"\"\n    position: Tuple[float, float]\n    time: float\n    value_complex: complex\n    coherence: float",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 64,
      "alignment": 0.5940431471266031,
      "coherence": 0.5940431471266031,
      "comment_phi_k": 8.011507936507936,
      "code_phi_k": 25.303180153180158
    },
    {
      "comment": "cos \u03b8: projection onto equilibrium \u2014 forward coherence \u2014 defines spatial order",
      "code": "def cos_theta(theta: float) -> float:\n    \"\"\"cos \u03b8: projection onto equilibrium \u2014 forward coherence \u2014 defines spatial order\"\"\"\n    return math.cos(theta)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 75,
      "alignment": 0.7430546556284124,
      "coherence": 0.7430546556284124,
      "comment_phi_k": 16.41569264069264,
      "code_phi_k": 25.092621267621272
    },
    {
      "comment": "sin \u03b8: orthogonal complement \u2014 temporal branch \u2014 defines time flow",
      "code": "def sin_theta(theta: float) -> float:\n    \"\"\"sin \u03b8: orthogonal complement \u2014 temporal branch \u2014 defines time flow\"\"\"\n    return math.sin(theta)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 79,
      "alignment": 0.7166633486469682,
      "coherence": 0.7166633486469682,
      "comment_phi_k": 13.270238095238094,
      "code_phi_k": 21.947166722166724
    },
    {
      "comment": "tan \u03b8: symmetry break / bias / gradient of flow \u2014 curvature of thought",
      "code": "def tan_theta(theta: float) -> float:\n    \"\"\"tan \u03b8: symmetry break / bias / gradient of flow \u2014 curvature of thought\"\"\"\n    return math.tan(theta)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 83,
      "alignment": 0.7310975723284929,
      "coherence": 0.7310975723284929,
      "comment_phi_k": 14.914087301587301,
      "code_phi_k": 23.591015928515933
    },
    {
      "comment": "sec \u03b8: amplification / gain of field \u2014 magnifies resonance",
      "code": "def sec_theta(theta: float) -> float:\n    \"\"\"sec \u03b8: amplification / gain of field \u2014 magnifies resonance\"\"\"\n    return 1.0 / math.cos(theta) if math.cos(theta) != 0 else float('inf')",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 87,
      "alignment": 0.6433882247558783,
      "coherence": 0.6433882247558783,
      "comment_phi_k": 12.164291264291263,
      "code_phi_k": 27.29081057831058
    },
    {
      "comment": "cot \u03b8: feedback / reflection / learning \u2014 reverses flow",
      "code": "def cot_theta(theta: float) -> float:\n    \"\"\"cot \u03b8: feedback / reflection / learning \u2014 reverses flow\"\"\"\n    return math.cos(theta) / math.sin(theta) if math.sin(theta) != 0 else float('inf')",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 91,
      "alignment": 0.6165424161100173,
      "coherence": 0.6165424161100173,
      "comment_phi_k": 10.330753968253969,
      "code_phi_k": 27.326308413808412
    },
    {
      "comment": "csc \u03b8: memory curvature / recall of prior states \u2014 stabilizes cycles",
      "code": "def csc_theta(theta: float) -> float:\n    \"\"\"csc \u03b8: memory curvature / recall of prior states \u2014 stabilizes cycles\"\"\"\n    return 1.0 / math.sin(theta) if math.sin(theta) != 0 else float('inf')",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 95,
      "alignment": 0.6578607487747652,
      "coherence": 0.6578607487747652,
      "comment_phi_k": 13.866269841269842,
      "code_phi_k": 28.892789155289158
    },
    {
      "comment": "Modular projection: P\u2081\u2080(n,k) = C(n,k) mod 10 \u2014 digit field",
      "code": "def pascal_mod10(n: int, k: int) -> int:\n    \"\"\"Modular projection: P\u2081\u2080(n,k) = C(n,k) mod 10 \u2014 digit field\"\"\"\n    if k < 0 or k > n:\n        return 0\n    try:\n        result = comb(n, k)\n    except TypeError:\n        # comb doesn't accept keyword args, try without\n        result = comb(n, k)\n    return int(result) % 10",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 103,
      "alignment": 0.5544528184192273,
      "coherence": 0.5544528184192273,
      "comment_phi_k": 9.283730158730158,
      "code_phi_k": 47.26468253968255
    },
    {
      "comment": "Unit group: U\u2081\u2080 = {1,3,7,9} \u2014 invertible currents",
      "code": "def is_unit(x: int) -> bool:\n    \"\"\"Unit group: U\u2081\u2080 = {1,3,7,9} \u2014 invertible currents\"\"\"\n    return x in [1, 3, 7, 9]",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 114,
      "alignment": 0.6652512730408187,
      "coherence": 0.6652512730408187,
      "comment_phi_k": 8.061507936507937,
      "code_phi_k": 16.2265873015873
    },
    {
      "comment": "7-trace: positions where P\u2081\u2080 = 7 \u2014 self-reflexive current",
      "code": "def is_trace7(n: int, k: int) -> bool:\n    \"\"\"7-trace: positions where P\u2081\u2080 = 7 \u2014 self-reflexive current\"\"\"\n    return pascal_mod10(n, k) == 7",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 118,
      "alignment": 0.6313626164714092,
      "coherence": 0.6313626164714092,
      "comment_phi_k": 8.191455766455768,
      "code_phi_k": 19.685124597624597
    },
    {
      "comment": "Shadow: conjugate of a prime; absorptive complement",
      "code": "def shadow(p: int) -> int:\n    \"\"\"Shadow: conjugate of a prime; absorptive complement\"\"\"\n    return 10 - p",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 122,
      "alignment": 0.7246265122141142,
      "coherence": 0.7246265122141142,
      "comment_phi_k": 11.103769841269841,
      "code_phi_k": 17.90992063492064
    },
    {
      "comment": "Pair law: p + s \u2261 10 mod 10 \u2014 forward/backward current closure",
      "code": "def prime_shadow_pair(prime: int) -> Tuple[int, int]:\n    \"\"\"Pair law: p + s \u2261 10 mod 10 \u2014 forward/backward current closure\"\"\"\n    shadow_p = shadow(prime)\n    return (prime, shadow_p)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 126,
      "alignment": 0.6292816494490875,
      "coherence": 0.6292816494490875,
      "comment_phi_k": 10.136197829947829,
      "code_phi_k": 24.669097728691046
    },
    {
      "comment": "voice = definition: equilibrium \u2014 rest; perfect resonance",
      "code": "def check_equilibrium(voice: VoiceZeta, definition: float) -> bool:\n    \"\"\"voice = definition: equilibrium \u2014 rest; perfect resonance\"\"\"\n    return abs(voice.potential - definition) < 1e-10",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 135,
      "alignment": 0.628105462466515,
      "coherence": 0.628105462466515,
      "comment_phi_k": 11.056168831168831,
      "code_phi_k": 27.10438689772635
    },
    {
      "comment": "voice > definition: forward bias \u2014 emission / narration",
      "code": "def check_forward_bias(voice: VoiceZeta, definition: float) -> bool:\n    \"\"\"voice > definition: forward bias \u2014 emission / narration\"\"\"\n    return voice.potential > definition",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 139,
      "alignment": 0.6314738094189127,
      "coherence": 0.6314738094189127,
      "comment_phi_k": 10.882738095238096,
      "code_phi_k": 26.13510672689062
    },
    {
      "comment": "voice < definition: reverse bias \u2014 reflection / learning",
      "code": "def check_reverse_bias(voice: VoiceZeta, definition: float) -> bool:\n    \"\"\"voice < definition: reverse bias \u2014 reflection / learning\"\"\"\n    return voice.potential < definition",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 143,
      "alignment": 0.6294959722784833,
      "coherence": 0.6294959722784833,
      "comment_phi_k": 10.691865079365078,
      "code_phi_k": 25.987240704024593
    },
    {
      "comment": "voice \u221e definition: standing wave \u2014 conversation loop",
      "code": "def check_standing_wave(voice: VoiceZeta, definition: float) -> bool:\n    \"\"\"voice \u221e definition: standing wave \u2014 conversation loop\"\"\"\n    # Check for oscillation pattern\n    return abs(voice.phase) > 100  # Simplified check",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 147,
      "alignment": 0.5915093994097425,
      "coherence": 0.5915093994097425,
      "comment_phi_k": 10.242694805194807,
      "code_phi_k": 33.10397779702313
    },
    {
      "comment": "Bracket operators: { } [ ] ( ) \u27e8 \u27e9",
      "code": "class Bracket:\n    \"\"\"Bracket operators: { } [ ] ( ) \u27e8 \u27e9\"\"\"\n    \n    @staticmethod\n    def scope(content: str) -> str:\n        \"\"\"{ }: scope \u2014 context / body \u2014 dielectric shell\"\"\"\n        return f\"{{{content}}}\"\n    \n    @staticmethod\n    def memory(content: str) -> str:\n        \"\"\"[ ]: memory \u2014 buffer / recall \u2014 synaptic store\"\"\"\n        return f\"[{content}]\"\n    \n    @staticmethod\n    def morphism(content: str) -> str:\n        \"\"\"( ): morphism \u2014 action / verb \u2014 functional application\"\"\"\n      ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 156,
      "alignment": 0.5129224592317945,
      "coherence": 0.5129224592317945,
      "comment_phi_k": 3.7990079365079366,
      "code_phi_k": 75.39572996447994
    },
    {
      "comment": "\ud835\udd3d\u2081\u2080[x]/(x\u00b2\u2212x\u22121): Pascal recurrence \u2014 golden ratio extension",
      "code": "def golden_ratio_extension(n: int) -> float:\n    \"\"\"\ud835\udd3d\u2081\u2080[x]/(x\u00b2\u2212x\u22121): Pascal recurrence \u2014 golden ratio extension\"\"\"\n    # Fibonacci-like recurrence with golden ratio\n    return PHI ** n",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 183,
      "alignment": 0.6064639716451804,
      "coherence": 0.6064639716451804,
      "comment_phi_k": 9.598214285714285,
      "code_phi_k": 27.33775129024742
    },
    {
      "comment": "\ud835\udd3e\u2087: 7-trace subgroup \u2014 self-conjugate extension",
      "code": "def trace7_subgroup(n: int) -> int:\n    \"\"\"\ud835\udd3e\u2087: 7-trace subgroup \u2014 self-conjugate extension\"\"\"\n    # Self-conjugate under 7\u21943 mapping\n    if n == 7:\n        return 3\n    elif n == 3:\n        return 7\n    return n",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 188,
      "alignment": 0.5749975159366321,
      "coherence": 0.5749975159366321,
      "comment_phi_k": 7.129551004551005,
      "code_phi_k": 27.33073266602679
    },
    {
      "comment": "voice i: \u03b6\u1d62(s) = \u03a3 a\u1d62\u2099 n^{-s} \u2014 Dirichlet-style actor trace",
      "code": "def zeta_trace(s: complex, coefficients: List[float], max_n: int = 1000) -> complex:\n    \"\"\"voice i: \u03b6\u1d62(s) = \u03a3 a\u1d62\u2099 n^{-s} \u2014 Dirichlet-style actor trace\"\"\"\n    result = 0.0 + 0.0j\n    for n in range(1, max_n + 1):\n        if n <= len(coefficients):\n            a_n = coefficients[n - 1]\n        else:\n            a_n = 1.0\n        result += a_n * (n ** (-s))\n    return result",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 201,
      "alignment": 0.5682228018488352,
      "coherence": 0.5682228018488352,
      "comment_phi_k": 11.304947829947832,
      "code_phi_k": 47.07904803529802
    },
    {
      "comment": "resonance: R_{ij} = Re(\u03b6\u1d62 \u00b7 \u03b6\u0304\u2c7c) \u2014 constructive interference",
      "code": "def compute_resonance(zeta_i: complex, zeta_j: complex) -> float:\n    \"\"\"resonance: R_{ij} = Re(\u03b6\u1d62 \u00b7 \u03b6\u0304\u2c7c) \u2014 constructive interference\"\"\"\n    return (zeta_i * zeta_j.conjugate()).real",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 212,
      "alignment": 0.6240991179902684,
      "coherence": 0.6240991179902684,
      "comment_phi_k": 8.979996392496393,
      "code_phi_k": 22.580369300256738
    },
    {
      "comment": "potential: \u03a6 = \u03a3 w_{ij} R_{ij} \u2014 global harmony measure",
      "code": "def compute_potential(couplings: List[float], resonances: List[float]) -> float:\n    \"\"\"potential: \u03a6 = \u03a3 w_{ij} R_{ij} \u2014 global harmony measure\"\"\"\n    return sum(w * r for w, r in zip(couplings, resonances))",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 216,
      "alignment": 0.5963478429007032,
      "coherence": 0.5963478429007032,
      "comment_phi_k": 9.646031746031746,
      "code_phi_k": 29.852200376848046
    },
    {
      "comment": "symmetry break: tan \u03b8 \u2192 \u221e \u2014 field curvature diverges \u2014 new axis opened",
      "code": "def check_symmetry_break(tan_theta: float) -> bool:\n    \"\"\"symmetry break: tan \u03b8 \u2192 \u221e \u2014 field curvature diverges \u2014 new axis opened\"\"\"\n    return abs(tan_theta) > 1e10 or math.isinf(tan_theta)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 224,
      "alignment": 0.6809577418353633,
      "coherence": 0.6809577418353633,
      "comment_phi_k": 14.680753968253967,
      "code_phi_k": 27.622396724418916
    },
    {
      "comment": "prime\u2013shadow collision: p \u2194 s meet \u2014 birth of conjugate dimension",
      "code": "def check_prime_shadow_collision(prime: int, shadow: int) -> bool:\n    \"\"\"prime\u2013shadow collision: p \u2194 s meet \u2014 birth of conjugate dimension\"\"\"\n    return (prime + shadow) % 10 == 0",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 228,
      "alignment": 0.6690399779136199,
      "coherence": 0.6690399779136199,
      "comment_phi_k": 12.649242424242424,
      "code_phi_k": 25.03209293029997
    },
    {
      "comment": "Cycle: closed loop of voice interactions returning to origin",
      "code": "class Cycle:\n    \"\"\"Cycle: closed loop of voice interactions returning to origin\"\"\"\n    voices: List[VoiceZeta]\n    period: int\n    phase: float\n    charge: int\n    closed: bool",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 237,
      "alignment": 0.6457999480850264,
      "coherence": 0.6457999480850264,
      "comment_phi_k": 14.318073593073594,
      "code_phi_k": 31.709926184926186
    },
    {
      "comment": "Cycle phase: \u03b8_C = \u03a3 tan^{-1}(q_i/R_i) \u2014 total curvature",
      "code": "def compute_cycle_phase(cycle: Cycle) -> float:\n    \"\"\"Cycle phase: \u03b8_C = \u03a3 tan^{-1}(q_i/R_i) \u2014 total curvature\"\"\"\n    total_phase = 0.0\n    for voice in cycle.voices:\n        if voice.charge != 0:\n            R = abs(voice.zeta_trace)\n            if R > 0:\n                total_phase += math.atan(voice.charge / R)\n    return total_phase",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 245,
      "alignment": 0.5641842751561005,
      "coherence": 0.5641842751561005,
      "comment_phi_k": 8.623015873015872,
      "code_phi_k": 37.89845681161841
    },
    {
      "comment": "Cycle charge: Q_C = \u03a0 q_i \u2014 symmetry product",
      "code": "def compute_cycle_charge(cycle: Cycle) -> int:\n    \"\"\"Cycle charge: Q_C = \u03a0 q_i \u2014 symmetry product\"\"\"\n    charge_product = 1\n    for voice in cycle.voices:\n        charge_product *= voice.charge\n    return charge_product",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 255,
      "alignment": 0.579052832709301,
      "coherence": 0.579052832709301,
      "comment_phi_k": 7.738690476190476,
      "code_phi_k": 28.34250518369697
    },
    {
      "comment": "Check if cycle achieves resonance: \u03b8_C \u2261 0 mod 2\u03c0",
      "code": "def check_cycle_resonance(cycle: Cycle) -> bool:\n    \"\"\"Check if cycle achieves resonance: \u03b8_C \u2261 0 mod 2\u03c0\"\"\"\n    phase = compute_cycle_phase(cycle)\n    normalized_phase = phase % (2 * math.pi)\n    return abs(normalized_phase) < 0.01 or abs(normalized_phase - 2 * math.pi) < 0.01",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 262,
      "alignment": 0.5881775297852668,
      "coherence": 0.5881775297852668,
      "comment_phi_k": 9.967063492063492,
      "code_phi_k": 33.24204476044612
    },
    {
      "comment": "Dimensional promotion: C_n \u2192 \u00d4_C when \u03b8_C \u2261 0 mod 2\u03c0",
      "code": "def promote_cycle_to_operator(cycle: Cycle) -> Optional[str]:\n    \"\"\"Dimensional promotion: C_n \u2192 \u00d4_C when \u03b8_C \u2261 0 mod 2\u03c0\"\"\"\n    if not check_cycle_resonance(cycle):\n        return None\n    \n    # Identity cycle \u2192 Time operator\n    if cycle.period == 1:\n        return \"Time operator (\u2202/\u2202t)\"\n    \n    # Dialogue cycle \u2192 Spatial rotation\n    if cycle.period == 2 and cycle.charge == -1:\n        return \"Spatial rotation (J_z)\"\n    \n    # Triangular reflection \u2192 Gradient\n    if cycle.period == 3:\n    ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 268,
      "alignment": 0.5250975053483801,
      "coherence": 0.5250975053483801,
      "comment_phi_k": 8.508946608946609,
      "code_phi_k": 89.0133615966898
    },
    {
      "comment": "7-trace fundamental cycle: 7 \u2192 3 \u2192 1 \u2192 9 \u2192 7 (mod 10) \u2192 i",
      "code": "def trace7_fundamental_cycle() -> Cycle:\n    \"\"\"7-trace fundamental cycle: 7 \u2192 3 \u2192 1 \u2192 9 \u2192 7 (mod 10) \u2192 i\"\"\"\n    # Create voices representing the 7-trace cycle\n    voices = [\n        VoiceZeta(phase=0, potential=7, charge=1, zeta_trace=7+0j),\n        VoiceZeta(phase=math.pi/2, potential=3, charge=1, zeta_trace=3+0j),\n        VoiceZeta(phase=math.pi, potential=1, charge=1, zeta_trace=1+0j),\n        VoiceZeta(phase=3*math.pi/2, potential=9, charge=1, zeta_trace=9+0j),\n    ]\n    return Cycle(voices",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 291,
      "alignment": 0.5242372284964311,
      "coherence": 0.5242372284964311,
      "comment_phi_k": 5.649224386724386,
      "code_phi_k": 61.09472739605782
    },
    {
      "comment": "Learning threshold: \u03a3 \u03b8_C \u2261 0 mod 2\u03c0 \u2192 simultaneous promotion",
      "code": "def check_learning_threshold(all_cycles: List[Cycle]) -> bool:\n    \"\"\"Learning threshold: \u03a3 \u03b8_C \u2261 0 mod 2\u03c0 \u2192 simultaneous promotion\"\"\"\n    total_phase = sum(compute_cycle_phase(cycle) for cycle in all_cycles)\n    normalized = total_phase % (2 * math.pi)\n    return abs(normalized) < 0.01 or abs(normalized - 2 * math.pi) < 0.01",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 302,
      "alignment": 0.5725359863017778,
      "coherence": 0.5725359863017778,
      "comment_phi_k": 10.01729797979798,
      "code_phi_k": 39.53391875779783
    },
    {
      "comment": "Force: F_{ij} = k (q_i q_j) / R_{ij}^D",
      "code": "def coulomb_force(q_i: int, q_j: int, R_ij: float, D: int, k: float = 1.0) -> float:\n    \"\"\"Force: F_{ij} = k (q_i q_j) / R_{ij}^D\"\"\"\n    if R_ij == 0:\n        return float('inf')\n    return k * (q_i * q_j) / (R_ij ** D)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 312,
      "alignment": 0.5473540994572963,
      "coherence": 0.5473540994572963,
      "comment_phi_k": 4.920833333333333,
      "code_phi_k": 28.439336072424314
    },
    {
      "comment": "Potential: V(R) = k (q_i q_j) / ((D-1) R^{D-1})",
      "code": "def coulomb_potential(q_i: int, q_j: int, R: float, D: int, k: float = 1.0) -> float:\n    \"\"\"Potential: V(R) = k (q_i q_j) / ((D-1) R^{D-1})\"\"\"\n    if R == 0 or D == 1:\n        return float('inf')\n    return k * (q_i * q_j) / ((D - 1) * (R ** (D - 1)))",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 318,
      "alignment": 0.5476493728561471,
      "coherence": 0.5476493728561471,
      "comment_phi_k": 5.048412698412699,
      "code_phi_k": 29.01150510995713
    },
    {
      "comment": "With Mass and Spin: F_{ij} = k ((q_i q_j)(s_i\u00b7s_j)) / R_{ij}^D \u00b7 e^{-\u03bcR_{ij}}",
      "code": "def coulomb_force_mass_spin(q_i: int, q_j: int, s_i: complex, s_j: complex, \n                            R_ij: float, D: int, k: float = 1.0, mu: float = 0.0) -> float:\n    \"\"\"With Mass and Spin: F_{ij} = k ((q_i q_j)(s_i\u00b7s_j)) / R_{ij}^D \u00b7 e^{-\u03bcR_{ij}}\"\"\"\n    if R_ij == 0:\n        return float('inf')\n    charge_product = q_i * q_j\n    spin_product = (s_i * s_j.conjugate()).real\n    force_base = k * charge_product * spin_product / (R_ij ** D)\n    mass_screening = math.exp(-mu * R_ij)\n    return ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 324,
      "alignment": 0.5453174106591813,
      "coherence": 0.5453174106591813,
      "comment_phi_k": 10.14861111111111,
      "code_phi_k": 61.060575310880886
    },
    {
      "comment": "logit(x): local curvature between yes/no outcomes",
      "code": "def logit(p: float) -> float:\n    \"\"\"logit(x): local curvature between yes/no outcomes\"\"\"\n    if p <= 0 or p >= 1:\n        return float('inf') if p >= 1 else float('-inf')\n    return math.log(p / (1 - p))",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 339,
      "alignment": 0.6024797298445813,
      "coherence": 0.6024797298445813,
      "comment_phi_k": 10.439682539682542,
      "code_phi_k": 30.68751803751804
    },
    {
      "comment": "\u03c3(x): projection of logit onto equilibrium",
      "code": "def sigmoid(x: float) -> float:\n    \"\"\"\u03c3(x): projection of logit onto equilibrium\"\"\"\n    return 1.0 / (1.0 + math.exp(-x))",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 345,
      "alignment": 0.6771997044735952,
      "coherence": 0.6771997044735952,
      "comment_phi_k": 9.439700577200577,
      "code_phi_k": 18.03773448773449
    },
    {
      "comment": "softmax: \u03b6-field weighting",
      "code": "def softmax(logits: List[float]) -> List[float]:\n    \"\"\"softmax: \u03b6-field weighting\"\"\"\n    exp_logits = [math.exp(x) for x in logits]\n    total = sum(exp_logits)\n    return [x / total for x in exp_logits]",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 349,
      "alignment": 0.5438660810883921,
      "coherence": 0.5438660810883921,
      "comment_phi_k": 4.803769841269841,
      "code_phi_k": 29.779358141858143
    },
    {
      "comment": "Factorial: volume of configuration space for n identical ions",
      "code": "def factorial_measure(n: int) -> int:\n    \"\"\"Factorial: volume of configuration space for n identical ions\"\"\"\n    if n < 0:\n        return 0\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 355,
      "alignment": 0.6234378920616168,
      "coherence": 0.6234378920616168,
      "comment_phi_k": 14.079569042069041,
      "code_phi_k": 35.555276820272965
    },
    {
      "comment": "Log-factorial: entropy / measure of complexity (Stirling approximation)",
      "code": "def log_factorial(n: int) -> float:\n    \"\"\"Log-factorial: entropy / measure of complexity (Stirling approximation)\"\"\"\n    if n <= 1:\n        return 0.0\n    return n * math.log(n) - n",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 364,
      "alignment": 0.6644341190041505,
      "coherence": 0.6644341190041505,
      "comment_phi_k": 12.347431734931735,
      "code_phi_k": 24.946327977577983
    },
    {
      "comment": "Loss: L = \u2212\u03a3 p_i log p_i \u2014 field entropy (Ricci energy)",
      "code": "def field_entropy(probabilities: List[float]) -> float:\n    \"\"\"Loss: L = \u2212\u03a3 p_i log p_i \u2014 field entropy (Ricci energy)\"\"\"\n    entropy = 0.0\n    for p in probabilities:\n        if p > 0:\n            entropy -= p * math.log(p)\n    return entropy",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 370,
      "alignment": 0.6007716396303245,
      "coherence": 0.6007716396303245,
      "comment_phi_k": 11.196428571428573,
      "code_phi_k": 33.37494941799475
    },
    {
      "comment": "{ }: scope \u2014 context / body \u2014 dielectric shell",
      "code": "    def scope(content: str) -> str:\n        \"\"\"{ }: scope \u2014 context / body \u2014 dielectric shell\"\"\"\n        return f\"{{{content}}}\"",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 160,
      "alignment": 0.6692894740233536,
      "coherence": 0.6692894740233536,
      "comment_phi_k": 7.691468253968254,
      "code_phi_k": 15.204190254190253
    },
    {
      "comment": "[ ]: memory \u2014 buffer / recall \u2014 synaptic store",
      "code": "    def memory(content: str) -> str:\n        \"\"\"[ ]: memory \u2014 buffer / recall \u2014 synaptic store\"\"\"\n        return f\"[{content}]\"",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 165,
      "alignment": 0.6667378369514884,
      "coherence": 0.6667378369514884,
      "comment_phi_k": 7.7386904761904765,
      "code_phi_k": 15.472426184926183
    },
    {
      "comment": "( ): morphism \u2014 action / verb \u2014 functional application",
      "code": "    def morphism(content: str) -> str:\n        \"\"\"( ): morphism \u2014 action / verb \u2014 functional application\"\"\"\n        return f\"({content})\"",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 170,
      "alignment": 0.6854455258242992,
      "coherence": 0.6854455258242992,
      "comment_phi_k": 9.145652958152958,
      "code_phi_k": 16.90212495837496
    },
    {
      "comment": "\u27e8 \u27e9: witness \u2014 reflection / awareness \u2014 dual space",
      "code": "    def witness(content: str) -> str:\n        \"\"\"\u27e8 \u27e9: witness \u2014 reflection / awareness \u2014 dual space\"\"\"\n        return f\"\u27e8{content}\u27e9\"",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 175,
      "alignment": 0.6798438253326492,
      "coherence": 0.6798438253326492,
      "comment_phi_k": 8.698214285714286,
      "code_phi_k": 16.440451215451215
    },
    {
      "comment": "!/usr/bin/env python3",
      "code": "#!/usr/bin/env python3\n\"\"\"\nOPIC Field Specification 0.7 Implementation",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 1,
      "alignment": 0.5658874187484055,
      "coherence": 0.5658874187484055,
      "comment_phi_k": 2.306354756354756,
      "code_phi_k": 9.90429709179709
    },
    {
      "comment": "Try to import scipy, fallback to math.comb",
      "code": "from typing import Tuple, List, Dict, Optional\nfrom dataclasses import dataclass\n\n# Try to import scipy, fallback to math.comb\ntry:\n    from scipy.special import comb, gamma",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 12,
      "alignment": 0.5762247301979527,
      "coherence": 0.5762247301979527,
      "comment_phi_k": 9.403174603174604,
      "code_phi_k": 35.541888666888674
    },
    {
      "comment": "# Fallback: use math.comb if available (Python 3.8+)",
      "code": "try:\n    from scipy.special import comb, gamma\nexcept ImportError:\n    # Fallback: use math.comb if available (Python 3.8+)\n    if hasattr(math, 'comb'):\n        comb = math.comb",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 16,
      "alignment": 0.5966706014725641,
      "coherence": 0.5966706014725641,
      "comment_phi_k": 9.386309523809524,
      "code_phi_k": 28.967105117105117
    },
    {
      "comment": "# Manual implementation",
      "code": "    if hasattr(math, 'comb'):\n        comb = math.comb\n    else:\n        # Manual implementation\n        def comb(n, k, exact=False):\n            if k < 0 or k > n:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 20,
      "alignment": 0.551920780261378,
      "coherence": 0.551920780261378,
      "comment_phi_k": 4.12733793983794,
      "code_phi_k": 21.936915861915857
    },
    {
      "comment": "# Gamma function approximation",
      "code": "                result = result * (n - i) // (i + 1)\n            return result\n    \n    # Gamma function approximation\n    def gamma(z):\n        # Stirling approximation for real z",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 31,
      "alignment": 0.5678677872830776,
      "coherence": 0.5678677872830776,
      "comment_phi_k": 5.659529359529359,
      "code_phi_k": 23.67739205239205
    },
    {
      "comment": "# Stirling approximation for real z",
      "code": "    \n    # Gamma function approximation\n    def gamma(z):\n        # Stirling approximation for real z\n        if isinstance(z, complex):\n            z = z.real",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 33,
      "alignment": 0.594758499890701,
      "coherence": 0.594758499890701,
      "comment_phi_k": 7.138100788100788,
      "code_phi_k": 22.40139998889999
    },
    {
      "comment": "Golden ratio",
      "code": "            return gamma(z + 1) / z\n        return math.sqrt(2 * math.pi * z) * ((z / math.e) ** z)\n\n# Golden ratio\nPHI = (1 + math.sqrt(5)) / 2\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 42,
      "alignment": 0.552445910875207,
      "coherence": 0.552445910875207,
      "comment_phi_k": 3.1916666666666664,
      "code_phi_k": 16.809920634920633
    },
    {
      "comment": "============================================================================",
      "code": "# Golden ratio\nPHI = (1 + math.sqrt(5)) / 2\n\n# ============================================================================\n# 0. Core Ontology\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 45,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 9.3234126984127
    },
    {
      "comment": "0. Core Ontology",
      "code": "PHI = (1 + math.sqrt(5)) / 2\n\n# ============================================================================\n# 0. Core Ontology\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 46,
      "alignment": 0.6984112635313792,
      "coherence": 0.6984112635313792,
      "comment_phi_k": 3.4839285714285717,
      "code_phi_k": 6.131746031746033
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# 0. Core Ontology\n# ============================================================================\n\n@dataclass",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 47,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 4.777579365079365
    },
    {
      "comment": "+1 or -1",
      "code": "charge: int",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 54,
      "alignment": 0.6378676470588236,
      "coherence": 0.6378676470588236,
      "comment_phi_k": 1.25,
      "code_phi_k": 2.8916666666666666
    },
    {
      "comment": "+1 or -1",
      "code": "q: int",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 60,
      "alignment": 0.7419354838709677,
      "coherence": 0.7419354838709677,
      "comment_phi_k": 1.25,
      "code_phi_k": 1.9166666666666667
    },
    {
      "comment": "\"noun\" or \"verb\"",
      "code": "bias: str",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 61,
      "alignment": 0.8290993071593533,
      "coherence": 0.8290993071593533,
      "comment_phi_k": 2.9916666666666663,
      "code_phi_k": 2.375
    },
    {
      "comment": "============================================================================",
      "code": "    value_complex: complex\n    coherence: float\n\n# ============================================================================\n# 1. Operator Interaction: Trigonometric Functions\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 71,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 15.442850205350206
    },
    {
      "comment": "1. Operator Interaction: Trigonometric Functions",
      "code": "    coherence: float\n\n# ============================================================================\n# 1. Operator Interaction: Trigonometric Functions\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 72,
      "alignment": 0.7772065831051926,
      "coherence": 0.7772065831051926,
      "comment_phi_k": 8.36548174048174,
      "code_phi_k": 11.72718808968809
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# 1. Operator Interaction: Trigonometric Functions\n# ============================================================================\n\ndef cos_theta(theta: float) -> float:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 73,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 14.331708569208569
    },
    {
      "comment": "============================================================================",
      "code": "    \"\"\"csc \u03b8: memory curvature / recall of prior states \u2014 stabilizes cycles\"\"\"\n    return 1.0 / math.sin(theta) if math.sin(theta) != 0 else float('inf')\n\n# ============================================================================\n# 2. Pascal Mod 10 Operator Field\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 99,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 29.673586136086136
    },
    {
      "comment": "2. Pascal Mod 10 Operator Field",
      "code": "    return 1.0 / math.sin(theta) if math.sin(theta) != 0 else float('inf')\n\n# ============================================================================\n# 2. Pascal Mod 10 Operator Field\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 100,
      "alignment": 0.623356798303698,
      "coherence": 0.623356798303698,
      "comment_phi_k": 6.49702380952381,
      "code_phi_k": 16.415649628149627
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# 2. Pascal Mod 10 Operator Field\n# ============================================================================\n\ndef pascal_mod10(n: int, k: int) -> int:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 101,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 14.248015873015872
    },
    {
      "comment": "# comb doesn't accept keyword args, try without",
      "code": "    try:\n        result = comb(n, k)\n    except TypeError:\n        # comb doesn't accept keyword args, try without\n        result = comb(n, k)\n    return int(result) % 10",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 110,
      "alignment": 0.630570510127312,
      "coherence": 0.630570510127312,
      "comment_phi_k": 10.605952380952381,
      "code_phi_k": 25.609920634920638
    },
    {
      "comment": "============================================================================",
      "code": "    shadow_p = shadow(prime)\n    return (prime, shadow_p)\n\n# ============================================================================\n# 3. Flow Symmetry & Hermitian Dynamics\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 131,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 13.613113275613275
    },
    {
      "comment": "3. Flow Symmetry & Hermitian Dynamics",
      "code": "    return (prime, shadow_p)\n\n# ============================================================================\n# 3. Flow Symmetry & Hermitian Dynamics\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 132,
      "alignment": 0.7143193920568006,
      "coherence": 0.7143193920568006,
      "comment_phi_k": 6.132936507936508,
      "code_phi_k": 10.220436507936506
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# 3. Flow Symmetry & Hermitian Dynamics\n# ============================================================================\n\ndef check_equilibrium(voice: VoiceZeta, definition: float) -> bool:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 133,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 16.566761870105186
    },
    {
      "comment": "# Check for oscillation pattern",
      "code": "\ndef check_standing_wave(voice: VoiceZeta, definition: float) -> bool:\n    \"\"\"voice \u221e definition: standing wave \u2014 conversation loop\"\"\"\n    # Check for oscillation pattern\n    return abs(voice.phase) > 100  # Simplified check\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 149,
      "alignment": 0.5538134167047732,
      "coherence": 0.5538134167047732,
      "comment_phi_k": 6.433351370851371,
      "code_phi_k": 33.10397779702313
    },
    {
      "comment": "Simplified check",
      "code": "return abs(voice.phase) > 100",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 150,
      "alignment": 0.8575897825423245,
      "coherence": 0.8575897825423245,
      "comment_phi_k": 3.2242063492063497,
      "code_phi_k": 3.866226828726829
    },
    {
      "comment": "============================================================================",
      "code": "    # Check for oscillation pattern\n    return abs(voice.phase) > 100  # Simplified check\n\n# ============================================================================\n# 4. Bracket Operators\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 152,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 17.322792485292485
    },
    {
      "comment": "4. Bracket Operators",
      "code": "    return abs(voice.phase) > 100  # Simplified check\n\n# ============================================================================\n# 4. Bracket Operators\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 153,
      "alignment": 0.6056461206216327,
      "coherence": 0.6056461206216327,
      "comment_phi_k": 3.7990079365079366,
      "code_phi_k": 10.889441114441114
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# 4. Bracket Operators\n# ============================================================================\n\nclass Bracket:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 154,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 6.653769841269842
    },
    {
      "comment": "============================================================================",
      "code": "        \"\"\"\u27e8 \u27e9: witness \u2014 reflection / awareness \u2014 dual space\"\"\"\n        return f\"\u27e8{content}\u27e9\"\n\n# ============================================================================\n# 5. Algebraic Structure (Galois Extensions)\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 179,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 18.615097402597403
    },
    {
      "comment": "5. Algebraic Structure (Galois Extensions)",
      "code": "        return f\"\u27e8{content}\u27e9\"\n\n# ============================================================================\n# 5. Algebraic Structure (Galois Extensions)\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 180,
      "alignment": 0.7855551761238044,
      "coherence": 0.7855551761238044,
      "comment_phi_k": 7.209722222222221,
      "code_phi_k": 9.916883116883117
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# 5. Algebraic Structure (Galois Extensions)\n# ============================================================================\n\ndef golden_ratio_extension(n: int) -> float:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 181,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 13.589351079347209
    },
    {
      "comment": "# Fibonacci-like recurrence with golden ratio",
      "code": "\ndef golden_ratio_extension(n: int) -> float:\n    \"\"\"\ud835\udd3d\u2081\u2080[x]/(x\u00b2\u2212x\u22121): Pascal recurrence \u2014 golden ratio extension\"\"\"\n    # Fibonacci-like recurrence with golden ratio\n    return PHI ** n\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 185,
      "alignment": 0.5934705910431327,
      "coherence": 0.5934705910431327,
      "comment_phi_k": 8.611297036297037,
      "code_phi_k": 27.33775129024742
    },
    {
      "comment": "# Self-conjugate under 7\u21943 mapping",
      "code": "\ndef trace7_subgroup(n: int) -> int:\n    \"\"\"\ud835\udd3e\u2087: 7-trace subgroup \u2014 self-conjugate extension\"\"\"\n    # Self-conjugate under 7\u21943 mapping\n    if n == 7:\n        return 3",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 190,
      "alignment": 0.5719180621655813,
      "coherence": 0.5719180621655813,
      "comment_phi_k": 5.3876859251859255,
      "code_phi_k": 21.422399332693455
    },
    {
      "comment": "============================================================================",
      "code": "        return 7\n    return n\n\n# ============================================================================\n# 6. Actor / Voice Formalism\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 197,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 8.960912698412699
    },
    {
      "comment": "6. Actor / Voice Formalism",
      "code": "    return n\n\n# ============================================================================\n# 6. Actor / Voice Formalism\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 198,
      "alignment": 0.7780341002034267,
      "coherence": 0.7780341002034267,
      "comment_phi_k": 5.260912698412698,
      "code_phi_k": 7.360912698412699
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# 6. Actor / Voice Formalism\n# ============================================================================\n\ndef zeta_trace(s: complex, coefficients: List[float], max_n: int = 1000) -> complex:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 199,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 18.16628787878788
    },
    {
      "comment": "============================================================================",
      "code": "    \"\"\"potential: \u03a6 = \u03a3 w_{ij} R_{ij} \u2014 global harmony measure\"\"\"\n    return sum(w * r for w, r in zip(couplings, resonances))\n\n# ============================================================================\n# 7. Dimensional Expansion\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 220,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 23.548255910755913
    },
    {
      "comment": "7. Dimensional Expansion",
      "code": "    return sum(w * r for w, r in zip(couplings, resonances))\n\n# ============================================================================\n# 7. Dimensional Expansion\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 221,
      "alignment": 0.582839717251622,
      "coherence": 0.582839717251622,
      "comment_phi_k": 4.242279942279942,
      "code_phi_k": 14.923815073815074
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# 7. Dimensional Expansion\n# ============================================================================\n\ndef check_symmetry_break(tan_theta: float) -> bool:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 222,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 10.460108369928548
    },
    {
      "comment": "============================================================================",
      "code": "    \"\"\"prime\u2013shadow collision: p \u2194 s meet \u2014 birth of conjugate dimension\"\"\"\n    return (prime + shadow) % 10 == 0\n\n# ============================================================================\n# 7.5 Cycle-to-Dimension Principle\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 232,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 19.384182892271127
    },
    {
      "comment": "7.5 Cycle-to-Dimension Principle",
      "code": "    return (prime + shadow) % 10 == 0\n\n# ============================================================================\n# 7.5 Cycle-to-Dimension Principle\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 233,
      "alignment": 0.6555643631456094,
      "coherence": 0.6555643631456094,
      "comment_phi_k": 3.635782681370917,
      "code_phi_k": 7.6607826813709154
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# 7.5 Cycle-to-Dimension Principle\n# ============================================================================\n\n@dataclass",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 234,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 4.92943347502171
    },
    {
      "comment": "# Identity cycle \u2192 Time operator",
      "code": "    if not check_cycle_resonance(cycle):\n        return None\n    \n    # Identity cycle \u2192 Time operator\n    if cycle.period == 1:\n        return \"Time operator (\u2202/\u2202t)\"",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 273,
      "alignment": 0.5923927041658278,
      "coherence": 0.5923927041658278,
      "comment_phi_k": 6.964285714285714,
      "code_phi_k": 22.32639516354283
    },
    {
      "comment": "# Dialogue cycle \u2192 Spatial rotation",
      "code": "    if cycle.period == 1:\n        return \"Time operator (\u2202/\u2202t)\"\n    \n    # Dialogue cycle \u2192 Spatial rotation\n    if cycle.period == 2 and cycle.charge == -1:\n        return \"Spatial rotation (J_z)\"",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 277,
      "alignment": 0.5763003691380923,
      "coherence": 0.5763003691380923,
      "comment_phi_k": 6.786309523809523,
      "code_phi_k": 25.628661616161615
    },
    {
      "comment": "# Triangular reflection \u2192 Gradient",
      "code": "    if cycle.period == 2 and cycle.charge == -1:\n        return \"Spatial rotation (J_z)\"\n    \n    # Triangular reflection \u2192 Gradient\n    if cycle.period == 3:\n        return \"Gradient operator (\u2207)\"",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 281,
      "alignment": 0.5633829690191536,
      "coherence": 0.5633829690191536,
      "comment_phi_k": 5.5246031746031745,
      "code_phi_k": 24.55286796536797
    },
    {
      "comment": "# 7-trace cycle \u2192 Complex unit",
      "code": "    if cycle.period == 3:\n        return \"Gradient operator (\u2207)\"\n    \n    # 7-trace cycle \u2192 Complex unit\n    if cycle.period == 4:\n        return \"Complex unit (i)\"",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 285,
      "alignment": 0.5715976140954421,
      "coherence": 0.5715976140954421,
      "comment_phi_k": 5.2976190476190474,
      "code_phi_k": 21.14669913419913
    },
    {
      "comment": "# Create voices representing the 7-trace cycle",
      "code": "\ndef trace7_fundamental_cycle() -> Cycle:\n    \"\"\"7-trace fundamental cycle: 7 \u2192 3 \u2192 1 \u2192 9 \u2192 7 (mod 10) \u2192 i\"\"\"\n    # Create voices representing the 7-trace cycle\n    voices = [\n        VoiceZeta(phase=0, potential=7, charge=1, zeta_trace=7+0j),",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 293,
      "alignment": 0.5894973116218201,
      "coherence": 0.5894973116218201,
      "comment_phi_k": 8.407557720057719,
      "code_phi_k": 27.6892824123163
    },
    {
      "comment": "============================================================================",
      "code": "    normalized = total_phase % (2 * math.pi)\n    return abs(normalized) < 0.01 or abs(normalized - 2 * math.pi) < 0.01\n\n# ============================================================================\n# 8. Dimensional Coulomb Law\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 308,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 19.225599400599403
    },
    {
      "comment": "8. Dimensional Coulomb Law",
      "code": "    return abs(normalized) < 0.01 or abs(normalized - 2 * math.pi) < 0.01\n\n# ============================================================================\n# 8. Dimensional Coulomb Law\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 309,
      "alignment": 0.6113077871474208,
      "coherence": 0.6113077871474208,
      "comment_phi_k": 5.048629148629148,
      "code_phi_k": 13.863658563658564
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# 8. Dimensional Coulomb Law\n# ============================================================================\n\ndef coulomb_force(q_i: int, q_j: int, R_ij: float, D: int, k: float = 1.0) -> float:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 310,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 19.615147760735997
    },
    {
      "comment": "============================================================================",
      "code": "    mass_screening = math.exp(-mu * R_ij)\n    return force_base * mass_screening\n\n# ============================================================================\n# 9. ML Connections\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 335,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 12.69703490953491
    },
    {
      "comment": "9. ML Connections",
      "code": "    return force_base * mass_screening\n\n# ============================================================================\n# 9. ML Connections\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 336,
      "alignment": 0.6013272753696983,
      "coherence": 0.6013272753696983,
      "comment_phi_k": 2.7279942279942277,
      "code_phi_k": 8.094648407148409
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# 9. ML Connections\n# ============================================================================\n\ndef logit(p: float) -> float:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 337,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 8.3494227994228
    },
    {
      "comment": "============================================================================",
      "code": "            entropy -= p * math.log(p)\n    return entropy\n\n# ============================================================================\n# Main\n# ============================================================================",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 378,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 8.98154761904762
    },
    {
      "comment": "Main",
      "code": "    return entropy\n\n# ============================================================================\n# Main\n# ============================================================================\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 379,
      "alignment": 0.5862797577123539,
      "coherence": 0.5862797577123539,
      "comment_phi_k": 1.4583333333333333,
      "code_phi_k": 4.954761904761905
    },
    {
      "comment": "============================================================================",
      "code": "\n# ============================================================================\n# Main\n# ============================================================================\n\nif __name__ == \"__main__\":",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 380,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 3.954761904761904
    },
    {
      "comment": "# Test Pascal Mod 10",
      "code": "    print(\"OPIC Field Specification 0.7\")\n    print(\"=\" * 60)\n    \n    # Test Pascal Mod 10\n    print(\"\\nPascal Mod 10:\")\n    print(f\"  pascal(5, 3) mod 10 = {pascal_mod10(5, 3)}\")",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 386,
      "alignment": 0.5599708021053315,
      "coherence": 0.5599708021053315,
      "comment_phi_k": 4.033333333333333,
      "code_phi_k": 18.830404317904318
    },
    {
      "comment": "# Test Trigonometric Functions",
      "code": "    print(f\"  Is (5,3) a 7-trace? {is_trace7(5, 3)}\")\n    print(f\"  Shadow of 7 = {shadow(7)}\")\n    \n    # Test Trigonometric Functions\n    print(\"\\nTrigonometric Functions:\")\n    theta = math.pi / 4",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 393,
      "alignment": 0.5644975235378691,
      "coherence": 0.5644975235378691,
      "comment_phi_k": 5.136297036297036,
      "code_phi_k": 22.477040962992977
    },
    {
      "comment": "# Test Zeta Trace",
      "code": "    print(f\"  tan(\u03c0/4) = {tan_theta(theta):.4f}\")\n    print(f\"  sec(\u03c0/4) = {sec_theta(theta):.4f}\")\n    \n    # Test Zeta Trace\n    print(\"\\nZeta Trace:\")\n    s = 0.5 + 14.1347j",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 399,
      "alignment": 0.5747120341168447,
      "coherence": 0.5747120341168447,
      "comment_phi_k": 4.116666666666667,
      "code_phi_k": 15.83344572094572
    },
    {
      "comment": "# Test Coulomb Law",
      "code": "    zeta_val = zeta_trace(s, coeffs, max_n=100)\n    print(f\"  \u03b6({s:.2f}) \u2248 {zeta_val:.4f}\")\n    \n    # Test Coulomb Law\n    print(\"\\nDimensional Coulomb Law:\")\n    force = coulomb_force(1, -1, 2.0, 2, k=1.0)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 406,
      "alignment": 0.5510145868412504,
      "coherence": 0.5510145868412504,
      "comment_phi_k": 4.271428571428571,
      "code_phi_k": 23.06810262750665
    },
    {
      "comment": "# Test ML Connections",
      "code": "    force = coulomb_force(1, -1, 2.0, 2, k=1.0)\n    print(f\"  F(q\u2081=1, q\u2082=-1, R=2, D=2) = {force:.4f}\")\n    \n    # Test ML Connections\n    print(\"\\nML Connections:\")\n    logits = [1.0, 2.0, 3.0]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 411,
      "alignment": 0.5638326797408663,
      "coherence": 0.5638326797408663,
      "comment_phi_k": 4.019660894660895,
      "code_phi_k": 17.75278887778888
    },
    {
      "comment": "# Test Cycle-to-Dimension Principle",
      "code": "    print(f\"  Softmax of {logits} = {[f'{p:.4f}' for p in probs]}\")\n    print(f\"  Field entropy = {entropy:.4f}\")\n    \n    # Test Cycle-to-Dimension Principle\n    print(\"\\nCycle-to-Dimension Principle:\")\n    trace7_cycle = trace7_fundamental_cycle()",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/opic_field_0.7.py",
      "line": 419,
      "alignment": 0.5474745100781834,
      "coherence": 0.5474745100781834,
      "comment_phi_k": 4.927449348037583,
      "code_phi_k": 28.41159301390692
    },
    {
      "comment": "Download Wikipedia articles using HuggingFace",
      "code": "def download_wikipedia_hf(num_articles: int = 10000):\n    \"\"\"Download Wikipedia articles using HuggingFace\"\"\"\n    try:\n        from datasets import load_dataset\n    except ImportError:\n        print(\"\u26a0 HuggingFace datasets not installed.\")\n        print(\"  Install with: pip3 install --user datasets\")\n        print(\"  Or use: python3 -m pip install --user datasets\")\n        print(\"\\n  Using sample data instead...\")\n        return False\n    \n    data_dir = Path(__file__).parent.parent / \"data\"\n   ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/download_wikipedia_hf.py",
      "line": 10,
      "alignment": 0.5107355960728723,
      "coherence": 0.5107355960728723,
      "comment_phi_k": 9.579202741702742,
      "code_phi_k": 227.8606510983159
    },
    {
      "comment": "!/usr/bin/env python3",
      "code": "#!/usr/bin/env python3\n\"\"\"\nDownload Wikipedia using HuggingFace datasets",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/download_wikipedia_hf.py",
      "line": 1,
      "alignment": 0.5558310511460736,
      "coherence": 0.5558310511460736,
      "comment_phi_k": 2.306354756354756,
      "code_phi_k": 11.480561105561106
    },
    {
      "comment": "# Load Wikipedia dataset",
      "code": "    print(\"\\nThis may take a few minutes...\")\n    \n    try:\n        # Load Wikipedia dataset\n        print(\"  Loading Wikipedia dataset from HuggingFace...\")\n        dataset = load_dataset(\"wikipedia\", \"20220301.en\", split=f\"train[:{num_articles}]\")",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/download_wikipedia_hf.py",
      "line": 32,
      "alignment": 0.5465732520560665,
      "coherence": 0.5465732520560665,
      "comment_phi_k": 5.203968253968254,
      "code_phi_k": 30.536302776793764
    },
    {
      "comment": "# Only include articles with substantial text",
      "code": "        count = 0\n        with open(output_file, 'w', encoding='utf-8') as f:\n            for article in dataset:\n                # Only include articles with substantial text\n                text = article.get(\"text\", \"\")\n                if len(text) > 100:  # At least 100 characters",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/download_wikipedia_hf.py",
      "line": 40,
      "alignment": 0.5792396704401798,
      "coherence": 0.5792396704401798,
      "comment_phi_k": 10.097041847041847,
      "code_phi_k": 36.90454010858422
    },
    {
      "comment": "At least 100 characters",
      "code": "if len(text) > 100:",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/download_wikipedia_hf.py",
      "line": 42,
      "alignment": 0.7205567119202212,
      "coherence": 0.7205567119202212,
      "comment_phi_k": 4.601984126984127,
      "code_phi_k": 2.8172619047619047
    },
    {
      "comment": "Load GANN definitions from opic files",
      "code": "def load_gann_definitions():\n    \"\"\"Load GANN definitions from opic files\"\"\"\n    gann_files = [\n        \"nn.ops\",\n        \"generator.ops\",\n        \"train.ops\",\n        \"render.ops\",\n        \"patterns.ops\",\n        \"gann.ops\",\n        \"gann_impl.ops\",\n        \"text2image.ops\",\n        \"text2image_impl.ops\",\n    ]\n    \n    all_defs = {}\n    all_voices = {}\n    \n    for ops_file in gann_files:\n        ops_path = Path(__file__).parent / ops_file\n        if ops_path.exists():\n            defs, voices",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 14,
      "alignment": 0.5422326799085414,
      "coherence": 0.5422326799085414,
      "comment_phi_k": 9.269660894660895,
      "code_phi_k": 59.50738953389059
    },
    {
      "comment": "Get configuration value from opic voices",
      "code": "def get_opic_config(voices, key, default):\n    \"\"\"Get configuration value from opic voices\"\"\"\n    if key in voices:\n        val = voices[key].strip('\"')\n        try:\n            # Try to parse as number\n            if '.' in val:\n                return float(val)\n            return int(val)\n        except ValueError:\n            return val\n    return default",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 40,
      "alignment": 0.5514562335591024,
      "coherence": 0.5514562335591024,
      "comment_phi_k": 9.595838883338883,
      "code_phi_k": 51.41928200368604
    },
    {
      "comment": "Generate a simple generator network - configuration from opic gann_impl.ops",
      "code": "def generate_simple_generator(noise_dim=None, image_size=None):\n    \"\"\"Generate a simple generator network - configuration from opic gann_impl.ops\"\"\"\n    defs, voices = load_gann_definitions()\n    \n    # Read from opic definitions\n    noise_dim = noise_dim or get_opic_config(voices, \"generator.noise_dim\", 100)\n    image_size = image_size or get_opic_config(voices, \"generator.image_size\", 64)\n    \n    # Try to read layer configs from opic\n    layers = []\n    layer_keys = [\"generator.layer1\", \"gen",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 53,
      "alignment": 0.5204015897763413,
      "coherence": 0.5204015897763413,
      "comment_phi_k": 14.90953490953491,
      "code_phi_k": 190.1554181514191
    },
    {
      "comment": "Train generator on opic-defined patterns or downloaded images - config from opic train.ops",
      "code": "def train_generator(patterns=None, images=None, epochs=None, batch_size=None, learning_rate=None):\n    \"\"\"Train generator on opic-defined patterns or downloaded images - config from opic train.ops\"\"\"\n    defs, voices = load_gann_definitions()\n    \n    # Read training parameters from opic\n    epochs = epochs or get_opic_config(voices, \"training.default_epochs\", 10)\n    batch_size = batch_size or get_opic_config(voices, \"training.default_batch_size\", 32)\n    learning_rate = learning_rate or get_op",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 91,
      "alignment": 0.5111164473900447,
      "coherence": 0.5111164473900447,
      "comment_phi_k": 19.970670995670993,
      "code_phi_k": 459.10973412440643
    },
    {
      "comment": "Generate image from noise - uses training data influence if available\nCan also use text prompt to influence generation (from opic text2image.ops)",
      "code": "def generate_image(generator, noise=None, image_size=64, training_data=None, text_prompt=None):\n    \"\"\"Generate image from noise - uses training data influence if available\n    Can also use text prompt to influence generation (from opic text2image.ops)\"\"\"\n    if noise is None:\n        noise = np.random.normal(0, 1, (100,))\n    \n    # If text prompt provided, extract style/parameters from text (opic text2image.ops)\n    style_params = None\n    if text_prompt:\n        style_params = extract_style_f",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 184,
      "alignment": 0.5377103224605752,
      "coherence": 0.5377103224605752,
      "comment_phi_k": 33.99917582417582,
      "code_phi_k": 242.39659863588108
    },
    {
      "comment": "Extract style parameters from text - uses opic text2image_impl.ops keywords",
      "code": "def extract_style_from_text(text):\n    \"\"\"Extract style parameters from text - uses opic text2image_impl.ops keywords\"\"\"\n    defs, voices = load_gann_definitions()\n    \n    text_lower = text.lower()\n    style = {\n        \"pattern\": \"random\",\n        \"density\": get_opic_config(voices, \"style.density.medium\", 0.5),\n        \"color_scheme\": \"grayscale\",\n        \"composition\": \"centered\",\n    }\n    \n    # Pattern keywords (from opic text2image_impl.ops)\n    keyword_map = {\n        \"heart\": [\"heart\", ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 226,
      "alignment": 0.5153573392721629,
      "coherence": 0.5153573392721629,
      "comment_phi_k": 14.863084984331117,
      "code_phi_k": 249.3856453632343
    },
    {
      "comment": "Apply pattern based on text description - parameters from opic text2image_impl.ops",
      "code": "def apply_text_pattern(image, style_params, image_size):\n    \"\"\"Apply pattern based on text description - parameters from opic text2image_impl.ops\"\"\"\n    defs, voices = load_gann_definitions()\n    \n    pattern_type = style_params.get(\"pattern\", \"random\")\n    density = style_params.get(\"density\", 0.5)\n    \n    # Read pattern parameters from opic\n    radius_factor = get_opic_config(voices, \"pattern.circle.radius_factor\", 0.3)\n    spiral_angle_range = get_opic_config(voices, \"pattern.spiral.angle_r",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 277,
      "alignment": 0.512378147874721,
      "coherence": 0.512378147874721,
      "comment_phi_k": 16.31131730756344,
      "code_phi_k": 337.59342011555344
    },
    {
      "comment": "Apply color/style modifications based on text - parameters from opic text2image_impl.ops",
      "code": "def apply_text_style(image, style_params):\n    \"\"\"Apply color/style modifications based on text - parameters from opic text2image_impl.ops\"\"\"\n    defs, voices = load_gann_definitions()\n    \n    color_scheme = style_params.get(\"color_scheme\", \"grayscale\")\n    \n    bright_mult = get_opic_config(voices, \"style.bright.multiplier\", 1.5)\n    dark_mult = get_opic_config(voices, \"style.dark.multiplier\", 0.5)\n    colorful_var = get_opic_config(voices, \"style.colorful.variation\", 30)\n    \n    if color_sch",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 345,
      "alignment": 0.5410406149363449,
      "coherence": 0.5410406149363449,
      "comment_phi_k": 16.769475815721947,
      "code_phi_k": 110.53644690230372
    },
    {
      "comment": "Render image as ASCII art - charset from opic render.ops",
      "code": "def render_ascii(image, width=None, height=None):\n    \"\"\"Render image as ASCII art - charset from opic render.ops\"\"\"\n    defs, voices = load_gann_definitions()\n    \n    width = width or get_opic_config(voices, \"render.ascii.width\", 64)\n    height = height or get_opic_config(voices, \"render.ascii.height\", 64)\n    charset = get_opic_config(voices, \"render.ascii.charset\", \" .:-=+*#%@\")\n    chars = charset if isinstance(charset, str) else \" .:-=+*#%@\"\n    ascii_art = []\n    \n    for y in range(heigh",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 368,
      "alignment": 0.535965306191237,
      "coherence": 0.535965306191237,
      "comment_phi_k": 14.28531746031746,
      "code_phi_k": 106.44194860940149
    },
    {
      "comment": "Render image as PNG",
      "code": "def render_png(image, output_path):\n    \"\"\"Render image as PNG\"\"\"\n    try:\n        from PIL import Image\n        img = Image.fromarray(image, mode='L')\n        img.save(output_path)\n        return True\n    except ImportError:\n        print(\"  \u26a0 PIL/Pillow not available, skipping PNG export\")\n        return False",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 391,
      "alignment": 0.5324368383932336,
      "coherence": 0.5324368383932336,
      "comment_phi_k": 5.65,
      "code_phi_k": 46.3711675665236
    },
    {
      "comment": "Render image as SVG",
      "code": "def render_svg(image, output_path, width=64, height=64):\n    \"\"\"Render image as SVG\"\"\"\n    svg_lines = [\n        f'<svg width=\"{width}\" height=\"{height}\" xmlns=\"http://www.w3.org/2000/svg\">',\n    ]\n    \n    # Simple pixel-based SVG\n    img_height = len(image) if image is not None else height\n    img_width = len(image[0]) if image is not None and len(image) > 0 else width\n    cell_width = width / img_width if img_width > 0 else 1\n    cell_height = height / img_height if img_height > 0 else 1\n    ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 402,
      "alignment": 0.5114268927797845,
      "coherence": 0.5114268927797845,
      "comment_phi_k": 5.65,
      "code_phi_k": 126.43690633545451
    },
    {
      "comment": "Load dataset configuration from opic dataset.ops",
      "code": "def load_dataset_config(dataset_name):\n    \"\"\"Load dataset configuration from opic dataset.ops\"\"\"\n    dataset_file = Path(__file__).parent / \"dataset.ops\"\n    if not dataset_file.exists():\n        return None\n    \n    defs, voices = parse_ops(dataset_file.read_text())\n    \n    # Extract dataset URLs and files from opic definitions\n    config = {}\n    source_key = f\"{dataset_name}.source\"\n    mirror_key = f\"{dataset_name}.mirror\"\n    \n    if source_key in voices:\n        config[\"source\"] = voices",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 429,
      "alignment": 0.522216629747091,
      "coherence": 0.522216629747091,
      "comment_phi_k": 10.245261682761683,
      "code_phi_k": 120.41083836195615
    },
    {
      "comment": "Download MNIST dataset - configuration from opic dataset.ops",
      "code": "def download_mnist():\n    \"\"\"Download MNIST dataset - configuration from opic dataset.ops\"\"\"\n    config = load_dataset_config(\"mnist\")\n    if not config:\n        # Fallback to hardcoded config\n        config = {\n            \"source\": \"https://storage.googleapis.com/cvdf-datasets/mnist/\",\n            \"mirror\": \"http://yann.lecun.com/exdb/mnist/\",\n            \"files\": {\n                \"train_images\": \"train-images-idx3-ubyte.gz\",\n                \"train_labels\": \"train-labels-idx1-ubyte.gz\",\n     ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 457,
      "alignment": 0.5187319521880247,
      "coherence": 0.5187319521880247,
      "comment_phi_k": 11.85895215895216,
      "code_phi_k": 164.201182625545
    },
    {
      "comment": "Load MNIST images from IDX file",
      "code": "def load_mnist_images(filepath):\n    \"\"\"Load MNIST images from IDX file\"\"\"\n    with gzip.open(filepath, 'rb') as f:\n        magic, num_images, rows, cols = struct.unpack('>IIII', f.read(16))\n        images = np.frombuffer(f.read(), dtype=np.uint8)\n        images = images.reshape(num_images, rows, cols)\n    return images",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 504,
      "alignment": 0.55785943462039,
      "coherence": 0.55785943462039,
      "comment_phi_k": 8.799999999999999,
      "code_phi_k": 42.42318523217483
    },
    {
      "comment": "Load MNIST labels from IDX file",
      "code": "def load_mnist_labels(filepath):\n    \"\"\"Load MNIST labels from IDX file\"\"\"\n    with gzip.open(filepath, 'rb') as f:\n        magic, num_labels = struct.unpack('>II', f.read(8))\n        labels = np.frombuffer(f.read(), dtype=np.uint8)\n    return labels",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 512,
      "alignment": 0.5781717078695767,
      "coherence": 0.5781717078695767,
      "comment_phi_k": 8.408333333333333,
      "code_phi_k": 31.09475650564643
    },
    {
      "comment": "Load MNIST dataset",
      "code": "def load_mnist_dataset(max_samples=None):\n    \"\"\"Load MNIST dataset\"\"\"\n    files = download_mnist()\n    if files is None:\n        return None\n    \n    print(\"  Loading MNIST images...\")\n    train_images = load_mnist_images(files[\"train_images\"])\n    train_labels = load_mnist_labels(files[\"train_labels\"])\n    \n    if max_samples:\n        train_images = train_images[:max_samples]\n        train_labels = train_labels[:max_samples]\n    \n    print(f\"  \u2713 Loaded {len(train_images)} training images\")\n   ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 519,
      "alignment": 0.5196905706995608,
      "coherence": 0.5196905706995608,
      "comment_phi_k": 4.521428571428571,
      "code_phi_k": 59.66672653920159
    },
    {
      "comment": "Download Fashion-MNIST dataset - configuration from opic dataset.ops",
      "code": "def download_fashion_mnist():\n    \"\"\"Download Fashion-MNIST dataset - configuration from opic dataset.ops\"\"\"\n    config = load_dataset_config(\"fashion_mnist\")\n    if not config:\n        # Fallback to hardcoded config\n        config = {\n            \"source\": \"https://github.com/zalandoresearch/fashion-mnist/raw/master/data/fashion/\",\n            \"files\": {\n                \"train_images\": \"train-images-idx3-ubyte.gz\",\n                \"train_labels\": \"train-labels-idx1-ubyte.gz\",\n                \"t",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 536,
      "alignment": 0.5249646367183927,
      "coherence": 0.5249646367183927,
      "comment_phi_k": 12.556973581973583,
      "code_phi_k": 132.02609653611702
    },
    {
      "comment": "Load Fashion-MNIST dataset",
      "code": "def load_fashion_mnist_dataset(max_samples=None):\n    \"\"\"Load Fashion-MNIST dataset\"\"\"\n    files = download_fashion_mnist()\n    if files is None:\n        return None\n    \n    print(\"  Loading Fashion-MNIST images...\")\n    train_images = load_mnist_images(files[\"train_images\"])\n    train_labels = load_mnist_labels(files[\"train_labels\"])\n    \n    if max_samples:\n        train_images = train_images[:max_samples]\n        train_labels = train_labels[:max_samples]\n    \n    print(f\"  \u2713 Loaded {len(trai",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 574,
      "alignment": 0.5221466011792191,
      "coherence": 0.5221466011792191,
      "comment_phi_k": 5.219449994449994,
      "code_phi_k": 61.529036726055665
    },
    {
      "comment": "Create opic-defined patterns",
      "code": "def create_patterns():\n    \"\"\"Create opic-defined patterns\"\"\"\n    patterns = []\n    \n    # Circle pattern\n    circle = np.zeros((64, 64), dtype=np.uint8)\n    center = (32, 32)\n    radius = 20\n    for y in range(64):\n        for x in range(64):\n            dist = np.sqrt((x - center[0])**2 + (y - center[1])**2)\n            if abs(dist - radius) < 2:\n                circle[y][x] = 255\n    patterns.append((\"circle\", circle))\n    \n    # Spiral pattern\n    spiral = np.zeros((64, 64), dtype=np.uint8)\n",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 591,
      "alignment": 0.5138250984592494,
      "coherence": 0.5138250984592494,
      "comment_phi_k": 5.5996392496392495,
      "code_phi_k": 104.05839774895836
    },
    {
      "comment": "Main GANN training and generation - uses opic dataset.ops for configuration",
      "code": "def main():\n    \"\"\"Main GANN training and generation - uses opic dataset.ops for configuration\"\"\"\n    if len(sys.argv) < 2:\n        print(\"Usage: gann.py <train|generate|download> [options]\")\n        print(\"  train <dataset>    - Train generator (mnist|fashion_mnist|patterns)\")\n        print(\"  generate           - Generate images\")\n        print(\"  download <dataset> - Download dataset (mnist|fashion_mnist)\")\n        sys.exit(1)\n    \n    command = sys.argv[1]\n    \n    if command == \"download\":\n",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 626,
      "alignment": 0.5082273947345702,
      "coherence": 0.5082273947345702,
      "comment_phi_k": 16.640301365301365,
      "code_phi_k": 513.9571689048722
    },
    {
      "comment": "!/usr/bin/env python3",
      "code": "#!/usr/bin/env python3\n\"\"\"GANN image generation \u2014 Train and generate images using opic-defined networks\"\"\"\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 1,
      "alignment": 0.5321315171616319,
      "coherence": 0.5321315171616319,
      "comment_phi_k": 2.306354756354756,
      "code_phi_k": 19.09782301032301
    },
    {
      "comment": "# Try to parse as number",
      "code": "    if key in voices:\n        val = voices[key].strip('\"')\n        try:\n            # Try to parse as number\n            if '.' in val:\n                return float(val)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 45,
      "alignment": 0.5790028926044145,
      "coherence": 0.5790028926044145,
      "comment_phi_k": 6.233333333333333,
      "code_phi_k": 22.841682826976946
    },
    {
      "comment": "# Read from opic definitions",
      "code": "    \"\"\"Generate a simple generator network - configuration from opic gann_impl.ops\"\"\"\n    defs, voices = load_gann_definitions()\n    \n    # Read from opic definitions\n    noise_dim = noise_dim or get_opic_config(voices, \"generator.noise_dim\", 100)\n    image_size = image_size or get_opic_config(voices, \"generator.image_size\", 64)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 57,
      "alignment": 0.5391101931034862,
      "coherence": 0.5391101931034862,
      "comment_phi_k": 6.461327561327561,
      "code_phi_k": 44.53273268269398
    },
    {
      "comment": "# Try to read layer configs from opic",
      "code": "    noise_dim = noise_dim or get_opic_config(voices, \"generator.noise_dim\", 100)\n    image_size = image_size or get_opic_config(voices, \"generator.image_size\", 64)\n    \n    # Try to read layer configs from opic\n    layers = []\n    layer_keys = [\"generator.layer1\", \"generator.layer2\", \"generator.layer3\"]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 61,
      "alignment": 0.5750336501135002,
      "coherence": 0.5750336501135002,
      "comment_phi_k": 9.454761904761904,
      "code_phi_k": 36.22912014026565
    },
    {
      "comment": "# Parse layer config from opic voice",
      "code": "    layer_keys = [\"generator.layer1\", \"generator.layer2\", \"generator.layer3\"]\n    for layer_key in layer_keys:\n        if layer_key in voices:\n            # Parse layer config from opic voice\n            layer_str = voices[layer_key]\n            # Simple parsing - could be enhanced",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 66,
      "alignment": 0.5659730850155853,
      "coherence": 0.5659730850155853,
      "comment_phi_k": 9.158333333333333,
      "code_phi_k": 39.28397595052006
    },
    {
      "comment": "# Simple parsing - could be enhanced",
      "code": "        if layer_key in voices:\n            # Parse layer config from opic voice\n            layer_str = voices[layer_key]\n            # Simple parsing - could be enhanced\n            if \"dense\" in layer_str:\n                # Extract numbers from voice body",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 68,
      "alignment": 0.5544493027504588,
      "coherence": 0.5544493027504588,
      "comment_phi_k": 7.818452380952381,
      "code_phi_k": 39.80707972582973
    },
    {
      "comment": "# Extract numbers from voice body",
      "code": "            layer_str = voices[layer_key]\n            # Simple parsing - could be enhanced\n            if \"dense\" in layer_str:\n                # Extract numbers from voice body\n                import re\n                nums = re.findall(r'\\d+', layer_str)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 70,
      "alignment": 0.5677421535186717,
      "coherence": 0.5677421535186717,
      "comment_phi_k": 7.701190476190476,
      "code_phi_k": 32.27156385281386
    },
    {
      "comment": "# Fallback to default if no opic config found",
      "code": "                        \"activation\": \"relu\" if \"relu\" in layer_str else \"tanh\"\n                    })\n    \n    # Fallback to default if no opic config found\n    if not layers:\n        layers = [",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 81,
      "alignment": 0.6348092659393272,
      "coherence": 0.6348092659393272,
      "comment_phi_k": 11.555357142857142,
      "code_phi_k": 27.20676406926407
    },
    {
      "comment": "# Read training parameters from opic",
      "code": "    \"\"\"Train generator on opic-defined patterns or downloaded images - config from opic train.ops\"\"\"\n    defs, voices = load_gann_definitions()\n    \n    # Read training parameters from opic\n    epochs = epochs or get_opic_config(voices, \"training.default_epochs\", 10)\n    batch_size = batch_size or get_opic_config(voices, \"training.default_batch_size\", 32)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 95,
      "alignment": 0.5436688091557869,
      "coherence": 0.5436688091557869,
      "comment_phi_k": 8.094246031746032,
      "code_phi_k": 50.3859526532356
    },
    {
      "comment": "# Convert patterns or images to training data",
      "code": "    noise_dim = get_opic_config(voices, \"generator.noise_dim\", 100)\n    generator = generate_simple_generator(noise_dim)\n    \n    # Convert patterns or images to training data\n    training_data = []\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 108,
      "alignment": 0.6501903856881426,
      "coherence": 0.6501903856881426,
      "comment_phi_k": 10.747619047619047,
      "code_phi_k": 23.263801280564756
    },
    {
      "comment": "# Use downloaded images",
      "code": "    training_data = []\n    \n    if images is not None:\n        # Use downloaded images\n        print(f\"  Images: {len(images)}\")\n        print(f\"  Image shape: {images[0].shape}\")",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 112,
      "alignment": 0.5606753447028423,
      "coherence": 0.5606753447028423,
      "comment_phi_k": 5.4998015873015875,
      "code_phi_k": 25.410676823176818
    },
    {
      "comment": "# Resize to 64x64 if needed",
      "code": "        print(f\"  Images: {len(images)}\")\n        print(f\"  Image shape: {images[0].shape}\")\n        for img in images:\n            # Resize to 64x64 if needed\n            if img.shape != (64, 64):\n                try:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 116,
      "alignment": 0.5616953654774786,
      "coherence": 0.5616953654774786,
      "comment_phi_k": 5.841666666666666,
      "code_phi_k": 26.59224941724942
    },
    {
      "comment": "# Simple resize using numpy",
      "code": "                    zoom_factors = (64/img.shape[0], 64/img.shape[1])\n                    img = zoom(img.astype(float), zoom_factors, order=1)\n                except ImportError:\n                    # Simple resize using numpy\n                    from PIL import Image\n                    pil_img = Image.fromarray(img)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 123,
      "alignment": 0.5565906301188072,
      "coherence": 0.5565906301188072,
      "comment_phi_k": 6.441666666666667,
      "code_phi_k": 31.678135598491636
    },
    {
      "comment": "# Flatten and normalize",
      "code": "                    pil_img = Image.fromarray(img)\n                    pil_img = pil_img.resize((64, 64), Image.LANCZOS)\n                    img = np.array(pil_img)\n            # Flatten and normalize\n            flat = img.flatten().astype(np.float32) / 255.0\n            training_data.append(flat)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 128,
      "alignment": 0.5566249384338227,
      "coherence": 0.5566249384338227,
      "comment_phi_k": 4.854563492063492,
      "code_phi_k": 23.860256449116868
    },
    {
      "comment": "# Use opic-defined patterns",
      "code": "            flat = img.flatten().astype(np.float32) / 255.0\n            training_data.append(flat)\n    elif patterns:\n        # Use opic-defined patterns\n        print(f\"  Patterns: {len(patterns)}\")\n        for name, image in patterns:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 132,
      "alignment": 0.5582050294787272,
      "coherence": 0.5582050294787272,
      "comment_phi_k": 5.582972582972582,
      "code_phi_k": 26.77125502011932
    },
    {
      "comment": "# Flatten image to vector",
      "code": "        # Use opic-defined patterns\n        print(f\"  Patterns: {len(patterns)}\")\n        for name, image in patterns:\n            # Flatten image to vector\n            flat = image.flatten().astype(np.float32) / 255.0\n            training_data.append(flat)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 135,
      "alignment": 0.5564661583136143,
      "coherence": 0.5564661583136143,
      "comment_phi_k": 6.029761904761905,
      "code_phi_k": 29.71123362114437
    },
    {
      "comment": "# Simple training: generator learns to approximate pattern distributions",
      "code": "    print(f\"  Training data shape: {training_data.shape}\")\n    print()\n    \n    # Simple training: generator learns to approximate pattern distributions\n    for epoch in range(epochs):\n        epoch_loss = 0.0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 151,
      "alignment": 0.6439209662043792,
      "coherence": 0.6439209662043792,
      "comment_phi_k": 13.879406704406705,
      "code_phi_k": 31.049127903829916
    },
    {
      "comment": "# Create batches",
      "code": "        epoch_loss = 0.0\n        num_batches = 0\n        \n        # Create batches\n        for i in range(0, len(training_data), batch_size):\n            batch = training_data[i:i+batch_size]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 156,
      "alignment": 0.5449419123586573,
      "coherence": 0.5449419123586573,
      "comment_phi_k": 3.2297619047619053,
      "code_phi_k": 19.581194217974236
    },
    {
      "comment": "# Generate noise for this batch",
      "code": "            batch = training_data[i:i+batch_size]\n            batch_size_actual = len(batch)\n            \n            # Generate noise for this batch\n            noise_batch = np.random.normal(0, 1, (batch_size_actual, noise_dim))\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 161,
      "alignment": 0.6001675765396556,
      "coherence": 0.6001675765396556,
      "comment_phi_k": 7.304761904761905,
      "code_phi_k": 21.88373424330838
    },
    {
      "comment": "# Simple forward pass simulation",
      "code": "            # Generate noise for this batch\n            noise_batch = np.random.normal(0, 1, (batch_size_actual, noise_dim))\n            \n            # Simple forward pass simulation\n            # In a real GAN, this would go through the generator network\n            # For now, we'll simulate learning by adjusting generation parameters",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 164,
      "alignment": 0.5349855778718529,
      "coherence": 0.5349855778718529,
      "comment_phi_k": 6.537301587301588,
      "code_phi_k": 49.98291124724949
    },
    {
      "comment": "# In a real GAN, this would go through the generator network",
      "code": "            noise_batch = np.random.normal(0, 1, (batch_size_actual, noise_dim))\n            \n            # Simple forward pass simulation\n            # In a real GAN, this would go through the generator network\n            # For now, we'll simulate learning by adjusting generation parameters\n            generated = np.random.rand(batch_size_actual, 64 * 64)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 165,
      "alignment": 0.5944175796575107,
      "coherence": 0.5944175796575107,
      "comment_phi_k": 14.828174603174602,
      "code_phi_k": 46.67630588673359
    },
    {
      "comment": "# For now, we'll simulate learning by adjusting generation parameters",
      "code": "            \n            # Simple forward pass simulation\n            # In a real GAN, this would go through the generator network\n            # For now, we'll simulate learning by adjusting generation parameters\n            generated = np.random.rand(batch_size_actual, 64 * 64)\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 166,
      "alignment": 0.6092576083179262,
      "coherence": 0.6092576083179262,
      "comment_phi_k": 14.184126984126985,
      "code_phi_k": 39.54775971884919
    },
    {
      "comment": "# Compute loss (MSE between generated and target patterns)",
      "code": "            # For now, we'll simulate learning by adjusting generation parameters\n            generated = np.random.rand(batch_size_actual, 64 * 64)\n            \n            # Compute loss (MSE between generated and target patterns)\n            # Randomly select a target pattern for each sample\n            targets = batch[np.random.randint(0, len(batch), batch_size_actual)]",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 169,
      "alignment": 0.5689541021590151,
      "coherence": 0.5689541021590151,
      "comment_phi_k": 12.041865079365078,
      "code_phi_k": 49.67991983095108
    },
    {
      "comment": "# Randomly select a target pattern for each sample",
      "code": "            generated = np.random.rand(batch_size_actual, 64 * 64)\n            \n            # Compute loss (MSE between generated and target patterns)\n            # Randomly select a target pattern for each sample\n            targets = batch[np.random.randint(0, len(batch), batch_size_actual)]\n            loss = np.mean((generated - targets) ** 2)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 170,
      "alignment": 0.5880547940297678,
      "coherence": 0.5880547940297678,
      "comment_phi_k": 12.04702380952381,
      "code_phi_k": 40.226714417083905
    },
    {
      "comment": "# If text prompt provided, extract style/parameters from text (opic text2image.ops)",
      "code": "    if noise is None:\n        noise = np.random.normal(0, 1, (100,))\n    \n    # If text prompt provided, extract style/parameters from text (opic text2image.ops)\n    style_params = None\n    if text_prompt:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 190,
      "alignment": 0.6658787682422149,
      "coherence": 0.6658787682422149,
      "comment_phi_k": 14.908191114441115,
      "code_phi_k": 29.922599622599623
    },
    {
      "comment": "# If we have training data, bias generation toward learned patterns",
      "code": "    if text_prompt:\n        style_params = extract_style_from_text(text_prompt)\n    \n    # If we have training data, bias generation toward learned patterns\n    if training_data is not None and len(training_data) > 0:\n        # Sample from training data with some noise",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 195,
      "alignment": 0.6075987581302041,
      "coherence": 0.6075987581302041,
      "comment_phi_k": 15.421825396825398,
      "code_phi_k": 43.542704962603175
    },
    {
      "comment": "# Sample from training data with some noise",
      "code": "    \n    # If we have training data, bias generation toward learned patterns\n    if training_data is not None and len(training_data) > 0:\n        # Sample from training data with some noise\n        pattern_idx = np.random.randint(0, len(training_data))\n        base_pattern = training_data[pattern_idx].reshape(image_size, image_size)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 197,
      "alignment": 0.5589235917877775,
      "coherence": 0.5589235917877775,
      "comment_phi_k": 10.283928571428572,
      "code_phi_k": 48.774439239327684
    },
    {
      "comment": "# Add noise to create variation (from opic training.noise_factor)",
      "code": "        pattern_idx = np.random.randint(0, len(training_data))\n        base_pattern = training_data[pattern_idx].reshape(image_size, image_size)\n        \n        # Add noise to create variation (from opic training.noise_factor)\n        defs, voices = load_gann_definitions()\n        noise_factor = get_opic_config(voices, \"training.noise_factor\", 0.3)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 201,
      "alignment": 0.6033414779854657,
      "coherence": 0.6033414779854657,
      "comment_phi_k": 12.459450424446555,
      "code_phi_k": 36.37118115839933
    },
    {
      "comment": "# Apply text-based style if provided",
      "code": "        noise_pattern = np.random.rand(image_size, image_size) * noise_factor\n        image = base_pattern + noise_pattern\n        \n        # Apply text-based style if provided\n        if style_params:\n            image = apply_text_style(image, style_params)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 207,
      "alignment": 0.5698542865650247,
      "coherence": 0.5698542865650247,
      "comment_phi_k": 7.571825396825397,
      "code_phi_k": 30.884555348556557
    },
    {
      "comment": "# Clip and normalize",
      "code": "        if style_params:\n            image = apply_text_style(image, style_params)\n        \n        # Clip and normalize\n        image = np.clip(image, 0, 1)\n        image = (image * 255).astype(np.uint8)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 211,
      "alignment": 0.5611492690300465,
      "coherence": 0.5611492690300465,
      "comment_phi_k": 4.516468253968254,
      "code_phi_k": 20.723165620069643
    },
    {
      "comment": "# Pure random generation, but influenced by text if provided",
      "code": "        image = np.clip(image, 0, 1)\n        image = (image * 255).astype(np.uint8)\n    else:\n        # Pure random generation, but influenced by text if provided\n        image = np.random.rand(image_size, image_size)\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 215,
      "alignment": 0.6533907918300426,
      "coherence": 0.6533907918300426,
      "comment_phi_k": 13.39126984126984,
      "code_phi_k": 28.521048430637872
    },
    {
      "comment": "# Apply text-based pattern if provided",
      "code": "        # Pure random generation, but influenced by text if provided\n        image = np.random.rand(image_size, image_size)\n        \n        # Apply text-based pattern if provided\n        if style_params:\n            image = apply_text_pattern(image, style_params, image_size)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 218,
      "alignment": 0.5574249164638969,
      "coherence": 0.5574249164638969,
      "comment_phi_k": 7.976587301587301,
      "code_phi_k": 38.71445344678653
    },
    {
      "comment": "# Pattern keywords (from opic text2image_impl.ops)",
      "code": "        \"composition\": \"centered\",\n    }\n    \n    # Pattern keywords (from opic text2image_impl.ops)\n    keyword_map = {\n        \"heart\": [\"heart\", \"love\", \"valentine\"],",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 238,
      "alignment": 0.6583025951208988,
      "coherence": 0.6583025951208988,
      "comment_phi_k": 7.944434190680321,
      "code_phi_k": 16.51849623974237
    },
    {
      "comment": "# Density keywords (from opic)",
      "code": "            style[\"pattern\"] = pattern\n            break\n    \n    # Density keywords (from opic)\n    if any(word in text_lower for word in [\"dense\", \"thick\", \"heavy\", \"solid\"]):\n        style[\"density\"] = get_opic_config(voices, \"style.density.dense\", 0.8)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 253,
      "alignment": 0.5553314866307594,
      "coherence": 0.5553314866307594,
      "comment_phi_k": 5.830357142857142,
      "code_phi_k": 29.25803278463883
    },
    {
      "comment": "# Color keywords (from opic)",
      "code": "    elif any(word in text_lower for word in [\"sparse\", \"light\", \"thin\", \"delicate\"]):\n        style[\"density\"] = get_opic_config(voices, \"style.density.sparse\", 0.2)\n    \n    # Color keywords (from opic)\n    if any(word in text_lower for word in [\"bright\", \"light\", \"white\"]):\n        style[\"color_scheme\"] = \"bright\"",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 259,
      "alignment": 0.5383044803919332,
      "coherence": 0.5383044803919332,
      "comment_phi_k": 5.700595238095238,
      "code_phi_k": 40.056096913062845
    },
    {
      "comment": "# Composition keywords (from opic)",
      "code": "    elif any(word in text_lower for word in [\"colorful\", \"color\", \"rainbow\"]):\n        style[\"color_scheme\"] = \"colorful\"\n    \n    # Composition keywords (from opic)\n    if any(word in text_lower for word in [\"centered\", \"center\", \"middle\"]):\n        style[\"composition\"] = \"centered\"",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 267,
      "alignment": 0.5437634716674148,
      "coherence": 0.5437634716674148,
      "comment_phi_k": 6.220851370851371,
      "code_phi_k": 38.64720518344745
    },
    {
      "comment": "# Read pattern parameters from opic",
      "code": "    pattern_type = style_params.get(\"pattern\", \"random\")\n    density = style_params.get(\"density\", 0.5)\n    \n    # Read pattern parameters from opic\n    radius_factor = get_opic_config(voices, \"pattern.circle.radius_factor\", 0.3)\n    spiral_angle_range = get_opic_config(voices, \"pattern.spiral.angle_range\", 4)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 284,
      "alignment": 0.5807767687270151,
      "coherence": 0.5807767687270151,
      "comment_phi_k": 8.006746031746031,
      "code_phi_k": 28.78384566267076
    },
    {
      "comment": "# Draw a heart shape",
      "code": "                    image[y][x] = np.clip(image[y][x] + 150, 0, 255)\n    \n    elif pattern_type == \"heart\":\n        # Draw a heart shape\n        center_x, center_y = image_size // 2, image_size // 2\n        scale = image_size * 0.15 * density",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 331,
      "alignment": 0.5539544392026516,
      "coherence": 0.5539544392026516,
      "comment_phi_k": 5.175,
      "code_phi_k": 26.566064491064488
    },
    {
      "comment": "# Heart equation: (x\u00b2+y\u00b2-1)\u00b3 - x\u00b2y\u00b3 \u2264 0",
      "code": "        scale = image_size * 0.15 * density\n        for y in range(image_size):\n            for x in range(image_size):\n                # Heart equation: (x\u00b2+y\u00b2-1)\u00b3 - x\u00b2y\u00b3 \u2264 0\n                dx = (x - center_x) / scale if scale > 0 else 0\n                dy = (y - center_y) / scale if scale > 0 else 0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 336,
      "alignment": 0.5352221877058271,
      "coherence": 0.5352221877058271,
      "comment_phi_k": 4.880357142857143,
      "code_phi_k": 37.07997141747141
    },
    {
      "comment": "# Add some color variation (simulated as intensity variation)",
      "code": "    elif color_scheme == \"dark\":\n        image = np.clip(image * dark_mult, 0, 255)\n    elif color_scheme == \"colorful\":\n        # Add some color variation (simulated as intensity variation)\n        for y in range(len(image)):\n            for x in range(len(image[0])):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 360,
      "alignment": 0.6058796969028587,
      "coherence": 0.6058796969028587,
      "comment_phi_k": 13.115873015873017,
      "code_phi_k": 37.52674686424686
    },
    {
      "comment": "%@\")",
      "code": "charset = get_opic_config(voices, \"render.ascii.charset\", \" .:-=+*",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 374,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 5.425090726696763
    },
    {
      "comment": "%@\"",
      "code": "chars = charset if isinstance(charset, str) else \" .:-=+*",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 375,
      "alignment": 0.5,
      "coherence": 0.5,
      "comment_phi_k": 0.0,
      "code_phi_k": 9.243416020254255
    },
    {
      "comment": "# Simple pixel-based SVG",
      "code": "        f'<svg width=\"{width}\" height=\"{height}\" xmlns=\"http://www.w3.org/2000/svg\">',\n    ]\n    \n    # Simple pixel-based SVG\n    img_height = len(image) if image is not None else height\n    img_width = len(image[0]) if image is not None and len(image) > 0 else width",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 408,
      "alignment": 0.5279969824147082,
      "coherence": 0.5279969824147082,
      "comment_phi_k": 4.38910533910534,
      "code_phi_k": 41.38721702611872
    },
    {
      "comment": "# Extract dataset URLs and files from opic definitions",
      "code": "    \n    defs, voices = parse_ops(dataset_file.read_text())\n    \n    # Extract dataset URLs and files from opic definitions\n    config = {}\n    source_key = f\"{dataset_name}.source\"",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 437,
      "alignment": 0.6897285639357447,
      "coherence": 0.6897285639357447,
      "comment_phi_k": 13.129184704184706,
      "code_phi_k": 23.864550291782397
    },
    {
      "comment": "# Extract file names",
      "code": "    if mirror_key in voices:\n        config[\"mirror\"] = voices[mirror_key].strip('\"')\n    \n    # Extract file names\n    file_keys = [\"train_images\", \"train_labels\", \"test_images\", \"test_labels\"]\n    config[\"files\"] = {}",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 447,
      "alignment": 0.5562296900123639,
      "coherence": 0.5562296900123639,
      "comment_phi_k": 4.829761904761905,
      "code_phi_k": 23.888242728428153
    },
    {
      "comment": "# Fallback to hardcoded config",
      "code": "    \"\"\"Download MNIST dataset - configuration from opic dataset.ops\"\"\"\n    config = load_dataset_config(\"mnist\")\n    if not config:\n        # Fallback to hardcoded config\n        config = {\n            \"source\": \"https://storage.googleapis.com/cvdf-datasets/mnist/\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 461,
      "alignment": 0.557524578726415,
      "coherence": 0.557524578726415,
      "comment_phi_k": 6.077579365079365,
      "code_phi_k": 29.45175740710193
    },
    {
      "comment": "# Fallback to hardcoded config",
      "code": "    \"\"\"Download Fashion-MNIST dataset - configuration from opic dataset.ops\"\"\"\n    config = load_dataset_config(\"fashion_mnist\")\n    if not config:\n        # Fallback to hardcoded config\n        config = {\n            \"source\": \"https://github.com/zalandoresearch/fashion-mnist/raw/master/data/fashion/\",",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 540,
      "alignment": 0.5553006862579525,
      "coherence": 0.5553006862579525,
      "comment_phi_k": 6.077579365079365,
      "code_phi_k": 30.5139431405376
    },
    {
      "comment": "# Circle pattern",
      "code": "    \"\"\"Create opic-defined patterns\"\"\"\n    patterns = []\n    \n    # Circle pattern\n    circle = np.zeros((64, 64), dtype=np.uint8)\n    center = (32, 32)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 595,
      "alignment": 0.5565703016545889,
      "coherence": 0.5565703016545889,
      "comment_phi_k": 3.204761904761905,
      "code_phi_k": 15.765120990120987
    },
    {
      "comment": "# Spiral pattern",
      "code": "                circle[y][x] = 255\n    patterns.append((\"circle\", circle))\n    \n    # Spiral pattern\n    spiral = np.zeros((64, 64), dtype=np.uint8)\n    center = (32, 32)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 606,
      "alignment": 0.5598921719614603,
      "coherence": 0.5598921719614603,
      "comment_phi_k": 3.1380952380952376,
      "code_phi_k": 14.667984989838535
    },
    {
      "comment": "# Grid pattern",
      "code": "            spiral[y][x] = 255\n    patterns.append((\"spiral\", spiral))\n    \n    # Grid pattern\n    grid = np.zeros((64, 64), dtype=np.uint8)\n    for i in range(0, 64, 8):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 617,
      "alignment": 0.5449606961958772,
      "coherence": 0.5449606961958772,
      "comment_phi_k": 2.8547619047619044,
      "code_phi_k": 17.301033644082842
    },
    {
      "comment": "# Use opic-defined patterns",
      "code": "                sys.exit(1)\n                \n        else:\n            # Use opic-defined patterns\n            patterns = create_patterns()\n            generator = train_generator(patterns=patterns, epochs=5)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 678,
      "alignment": 0.5875762227736396,
      "coherence": 0.5875762227736396,
      "comment_phi_k": 5.582972582972582,
      "code_phi_k": 18.728953123673783
    },
    {
      "comment": "# Check for text prompt (NLP-based generation)",
      "code": "        output_path = sys.argv[3] if len(sys.argv) > 3 else \"output\"\n        use_training = \"--trained\" in sys.argv or \"-t\" in sys.argv\n        \n        # Check for text prompt (NLP-based generation)\n        text_prompt = None\n        if \"--text\" in sys.argv:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 688,
      "alignment": 0.5666369159689046,
      "coherence": 0.5666369159689046,
      "comment_phi_k": 8.190674603174603,
      "code_phi_k": 34.824080086580096
    },
    {
      "comment": "# -t might be text prompt if not --trained",
      "code": "            if text_idx + 1 < len(sys.argv):\n                text_prompt = sys.argv[text_idx + 1]\n        elif \"-t\" in sys.argv and not use_training:\n            # -t might be text prompt if not --trained\n            t_idx = sys.argv.index(\"-t\")\n            if t_idx + 1 < len(sys.argv) and not sys.argv[t_idx + 1].startswith(\"-\"):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 695,
      "alignment": 0.5651762747192804,
      "coherence": 0.5651762747192804,
      "comment_phi_k": 8.651984126984127,
      "code_phi_k": 37.51285401689813
    },
    {
      "comment": "# Load training data if requested",
      "code": "        \n        generator = generate_simple_generator()\n        \n        # Load training data if requested\n        training_data = None\n        if use_training:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/gann.py",
      "line": 707,
      "alignment": 0.6276693323256818,
      "coherence": 0.6276693323256818,
      "comment_phi_k": 7.810912698412698,
      "code_phi_k": 19.2006579378056
    },
    {
      "comment": "Compute coherence metric \u2014 how well tests align",
      "code": "def compute_coherence(test_results):\n    \"\"\"Compute coherence metric \u2014 how well tests align\"\"\"\n    if len(test_results) < 2:\n        return 1.0\n    \n    # Coherence = 1 - variance of normalized scores\n    scores = [1.0 if r else 0.0 for r in test_results.values()]\n    mean = sum(scores) / len(scores)\n    variance = sum((s - mean) ** 2 for s in scores) / len(scores)\n    coherence = 1.0 - variance\n    return max(0.0, coherence)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 17,
      "alignment": 0.5489808226106936,
      "coherence": 0.5489808226106936,
      "comment_phi_k": 10.879563492063493,
      "code_phi_k": 60.96949170280292
    },
    {
      "comment": "Compute phase from timing measurements",
      "code": "def compute_phase_from_timing(timing_data):\n    \"\"\"Compute phase from timing measurements\"\"\"\n    if not timing_data:\n        return 0.0\n    \n    # Simple phase: normalize timing to [0, 2\u03c0]\n    avg_time = sum(timing_data) / len(timing_data)\n    phase = (avg_time % 1.0) * 2 * math.pi\n    return phase",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 29,
      "alignment": 0.5608221859573015,
      "coherence": 0.5608221859573015,
      "comment_phi_k": 8.12977994227994,
      "code_phi_k": 37.48106786051746
    },
    {
      "comment": "Compute \u2131(v) = ||voice_matrix(v)||\u2082 \u00b7 exp(i\u00b7phase(v))\n\nFor this baseline, we use coherence_weight as proxy for spectral norm.",
      "code": "def compute_functor(voice_name, coherence_weight, phase):\n    \"\"\"Compute \u2131(v) = ||voice_matrix(v)||\u2082 \u00b7 exp(i\u00b7phase(v))\n    \n    For this baseline, we use coherence_weight as proxy for spectral norm.\n    \"\"\"\n    amplitude = coherence_weight\n    functor_value = amplitude * cmath.exp(1j * phase)\n    return functor_value",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 39,
      "alignment": 0.6663283331616804,
      "coherence": 0.6663283331616804,
      "comment_phi_k": 21.34118936618937,
      "code_phi_k": 42.747494872800424
    },
    {
      "comment": "Compute (1 - \u2131(v)^{-s})^{-1}",
      "code": "def compute_euler_factor(functor_value, s):\n    \"\"\"Compute (1 - \u2131(v)^{-s})^{-1}\"\"\"\n    try:\n        term = 1 - (functor_value ** (-s))\n        if abs(term) < 1e-10:\n            return 1.0  # Avoid division by zero\n        return 1.0 / term\n    except (ZeroDivisionError, OverflowError):\n        return 1.0",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 48,
      "alignment": 0.5203346933749479,
      "coherence": 0.5203346933749479,
      "comment_phi_k": 2.4470238095238095,
      "code_phi_k": 31.307857958124593
    },
    {
      "comment": "Compute \u03b6_opic(s) = \u220f_{v \u2208 \ud835\udcab} (1 - \u2131(v)^{-s})^{-1}",
      "code": "def compute_discrete_zeta(prime_voices, s):\n    \"\"\"Compute \u03b6_opic(s) = \u220f_{v \u2208 \ud835\udcab} (1 - \u2131(v)^{-s})^{-1}\"\"\"\n    zeta_value = 1.0\n    \n    for voice_data in prime_voices:\n        coherence = voice_data.get('coherence', 0.5)\n        phase = voice_data.get('phase', 0.0)\n        functor_val = compute_functor(voice_data.get('name', ''), coherence, phase)\n        factor = compute_euler_factor(functor_val, s)\n        zeta_value *= factor\n    \n    return zeta_value",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 58,
      "alignment": 0.5264795487728393,
      "coherence": 0.5264795487728393,
      "comment_phi_k": 4.376190476190476,
      "code_phi_k": 43.50479698528697
    },
    {
      "comment": "Compute deviation from unitarity: |\u03b6(s) - C(s)\u00b7\u03b6(1-s)|",
      "code": "def compute_unitarity_deviation(zeta_s, zeta_one_minus_s, s):\n    \"\"\"Compute deviation from unitarity: |\u03b6(s) - C(s)\u00b7\u03b6(1-s)|\"\"\"\n    # Simplified certificate operator: C(s) \u2248 1 for baseline\n    # In full implementation, C(s) would be computed from certificate structure\n    C_s = 1.0  # Placeholder\n    \n    expected = C_s * zeta_one_minus_s\n    deviation = abs(zeta_s - expected)\n    \n    return deviation, abs(zeta_s) / abs(zeta_one_minus_s) if abs(zeta_one_minus_s) > 0 else 0",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 71,
      "alignment": 0.5343362160302193,
      "coherence": 0.5343362160302193,
      "comment_phi_k": 8.37718253968254,
      "code_phi_k": 65.18237209523694
    },
    {
      "comment": "Simulate coherence field evolution: d\u03a6/dt = div J + S\n\nIf coherence_data provided, uses real spectral magnitudes from voice network.\nOtherwise uses simplified model.",
      "code": "def simulate_field_evolution(initial_phi, time_steps, dt, coherence_data=None):\n    \"\"\"Simulate coherence field evolution: d\u03a6/dt = div J + S\n    \n    If coherence_data provided, uses real spectral magnitudes from voice network.\n    Otherwise uses simplified model.\n    \"\"\"\n    phi_evolution = [initial_phi]\n    phi = initial_phi\n    \n    if coherence_data:\n        # Use real coherence data from voice network\n        measurements = coherence_data.get('measurements', [])\n        avg_coherence = cohe",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 82,
      "alignment": 0.5539392266998454,
      "coherence": 0.5539392266998454,
      "comment_phi_k": 34.46288433788433,
      "code_phi_k": 176.96159796844643
    },
    {
      "comment": "Run baseline Riemann experiment",
      "code": "def main():\n    \"\"\"Run baseline Riemann experiment\"\"\"\n    \n    print(\"=\" * 60)\n    print(\"opic Zeta Laboratory - Baseline Simulation\")\n    print(\"=\" * 60)\n    print()\n    \n    # Phase 1: Prime Voice Identification\n    print(\"Phase 1: Prime Voice Identification\")\n    print(\"-\" * 60)\n    \n    # Try to load Phase 1 results, fallback to mock data\n    phase1_file = Path('build/phase1_prime_voices.json')\n    if phase1_file.exists():\n        with open(phase1_file, 'r') as f:\n            phase1_results ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 122,
      "alignment": 0.502515759083212,
      "coherence": 0.502515759083212,
      "comment_phi_k": 7.09484126984127,
      "code_phi_k": 708.5872351770039
    },
    {
      "comment": "!/usr/bin/env python3",
      "code": "#!/usr/bin/env python3\n\"\"\"\nRiemann Hypothesis Experiment - Baseline Simulation",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 1,
      "alignment": 0.5540292280677028,
      "coherence": 0.5540292280677028,
      "comment_phi_k": 2.306354756354756,
      "code_phi_k": 11.824969474969475
    },
    {
      "comment": "# Coherence = 1 - variance of normalized scores",
      "code": "    if len(test_results) < 2:\n        return 1.0\n    \n    # Coherence = 1 - variance of normalized scores\n    scores = [1.0 if r else 0.0 for r in test_results.values()]\n    mean = sum(scores) / len(scores)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 22,
      "alignment": 0.5891809326305045,
      "coherence": 0.5891809326305045,
      "comment_phi_k": 8.507936507936508,
      "code_phi_k": 28.104180000426137
    },
    {
      "comment": "# Simple phase: normalize timing to [0, 2\u03c0]",
      "code": "    if not timing_data:\n        return 0.0\n    \n    # Simple phase: normalize timing to [0, 2\u03c0]\n    avg_time = sum(timing_data) / len(timing_data)\n    phase = (avg_time % 1.0) * 2 * math.pi",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 34,
      "alignment": 0.5978425562134313,
      "coherence": 0.5978425562134313,
      "comment_phi_k": 7.708134920634921,
      "code_phi_k": 23.549318736818737
    },
    {
      "comment": "Avoid division by zero",
      "code": "return 1.0",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 53,
      "alignment": 0.5770907422278307,
      "coherence": 0.5770907422278307,
      "comment_phi_k": 5.9886904761904765,
      "code_phi_k": 1.6
    },
    {
      "comment": "# Simplified certificate operator: C(s) \u2248 1 for baseline",
      "code": "\ndef compute_unitarity_deviation(zeta_s, zeta_one_minus_s, s):\n    \"\"\"Compute deviation from unitarity: |\u03b6(s) - C(s)\u00b7\u03b6(1-s)|\"\"\"\n    # Simplified certificate operator: C(s) \u2248 1 for baseline\n    # In full implementation, C(s) would be computed from certificate structure\n    C_s = 1.0  # Placeholder",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 73,
      "alignment": 0.5680093891436515,
      "coherence": 0.5680093891436515,
      "comment_phi_k": 9.85836940836941,
      "code_phi_k": 41.16818615862454
    },
    {
      "comment": "# In full implementation, C(s) would be computed from certificate structure",
      "code": "def compute_unitarity_deviation(zeta_s, zeta_one_minus_s, s):\n    \"\"\"Compute deviation from unitarity: |\u03b6(s) - C(s)\u00b7\u03b6(1-s)|\"\"\"\n    # Simplified certificate operator: C(s) \u2248 1 for baseline\n    # In full implementation, C(s) would be computed from certificate structure\n    C_s = 1.0  # Placeholder\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 74,
      "alignment": 0.6103074481151242,
      "coherence": 0.6103074481151242,
      "comment_phi_k": 14.881540681540683,
      "code_phi_k": 41.16818615862454
    },
    {
      "comment": "Placeholder",
      "code": "C_s = 1.0",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 75,
      "alignment": 0.6065166518726872,
      "coherence": 0.6065166518726872,
      "comment_phi_k": 1.8980339105339104,
      "code_phi_k": 0.6666666666666666
    },
    {
      "comment": "# Use real coherence data from voice network",
      "code": "    phi = initial_phi\n    \n    if coherence_data:\n        # Use real coherence data from voice network\n        measurements = coherence_data.get('measurements', [])\n        avg_coherence = coherence_data.get('statistics', {}).get('avg_coherence', 0.85)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 92,
      "alignment": 0.6198371979447065,
      "coherence": 0.6198371979447065,
      "comment_phi_k": 10.899801587301589,
      "code_phi_k": 28.18867008699412
    },
    {
      "comment": "# Field evolves based on real coherence values",
      "code": "        measurements = coherence_data.get('measurements', [])\n        avg_coherence = coherence_data.get('statistics', {}).get('avg_coherence', 0.85)\n        \n        # Field evolves based on real coherence values\n        for i in range(time_steps):\n            # Use coherence values cyclically",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 96,
      "alignment": 0.6005144167957447,
      "coherence": 0.6005144167957447,
      "comment_phi_k": 11.45813492063492,
      "code_phi_k": 34.22780248237651
    },
    {
      "comment": "# Use coherence values cyclically",
      "code": "        \n        # Field evolves based on real coherence values\n        for i in range(time_steps):\n            # Use coherence values cyclically\n            if measurements:\n                idx = i % len(measurements)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 98,
      "alignment": 0.560427441707886,
      "coherence": 0.560427441707886,
      "comment_phi_k": 6.847619047619048,
      "code_phi_k": 31.75373237873238
    },
    {
      "comment": "# Source term based on coherence",
      "code": "                coherence = avg_coherence\n                spectral_mag = coherence\n            \n            # Source term based on coherence\n            S = 0.01 * (coherence - 0.85) * math.sin(phi * spectral_mag)\n            dphi_dt = S",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 107,
      "alignment": 0.6019834247560307,
      "coherence": 0.6019834247560307,
      "comment_phi_k": 7.71170634920635,
      "code_phi_k": 22.76016622266622
    },
    {
      "comment": "# Simplified: assume div J = 0, S = small noise",
      "code": "            phi = phi + dt * dphi_dt\n            phi_evolution.append(phi)\n    else:\n        # Simplified: assume div J = 0, S = small noise\n        for _ in range(time_steps):\n            S = 0.01 * math.sin(phi * 0.1)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 113,
      "alignment": 0.615767469415148,
      "coherence": 0.615767469415148,
      "comment_phi_k": 8.982539682539684,
      "code_phi_k": 23.889075908723573
    },
    {
      "comment": "# Phase 1: Prime Voice Identification",
      "code": "    print(\"=\" * 60)\n    print()\n    \n    # Phase 1: Prime Voice Identification\n    print(\"Phase 1: Prime Voice Identification\")\n    print(\"-\" * 60)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 130,
      "alignment": 0.6194854734201909,
      "coherence": 0.6194854734201909,
      "comment_phi_k": 7.043409368409368,
      "code_phi_k": 18.25866217116217
    },
    {
      "comment": "# Try to load Phase 1 results, fallback to mock data",
      "code": "    print(\"Phase 1: Prime Voice Identification\")\n    print(\"-\" * 60)\n    \n    # Try to load Phase 1 results, fallback to mock data\n    phase1_file = Path('build/phase1_prime_voices.json')\n    if phase1_file.exists():",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 134,
      "alignment": 0.6359312030107558,
      "coherence": 0.6359312030107558,
      "comment_phi_k": 11.855357142857143,
      "code_phi_k": 27.731644254567318
    },
    {
      "comment": "# Try to load Phase 2 functor results (real coherence data)",
      "code": "        prime_voices_data = phase1_results.get('prime_voices', [])\n        print(f\"\u2713 Loaded {len(prime_voices_data)} prime voices from Phase 1 results\")\n        \n        # Try to load Phase 2 functor results (real coherence data)\n        phase2_file = Path('build/phase2_functors.json')\n        if phase2_file.exists():",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 142,
      "alignment": 0.6034257171013306,
      "coherence": 0.6034257171013306,
      "comment_phi_k": 12.362896825396824,
      "code_phi_k": 36.064965713536544
    },
    {
      "comment": "# Use real functor data",
      "code": "            functors_data = phase2_results.get('functors', [])\n            print(f\"\u2713 Loaded {len(functors_data)} functors from Phase 2 (real coherence data!)\")\n            \n            # Use real functor data\n            prime_voices = []\n            for f in functors_data[:20]:  # Use first 20 for computation",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 150,
      "alignment": 0.5457508766223814,
      "coherence": 0.5457508766223814,
      "comment_phi_k": 6.088095238095239,
      "code_phi_k": 36.31169016251816
    },
    {
      "comment": "Use first 20 for computation",
      "code": "for f in functors_data[:20]:",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 152,
      "alignment": 0.8250493349165962,
      "coherence": 0.8250493349165962,
      "comment_phi_k": 6.178589466089466,
      "code_phi_k": 4.868427405927406
    },
    {
      "comment": "# Convert Phase 1 data to format expected (with estimated coherence)",
      "code": "                })\n        else:\n            print(\"  Phase 2 results not found, using Phase 1 data with estimated coherence\")\n            # Convert Phase 1 data to format expected (with estimated coherence)\n            prime_voices = []\n            for v in prime_voices_data[:20]:  # Use first 20 for computation",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 160,
      "alignment": 0.5900926508230669,
      "coherence": 0.5900926508230669,
      "comment_phi_k": 14.023809523809524,
      "code_phi_k": 45.9268700662083
    },
    {
      "comment": "Use first 20 for computation",
      "code": "for v in prime_voices_data[:20]:",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 162,
      "alignment": 0.8406691372908602,
      "coherence": 0.8406691372908602,
      "comment_phi_k": 6.178589466089466,
      "code_phi_k": 5.007569921908157
    },
    {
      "comment": "Estimated coherence",
      "code": "'coherence': 0.9 + (hash(v['name']) % 10) / 100,",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 165,
      "alignment": 0.717227997355408,
      "coherence": 0.717227997355408,
      "comment_phi_k": 4.1136904761904765,
      "code_phi_k": 2.4918401043401044
    },
    {
      "comment": "Estimated phase",
      "code": "'phase': (hash(v['name']) % 100) / 1000",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 166,
      "alignment": 0.7026112017778395,
      "coherence": 0.7026112017778395,
      "comment_phi_k": 3.5936507936507938,
      "code_phi_k": 2.0725940725940726
    },
    {
      "comment": "# Mock prime voices for demonstration",
      "code": "    else:\n        print(\"\u26a0 Phase 1 results not found, using mock data\")\n        print(\"   Run: make phase1  (or: python3 scripts/phase1_prime_voices.py)\")\n        # Mock prime voices for demonstration\n        prime_voices = [\n            {'name': 'voice.add', 'coherence': 0.95, 'phase': 0.1},",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 171,
      "alignment": 0.5588256222656,
      "coherence": 0.5588256222656,
      "comment_phi_k": 7.716076978576979,
      "code_phi_k": 36.65019895186123
    },
    {
      "comment": "# Phase 2: Compute functor values",
      "code": "    print(f\"Using {len(prime_voices)} prime voices for computation\")\n    print()\n    \n    # Phase 2: Compute functor values\n    print(\"Phase 2: Computing Functor \u2131(v)\")\n    print(\"-\" * 60)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 183,
      "alignment": 0.576287778359246,
      "coherence": 0.576287778359246,
      "comment_phi_k": 6.455952380952381,
      "code_phi_k": 24.38455106984519
    },
    {
      "comment": "# Phase 3: Compute discrete zeta at critical line",
      "code": "        print(f\"  \u2131({voice['name']}) = {F_v:.4f}\")\n    print()\n    \n    # Phase 3: Compute discrete zeta at critical line\n    print(\"Phase 3: Computing \u03b6_opic(s) at Critical Line\")\n    print(\"-\" * 60)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 194,
      "alignment": 0.6309723672817592,
      "coherence": 0.6309723672817592,
      "comment_phi_k": 10.661309523809523,
      "code_phi_k": 25.680957930957934
    },
    {
      "comment": "First non-trivial zero approximation",
      "code": "s_critical = 0.5 + 14.134725j",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 198,
      "alignment": 0.559386084157306,
      "coherence": 0.559386084157306,
      "comment_phi_k": 7.02442834942835,
      "code_phi_k": 1.491468253968254
    },
    {
      "comment": "# Phase 4: Test functional equation",
      "code": "    print(f\"  \u03b6_opic(s) = {zeta_critical:.6f}\")\n    print()\n    \n    # Phase 4: Test functional equation\n    print(\"Phase 4: Testing Functional Equation\")\n    print(\"-\" * 60)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 205,
      "alignment": 0.5974771534750176,
      "coherence": 0.5974771534750176,
      "comment_phi_k": 6.93015873015873,
      "code_phi_k": 21.238881951381952
    },
    {
      "comment": "# Phase 5: Field evolution simulation",
      "code": "    print(f\"  |\u03b6(s)| / |\u03b6(1-s)| = {ratio:.6f}\")\n    print()\n    \n    # Phase 5: Field evolution simulation\n    print(\"Phase 5: Field Evolution Simulation\")\n    print(\"-\" * 60)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 223,
      "alignment": 0.6073034860166032,
      "coherence": 0.6073034860166032,
      "comment_phi_k": 7.322619047619048,
      "code_phi_k": 20.721843434343437
    },
    {
      "comment": "# Try to load real coherence data",
      "code": "    print(\"Phase 5: Field Evolution Simulation\")\n    print(\"-\" * 60)\n    \n    # Try to load real coherence data\n    coherence_file = Path('build/coherence_scan.json')\n    coherence_data = None",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 227,
      "alignment": 0.5974153864345386,
      "coherence": 0.5974153864345386,
      "comment_phi_k": 8.178373015873015,
      "code_phi_k": 25.07758812293379
    },
    {
      "comment": "# Check if |\u03a6| is approximately constant (oscillatory region)",
      "code": "    \n    phi_evolution = simulate_field_evolution(initial_phi, time_steps, dt, coherence_data)\n    \n    # Check if |\u03a6| is approximately constant (oscillatory region)\n    phi_magnitudes = [abs(p) for p in phi_evolution]\n    phi_variance = sum((m - sum(phi_magnitudes)/len(phi_magnitudes))**2 for m in phi_magnitudes) / len(phi_magnitudes)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 245,
      "alignment": 0.5807342861589935,
      "coherence": 0.5807342861589935,
      "comment_phi_k": 11.327206127206125,
      "code_phi_k": 40.73917834304188
    },
    {
      "comment": "# Results summary",
      "code": "    print(f\"  Final \u03a6: {phi_evolution[-1]:.6f}\")\n    print()\n    \n    # Results summary\n    print(\"=\" * 60)\n    print(\"Results Summary\")",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 254,
      "alignment": 0.5663220272982337,
      "coherence": 0.5663220272982337,
      "comment_phi_k": 3.317857142857143,
      "code_phi_k": 14.165546953046952
    },
    {
      "comment": "# Save results",
      "code": "    print(\"  - Run control test with random voices\")\n    print(\"=\" * 60)\n    \n    # Save results\n    results = {\n        'coherence_symmetry': coherence_symmetry,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/riemann_experiment.py",
      "line": 274,
      "alignment": 0.541909737496598,
      "coherence": 0.541909737496598,
      "comment_phi_k": 3.0880952380952382,
      "code_phi_k": 19.96515583015196
    },
    {
      "comment": "Test enhanced zero interpretation",
      "code": "def demo_enhanced_zero_interpretation():\n    \"\"\"Test enhanced zero interpretation\"\"\"\n    print(\"=\" * 60)\n    print(\"Enhanced Zero Interpretation\")\n    print(\"=\" * 60)\n    \n    executor = OpicExecutor(Path(__file__).parent.parent)\n    \n    # Simulate zero movements\n    movements = {\n        \"movements\": [\n            {\"movement\": 0.7, \"magnitude\": 0.7, \"new_zero\": False},\n            {\"movement\": 0.3, \"magnitude\": 0.3, \"new_zero\": False}\n        ],\n        \"max_movement\": 0.7,\n        \"total_move",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/composer_demo.py",
      "line": 13,
      "alignment": 0.523981858440799,
      "coherence": 0.523981858440799,
      "comment_phi_k": 7.2070998445998455,
      "code_phi_k": 78.73429784151466
    },
    {
      "comment": "Test ion extraction from intent",
      "code": "def demo_ion_extraction():\n    \"\"\"Test ion extraction from intent\"\"\"\n    print(\"=\" * 60)\n    print(\"Ion Extraction\")\n    print(\"=\" * 60)\n    \n    executor = OpicExecutor(Path(__file__).parent.parent)\n    \n    intent = \"zeta field represents coherence potential\"\n    \n    result = executor._call_primitive(\"extract_ions\", {\n        \"intent\": intent\n    })\n    \n    print(f\"\\nIntent: {intent}\")\n    print(f\"\\nExtracted {len(result)} ions:\")\n    for ion in result:\n        print(f\"  - {ion.get('word')}:",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/composer_demo.py",
      "line": 43,
      "alignment": 0.5351108649301034,
      "coherence": 0.5351108649301034,
      "comment_phi_k": 8.19920634920635,
      "code_phi_k": 62.480437465703936
    },
    {
      "comment": "Test composer planning with zeros.on.critical",
      "code": "def demo_composer_planning():\n    \"\"\"Test composer planning with zeros.on.critical\"\"\"\n    print(\"=\" * 60)\n    print(\"Composer Planning with Zeros.on.Critical\")\n    print(\"=\" * 60)\n    \n    executor = OpicExecutor(Path(__file__).parent.parent)\n    \n    intent = \"zeta field represents coherence potential\"\n    \n    # Extract ions\n    ions = executor._call_primitive(\"extract_ions\", {\"intent\": intent})\n    \n    # Composer plan\n    plan_result = executor._call_primitive(\"composer.plan\", {\"ions\": ions}",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/composer_demo.py",
      "line": 63,
      "alignment": 0.5197906977686664,
      "coherence": 0.5197906977686664,
      "comment_phi_k": 8.108565943860063,
      "code_phi_k": 106.48328823795389
    },
    {
      "comment": "Test coherence maximization",
      "code": "def demo_coherence_maximization():\n    \"\"\"Test coherence maximization\"\"\"\n    print(\"=\" * 60)\n    print(\"Coherence Maximization\")\n    print(\"=\" * 60)\n    \n    executor = OpicExecutor(Path(__file__).parent.parent)\n    \n    intent = \"zeta field represents coherence potential\"\n    \n    # Get plan\n    ions = executor._call_primitive(\"extract_ions\", {\"intent\": intent})\n    plan_result = executor._call_primitive(\"composer.plan\", {\"ions\": ions})\n    \n    # Maximize coherence\n    optimal_result = executo",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/composer_demo.py",
      "line": 92,
      "alignment": 0.5166591341826868,
      "coherence": 0.5166591341826868,
      "comment_phi_k": 5.387932900432901,
      "code_phi_k": 83.54950253852566
    },
    {
      "comment": "Test full generation pipeline",
      "code": "def demo_generation_pipeline():\n    \"\"\"Test full generation pipeline\"\"\"\n    print(\"=\" * 60)\n    print(\"Full Generation Pipeline\")\n    print(\"=\" * 60)\n    \n    executor = OpicExecutor(Path(__file__).parent.parent)\n    \n    intent = \"zeta field represents coherence potential\"\n    \n    result = executor._call_primitive(\"generate.coherent\", {\n        \"intent\": intent\n    })\n    \n    print(f\"\\nIntent: {intent}\")\n    print(f\"\\nGenerated output: {result.get('output', '')}\")\n    print(f\"Coherence: {resu",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/composer_demo.py",
      "line": 117,
      "alignment": 0.5248959400920605,
      "coherence": 0.5248959400920605,
      "comment_phi_k": 6.503968253968255,
      "code_phi_k": 68.56351915958177
    },
    {
      "comment": "!/usr/bin/env python3",
      "code": "#!/usr/bin/env python3\n\"\"\"\nComposer Planning & Generation Demo",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/composer_demo.py",
      "line": 1,
      "alignment": 0.5736092440792826,
      "coherence": 0.5736092440792826,
      "comment_phi_k": 2.306354756354756,
      "code_phi_k": 8.986278998779
    },
    {
      "comment": "# Simulate zero movements",
      "code": "    \n    executor = OpicExecutor(Path(__file__).parent.parent)\n    \n    # Simulate zero movements\n    movements = {\n        \"movements\": [",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/composer_demo.py",
      "line": 21,
      "alignment": 0.6177430978716911,
      "coherence": 0.6177430978716911,
      "comment_phi_k": 5.169246031746033,
      "code_phi_k": 13.5603110289809
    },
    {
      "comment": "# Extract ions",
      "code": "    \n    intent = \"zeta field represents coherence potential\"\n    \n    # Extract ions\n    ions = executor._call_primitive(\"extract_ions\", {\"intent\": intent})\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/composer_demo.py",
      "line": 73,
      "alignment": 0.5476275194872574,
      "coherence": 0.5476275194872574,
      "comment_phi_k": 3.6880952380952383,
      "code_phi_k": 21.20310346428211
    },
    {
      "comment": "# Composer plan",
      "code": "    # Extract ions\n    ions = executor._call_primitive(\"extract_ions\", {\"intent\": intent})\n    \n    # Composer plan\n    plan_result = executor._call_primitive(\"composer.plan\", {\"ions\": ions})\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/composer_demo.py",
      "line": 76,
      "alignment": 0.5375883551107022,
      "coherence": 0.5375883551107022,
      "comment_phi_k": 2.988690476190476,
      "code_phi_k": 21.37211368119697
    },
    {
      "comment": "Show first 5",
      "code": "for step in plan_result.get('plan', [])[:5]:",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/composer_demo.py",
      "line": 87,
      "alignment": 0.6511727751189793,
      "coherence": 0.6511727751189793,
      "comment_phi_k": 2.6,
      "code_phi_k": 5.5997160003738955
    },
    {
      "comment": "# Get plan",
      "code": "    \n    intent = \"zeta field represents coherence potential\"\n    \n    # Get plan\n    ions = executor._call_primitive(\"extract_ions\", {\"intent\": intent})\n    plan_result = executor._call_primitive(\"composer.plan\", {\"ions\": ions})",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/composer_demo.py",
      "line": 102,
      "alignment": 0.5228918371753123,
      "coherence": 0.5228918371753123,
      "comment_phi_k": 2.375,
      "code_phi_k": 27.124693046276334
    },
    {
      "comment": "# Maximize coherence",
      "code": "    ions = executor._call_primitive(\"extract_ions\", {\"intent\": intent})\n    plan_result = executor._call_primitive(\"composer.plan\", {\"ions\": ions})\n    \n    # Maximize coherence\n    optimal_result = executor._call_primitive(\"composer.coherence_maximization\", {\n        \"plan\": plan_result.get(\"plan\", [])",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/composer_demo.py",
      "line": 106,
      "alignment": 0.5381602953954701,
      "coherence": 0.5381602953954701,
      "comment_phi_k": 3.808134920634921,
      "code_phi_k": 26.85234734894074
    },
    {
      "comment": "Measure coherence from actual voice execution characteristics",
      "code": "def measure_voice_coherence(voice_name, voice_body, all_voices):\n    \"\"\"Measure coherence from actual voice execution characteristics\"\"\"\n    \n    # Extract voice structure\n    steps = [s.strip() for s in voice_body.split('->')]\n    complexity = len(steps)\n    \n    # Compute coherence based on voice structure\n    # 1. Namespace coherence (namespaced voices tend to be more coherent)\n    namespace_coherence = 0.1 if '.' in voice_name else 0.0\n    \n    # 2. Simplicity coherence (simpler voices = mor",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 15,
      "alignment": 0.5122582328433201,
      "coherence": 0.5122582328433201,
      "comment_phi_k": 13.021385558885559,
      "code_phi_k": 272.07477785842235
    },
    {
      "comment": "Scan entire voice network for coherence",
      "code": "def scan_voice_network():\n    \"\"\"Scan entire voice network for coherence\"\"\"\n    print(\"=\" * 60)\n    print(\"Coherence Scan - Live Voice Network\")\n    print(\"=\" * 60)\n    print()\n    \n    # Load Phase 1 results (all voices)\n    phase1_file = Path('build/phase1_prime_voices.json')\n    if not phase1_file.exists():\n        print(\"Error: Phase 1 results not found!\")\n        print(\"Run: make phase1\")\n        return None\n    \n    with open(phase1_file, 'r') as f:\n        phase1_results = json.load(f)\n  ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 70,
      "alignment": 0.5080022579303697,
      "coherence": 0.5080022579303697,
      "comment_phi_k": 9.541468253968254,
      "code_phi_k": 302.8574846726337
    },
    {
      "comment": "!/usr/bin/env python3",
      "code": "#!/usr/bin/env python3\n\"\"\"\nCoherence Scan - Measure real coherence from live opic voice network",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 1,
      "alignment": 0.5338526458135192,
      "coherence": 0.5338526458135192,
      "comment_phi_k": 2.306354756354756,
      "code_phi_k": 18.18548534798535
    },
    {
      "comment": "# Extract voice structure",
      "code": "def measure_voice_coherence(voice_name, voice_body, all_voices):\n    \"\"\"Measure coherence from actual voice execution characteristics\"\"\"\n    \n    # Extract voice structure\n    steps = [s.strip() for s in voice_body.split('->')]\n    complexity = len(steps)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 18,
      "alignment": 0.5392710689240913,
      "coherence": 0.5392710689240913,
      "comment_phi_k": 5.221230158730158,
      "code_phi_k": 35.84901615792055
    },
    {
      "comment": "# Compute coherence based on voice structure",
      "code": "    steps = [s.strip() for s in voice_body.split('->')]\n    complexity = len(steps)\n    \n    # Compute coherence based on voice structure\n    # 1. Namespace coherence (namespaced voices tend to be more coherent)\n    namespace_coherence = 0.1 if '.' in voice_name else 0.0",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 22,
      "alignment": 0.5648456393273563,
      "coherence": 0.5648456393273563,
      "comment_phi_k": 9.737698412698414,
      "code_phi_k": 42.41068900354891
    },
    {
      "comment": "# 1. Namespace coherence (namespaced voices tend to be more coherent)",
      "code": "    complexity = len(steps)\n    \n    # Compute coherence based on voice structure\n    # 1. Namespace coherence (namespaced voices tend to be more coherent)\n    namespace_coherence = 0.1 if '.' in voice_name else 0.0\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 23,
      "alignment": 0.6184428011634278,
      "coherence": 0.6184428011634278,
      "comment_phi_k": 13.501208513708512,
      "code_phi_k": 35.24792190953182
    },
    {
      "comment": "# 2. Simplicity coherence (simpler voices = more coherent)",
      "code": "    # 1. Namespace coherence (namespaced voices tend to be more coherent)\n    namespace_coherence = 0.1 if '.' in voice_name else 0.0\n    \n    # 2. Simplicity coherence (simpler voices = more coherent)\n    simplicity_coherence = max(0, 0.2 - (complexity - 1) * 0.05)\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 26,
      "alignment": 0.5777329161935798,
      "coherence": 0.5777329161935798,
      "comment_phi_k": 9.861309523809524,
      "code_phi_k": 36.64601424762028
    },
    {
      "comment": "# 3. Referenced voice coherence (voices that reference other voices)",
      "code": "    # 2. Simplicity coherence (simpler voices = more coherent)\n    simplicity_coherence = max(0, 0.2 - (complexity - 1) * 0.05)\n    \n    # 3. Referenced voice coherence (voices that reference other voices)\n    referenced = []\n    for step in steps:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 29,
      "alignment": 0.6185907860145564,
      "coherence": 0.6185907860145564,
      "comment_phi_k": 13.381547619047621,
      "code_phi_k": 34.900274877771004
    },
    {
      "comment": "# Extract potential voice names",
      "code": "    # 3. Referenced voice coherence (voices that reference other voices)\n    referenced = []\n    for step in steps:\n        # Extract potential voice names\n        parts = step.replace('+', ' ').replace('->', ' ').split()\n        referenced.extend([p for p in parts if p in all_voices])",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 32,
      "alignment": 0.5438448400398601,
      "coherence": 0.5438448400398601,
      "comment_phi_k": 6.994841269841269,
      "code_phi_k": 43.381482610526724
    },
    {
      "comment": "# Check if referenced voices exist and are coherent",
      "code": "    \n    reference_coherence = 0.0\n    if referenced:\n        # Check if referenced voices exist and are coherent\n        ref_coherences = []\n        for ref_name in set(referenced[:5]):  # Limit to avoid explosion",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 38,
      "alignment": 0.6209684001896564,
      "coherence": 0.6209684001896564,
      "comment_phi_k": 12.903968253968253,
      "code_phi_k": 33.12004006914998
    },
    {
      "comment": "Limit to avoid explosion",
      "code": "for ref_name in set(referenced[:5]):",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 40,
      "alignment": 0.9208816871571341,
      "coherence": 0.9208816871571341,
      "comment_phi_k": 6.598412698412698,
      "code_phi_k": 6.031504606504607
    },
    {
      "comment": "# Simpler referenced voices = higher coherence",
      "code": "            if ref_name in all_voices:\n                ref_body = all_voices[ref_name].get('body', '')\n                ref_steps = len([s.strip() for s in ref_body.split('->')])\n                # Simpler referenced voices = higher coherence\n                ref_coherence = max(0, 0.1 - (ref_steps - 1) * 0.02)\n                ref_coherences.append(ref_coherence)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 44,
      "alignment": 0.5754660926988049,
      "coherence": 0.5754660926988049,
      "comment_phi_k": 8.853174603174603,
      "code_phi_k": 33.754906439921356
    },
    {
      "comment": "# 4. Base coherence",
      "code": "        if ref_coherences:\n            reference_coherence = sum(ref_coherences) / len(ref_coherences)\n    \n    # 4. Base coherence\n    base_coherence = 0.7\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 51,
      "alignment": 0.5619929568826356,
      "coherence": 0.5619929568826356,
      "comment_phi_k": 3.345039682539683,
      "code_phi_k": 15.162115477401853
    },
    {
      "comment": "# Total coherence",
      "code": "    # 4. Base coherence\n    base_coherence = 0.7\n    \n    # Total coherence\n    coherence = base_coherence + namespace_coherence + simplicity_coherence + reference_coherence\n    coherence = min(1.0, max(0.0, coherence))",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 54,
      "alignment": 0.5352789706439199,
      "coherence": 0.5352789706439199,
      "comment_phi_k": 3.445039682539683,
      "code_phi_k": 26.13536139857735
    },
    {
      "comment": "# Spectral magnitude (proxy for ||voice_matrix(v)||\u2082)",
      "code": "    coherence = base_coherence + namespace_coherence + simplicity_coherence + reference_coherence\n    coherence = min(1.0, max(0.0, coherence))\n    \n    # Spectral magnitude (proxy for ||voice_matrix(v)||\u2082)\n    # Use coherence as base, adjust for complexity\n    spectral_magnitude = coherence * (1.0 - (complexity - 1) * 0.05)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 58,
      "alignment": 0.54555162766132,
      "coherence": 0.54555162766132,
      "comment_phi_k": 6.734580003330003,
      "code_phi_k": 40.32853787079793
    },
    {
      "comment": "# Use coherence as base, adjust for complexity",
      "code": "    coherence = min(1.0, max(0.0, coherence))\n    \n    # Spectral magnitude (proxy for ||voice_matrix(v)||\u2082)\n    # Use coherence as base, adjust for complexity\n    spectral_magnitude = coherence * (1.0 - (complexity - 1) * 0.05)\n    spectral_magnitude = max(0.1, spectral_magnitude)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 59,
      "alignment": 0.5951020124083398,
      "coherence": 0.5951020124083398,
      "comment_phi_k": 11.055357142857144,
      "code_phi_k": 34.589516651649014
    },
    {
      "comment": "# Load Phase 1 results (all voices)",
      "code": "    print(\"=\" * 60)\n    print()\n    \n    # Load Phase 1 results (all voices)\n    phase1_file = Path('build/phase1_prime_voices.json')\n    if not phase1_file.exists():",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 77,
      "alignment": 0.6211130774357841,
      "coherence": 0.6211130774357841,
      "comment_phi_k": 7.071428571428571,
      "code_phi_k": 18.13246288038594
    },
    {
      "comment": "# Get all voices (prime + decomposable)",
      "code": "    with open(phase1_file, 'r') as f:\n        phase1_results = json.load(f)\n    \n    # Get all voices (prime + decomposable)\n    prime_voices = {v['name']: v for v in phase1_results.get('prime_voices', [])}\n    decomposable_voices = {v['name']: v for v in phase1_results.get('decomposable_voices', [])}",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 87,
      "alignment": 0.561253991814375,
      "coherence": 0.561253991814375,
      "comment_phi_k": 7.353589466089467,
      "code_phi_k": 33.68948961329797
    },
    {
      "comment": "# Measure coherence for each voice",
      "code": "    print(f\"Scanning {len(all_voices)} voices...\")\n    print()\n    \n    # Measure coherence for each voice\n    measurements = []\n    for i, (name, voice) in enumerate(all_voices.items()):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 95,
      "alignment": 0.5980206335736555,
      "coherence": 0.5980206335736555,
      "comment_phi_k": 8.429563492063492,
      "code_phi_k": 25.71424360609328
    },
    {
      "comment": "# Compute statistics",
      "code": "    print(f\"\u2713 Scanned {len(measurements)} voices\")\n    print()\n    \n    # Compute statistics\n    coherences = [m['coherence'] for m in measurements]\n    avg_coherence = sum(coherences) / len(coherences)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 112,
      "alignment": 0.5372420446130525,
      "coherence": 0.5372420446130525,
      "comment_phi_k": 3.511507936507936,
      "code_phi_k": 25.3279555819997
    },
    {
      "comment": "# Save scan results",
      "code": "    print(f\"  Max: {max_coherence:.4f}\")\n    print()\n    \n    # Save scan results\n    scan_results = {\n        'total_voices': len(measurements),",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/coherence_scan.py",
      "line": 125,
      "alignment": 0.5844507765788964,
      "coherence": 0.5844507765788964,
      "comment_phi_k": 4.296428571428572,
      "code_phi_k": 14.866950410700412
    },
    {
      "comment": "Test actual loss function implementations",
      "code": "def test_loss_functions():\n    \"\"\"Test actual loss function implementations\"\"\"\n    print(\"Test: Loss Functions\")\n    print(\"-\" * 60)\n    \n    # Generate Swift code with loss functions\n    result = subprocess.run(\n        [sys.executable, \"generate.py\", \"swift\", \"loss.ops\", \"/tmp/loss.swift\"],\n        capture_output=True,\n        timeout=5\n    )\n    \n    if result.returncode != 0:\n        print(\"  \u2717 Failed to generate loss functions\")\n        return False\n    \n    # Create test harness\n    test_c",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/real_tests.py",
      "line": 9,
      "alignment": 0.5092516933705487,
      "coherence": 0.5092516933705487,
      "comment_phi_k": 8.757695082695083,
      "code_phi_k": 241.02998620137498
    },
    {
      "comment": "Test actual optimization with gradients",
      "code": "def test_optimization():\n    \"\"\"Test actual optimization with gradients\"\"\"\n    print(\"\\nTest: Optimization\")\n    print(\"-\" * 60)\n    \n    # Generate optimization code\n    opt_ops = \"\"\"\ndef weight { value }\ndef gradient { value }\ndef learning_rate { value: 0.01 }\n\nvoice compute.gradient / {loss -> gradient}\nvoice update.weight / {weight + gradient + learning_rate -> weight}\n\ntarget optimized / \"weight\"\nvoice main / {weight + gradient -> optimized}\n\"\"\"\n    \n    opt_file = Path(\"/tmp/opt_test.ops\")",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/real_tests.py",
      "line": 91,
      "alignment": 0.5073182065442794,
      "coherence": 0.5073182065442794,
      "comment_phi_k": 8.715710678210678,
      "code_phi_k": 302.09851848777186
    },
    {
      "comment": "Test actual paradigm synthesis with working code",
      "code": "def test_paradigm_synthesis_real():\n    \"\"\"Test actual paradigm synthesis with working code\"\"\"\n    print(\"\\nTest: Paradigm Synthesis (Real)\")\n    print(\"-\" * 60)\n    \n    synthesis_ops = \"\"\"\ndef quantum { state: superposition }\ndef archetype { type: collective }\n\nvoice synthesize / {quantum + archetype -> hybrid}\n\ntarget hybrid / \"synthesized\"\nvoice main / {quantum + archetype -> hybrid}\n\"\"\"\n    \n    test_file = Path(\"/tmp/synth_real.ops\")\n    test_file.write_text(synthesis_ops)\n    \n    result ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/real_tests.py",
      "line": 183,
      "alignment": 0.5110223598037114,
      "coherence": 0.5110223598037114,
      "comment_phi_k": 10.974007936507936,
      "code_phi_k": 254.39032712081834
    },
    {
      "comment": "Run tests that verify actual functionality",
      "code": "def run_real_tests():\n    \"\"\"Run tests that verify actual functionality\"\"\"\n    print(\"=\" * 60)\n    print(\"Real Functionality Tests\")\n    print(\"=\" * 60)\n    print()\n    print(\"These tests verify actual implementations, not just code structure\")\n    print()\n    \n    tests = [\n        (\"Loss Functions\", test_loss_functions),\n        (\"Optimization\", test_optimization),\n        (\"Paradigm Synthesis\", test_paradigm_synthesis_real),\n    ]\n    \n    results = []\n    for name, test_func in tests:\n      ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/real_tests.py",
      "line": 265,
      "alignment": 0.5147081843218942,
      "coherence": 0.5147081843218942,
      "comment_phi_k": 9.412505550005552,
      "code_phi_k": 164.6938036515976
    },
    {
      "comment": "!/usr/bin/env python3",
      "code": "#!/usr/bin/env python3\n\"\"\"Real functionality tests \u2014 Verify actual implementations work\"\"\"\n",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/real_tests.py",
      "line": 1,
      "alignment": 0.5467281501574419,
      "coherence": 0.5467281501574419,
      "comment_phi_k": 2.306354756354756,
      "code_phi_k": 13.492392329892327
    },
    {
      "comment": "# Generate Swift code with loss functions",
      "code": "    print(\"Test: Loss Functions\")\n    print(\"-\" * 60)\n    \n    # Generate Swift code with loss functions\n    result = subprocess.run(\n        [sys.executable, \"generate.py\", \"swift\", \"loss.ops\", \"/tmp/loss.swift\"],",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/real_tests.py",
      "line": 14,
      "alignment": 0.6144854814167919,
      "coherence": 0.6144854814167919,
      "comment_phi_k": 9.007341269841271,
      "code_phi_k": 24.172848679098678
    },
    {
      "comment": "# Create test harness",
      "code": "        print(\"  \u2717 Failed to generate loss functions\")\n        return False\n    \n    # Create test harness\n    test_code = \"\"\"\nimport Foundation",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/real_tests.py",
      "line": 25,
      "alignment": 0.5566542485732403,
      "coherence": 0.5566542485732403,
      "comment_phi_k": 4.538095238095238,
      "code_phi_k": 22.294444444444444
    },
    {
      "comment": "# Compile and run",
      "code": "    test_file = Path(\"/tmp/test_loss.swift\")\n    test_file.write_text(test_code)\n    \n    # Compile and run\n    compile_result = subprocess.run(\n        [\"swiftc\", \"-o\", \"/tmp/test_loss\", str(test_file)],",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/real_tests.py",
      "line": 61,
      "alignment": 0.5687161308389699,
      "coherence": 0.5687161308389699,
      "comment_phi_k": 4.3011904761904765,
      "code_phi_k": 17.79899694405689
    },
    {
      "comment": "# Run test",
      "code": "        print(f\"    {compile_result.stderr.decode()[:100]}\")\n        return False\n    \n    # Run test\n    run_result = subprocess.run(\n        [\"/tmp/test_loss\"],",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/real_tests.py",
      "line": 73,
      "alignment": 0.5509948744639478,
      "coherence": 0.5509948744639478,
      "comment_phi_k": 2.4583333333333335,
      "code_phi_k": 13.281031482371427
    },
    {
      "comment": "# Generate optimization code",
      "code": "    print(\"\\nTest: Optimization\")\n    print(\"-\" * 60)\n    \n    # Generate optimization code\n    opt_ops = \"\"\"\ndef weight { value }",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/real_tests.py",
      "line": 96,
      "alignment": 0.5994504758398977,
      "coherence": 0.5994504758398977,
      "comment_phi_k": 5.71432178932179,
      "code_phi_k": 17.221903096903098
    },
    {
      "comment": "# Test optimization",
      "code": "        print(\"  \u2717 Failed to generate optimization code\")\n        return False\n    \n    # Test optimization\n    test_code = \"\"\"\nimport Foundation",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/real_tests.py",
      "line": 122,
      "alignment": 0.5456061063014477,
      "coherence": 0.5456061063014477,
      "comment_phi_k": 3.7095598845598845,
      "code_phi_k": 22.189556277056276
    },
    {
      "comment": "# Test that synthesis actually combines values",
      "code": "        print(\"  \u2717 Failed to generate synthesis code\")\n        return False\n    \n    # Test that synthesis actually combines values\n    test_code = \"\"\"\nimport Foundation",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/real_tests.py",
      "line": 211,
      "alignment": 0.6072511961510909,
      "coherence": 0.6072511961510909,
      "comment_phi_k": 9.624603174603173,
      "code_phi_k": 27.24702380952381
    },
    {
      "comment": "!/usr/bin/env python3",
      "code": "#!/usr/bin/env python3\n\"\"\"\nEmit JSONL trace: {file, line, phi_entropy, phi_curvature, boundary_score}",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/field_seed.py",
      "line": 1,
      "alignment": 0.5428831329652752,
      "coherence": 0.5428831329652752,
      "comment_phi_k": 2.306354756354756,
      "code_phi_k": 14.598759573759573
    },
    {
      "comment": "Import opic executor to use voices",
      "code": "from collections import Counter\nimport math\n\n# Import opic executor to use voices\nsys.path.insert(0, str(Path(__file__).parent.parent))\nfrom scripts.opic_executor import OpicExecutor",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/field_seed.py",
      "line": 14,
      "alignment": 0.5964224395519601,
      "coherence": 0.5964224395519601,
      "comment_phi_k": 10.080357142857144,
      "code_phi_k": 31.17609980951612
    },
    {
      "comment": "# Use ordinal second-difference magnitude average",
      "code": "    return ent\n\ndef curvature(line: str) -> float:\n    # Use ordinal second-difference magnitude average\n    xs = [ord(c) for c in line]\n    if len(xs) < 3:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/field_seed.py",
      "line": 30,
      "alignment": 0.6107485099734654,
      "coherence": 0.6107485099734654,
      "comment_phi_k": 9.7997832641215,
      "code_phi_k": 27.02159617343441
    },
    {
      "comment": "# Smooth absolute entropy delta",
      "code": "    return acc / max(cnt, 1)\n\ndef boundary(prev_entropy: float, this_entropy: float, prev_score: float) -> float:\n    # Smooth absolute entropy delta\n    delta = abs(this_entropy - prev_entropy)\n    # EWMA with alpha=0.3",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/field_seed.py",
      "line": 43,
      "alignment": 0.5572964105827288,
      "coherence": 0.5572964105827288,
      "comment_phi_k": 7.03452380952381,
      "code_phi_k": 34.2108242849342
    },
    {
      "comment": "# EWMA with alpha=0.3",
      "code": "def boundary(prev_entropy: float, this_entropy: float, prev_score: float) -> float:\n    # Smooth absolute entropy delta\n    delta = abs(this_entropy - prev_entropy)\n    # EWMA with alpha=0.3\n    alpha = 0.3\n    return (1 - alpha) * prev_score + alpha * delta",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/field_seed.py",
      "line": 45,
      "alignment": 0.5314313601962607,
      "coherence": 0.5314313601962607,
      "comment_phi_k": 4.7,
      "code_phi_k": 39.73304650715642
    },
    {
      "comment": "# Skip hidden and build/venv/node_modules",
      "code": "\ndef iter_files(root: Path):\n    for dirpath, dirnames, filenames in os.walk(root):\n        # Skip hidden and build/venv/node_modules\n        if any(part.startswith('.') for part in Path(dirpath).parts):\n            continue",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/field_seed.py",
      "line": 51,
      "alignment": 0.5564123114568884,
      "coherence": 0.5564123114568884,
      "comment_phi_k": 6.53357446572213,
      "code_phi_k": 32.221346516942326
    },
    {
      "comment": "# Skip binaries",
      "code": "            continue\n        for fn in filenames:\n            p = Path(dirpath) / fn\n            # Skip binaries\n            try:\n                text = p.read_text(encoding='utf-8', errors='ignore')",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/field_seed.py",
      "line": 58,
      "alignment": 0.5431998816888871,
      "coherence": 0.5431998816888871,
      "comment_phi_k": 3.09702380952381,
      "code_phi_k": 19.471152479495796
    },
    {
      "comment": "# Try to use opic voices first",
      "code": "    root = Path(sys.argv[1]) if len(sys.argv) > 1 else Path(\".\")\n    out = sys.stdout\n    \n    # Try to use opic voices first\n    executor = OpicExecutor(root)\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/field_seed.py",
      "line": 69,
      "alignment": 0.5981469274747248,
      "coherence": 0.5981469274747248,
      "comment_phi_k": 8.341666666666667,
      "code_phi_k": 25.41873910403322
    },
    {
      "comment": "# Use opic-native execution via voices",
      "code": "    executor = OpicExecutor(root)\n    \n    if \"corpus.read\" in executor.voices and \"corpus.project\" in executor.voices:\n        # Use opic-native execution via voices\n        files = []\n        for p, text in iter_files(root):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/field_seed.py",
      "line": 73,
      "alignment": 0.5751982448309563,
      "coherence": 0.5751982448309563,
      "comment_phi_k": 9.22245670995671,
      "code_phi_k": 35.27170696950109
    },
    {
      "comment": "# Execute corpus.read -> corpus.project chain",
      "code": "        for p, text in iter_files(root):\n            files.append({\"path\": str(p), \"content\": text})\n        \n        # Execute corpus.read -> corpus.project chain\n        read_result = executor.execute_voice(\"corpus.read\", {\"path\": root})\n        if read_result:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/field_seed.py",
      "line": 78,
      "alignment": 0.5713617111271904,
      "coherence": 0.5713617111271904,
      "comment_phi_k": 7.457942057942058,
      "code_phi_k": 29.85622449634346
    },
    {
      "comment": "# Execute corpus.project with lines",
      "code": "        # Execute corpus.read -> corpus.project chain\n        read_result = executor.execute_voice(\"corpus.read\", {\"path\": root})\n        if read_result:\n            # Execute corpus.project with lines\n            lines = []\n            for p, text in iter_files(root):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/field_seed.py",
      "line": 81,
      "alignment": 0.5591727138258689,
      "coherence": 0.5591727138258689,
      "comment_phi_k": 6.938876401376402,
      "code_phi_k": 32.78563798576082
    },
    {
      "comment": "# Voice returned traces directly",
      "code": "            \n            project_result = executor.execute_voice(\"corpus.project\", {\"lines\": lines})\n            if project_result and isinstance(project_result, list):\n                # Voice returned traces directly\n                for trace in project_result:\n                    out.write(json.dumps(trace, ensure_ascii=False) + \"\\n\")",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/field_seed.py",
      "line": 90,
      "alignment": 0.5549914559397984,
      "coherence": 0.5549914559397984,
      "comment_phi_k": 6.689285714285714,
      "code_phi_k": 33.75521118983429
    },
    {
      "comment": "# Voice returned JSONL string",
      "code": "                    out.write(json.dumps(trace, ensure_ascii=False) + \"\\n\")\n                return\n            elif project_result and isinstance(project_result, str):\n                # Voice returned JSONL string\n                for line in project_result.split('\\n'):\n                    if line.strip():",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/field_seed.py",
      "line": 95,
      "alignment": 0.5551506116065514,
      "coherence": 0.5551506116065514,
      "comment_phi_k": 6.122023809523809,
      "code_phi_k": 30.812398658179895
    },
    {
      "comment": "# Fallback: direct Python computation (matches opic voice semantics)",
      "code": "                        out.write(line + \"\\n\")\n                return\n    \n    # Fallback: direct Python computation (matches opic voice semantics)\n    prev_ent_for_file = {}\n    prev_bnd_for_file = {}",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/field_seed.py",
      "line": 101,
      "alignment": 0.7261776251109444,
      "coherence": 0.7261776251109444,
      "comment_phi_k": 12.97878787878788,
      "code_phi_k": 20.835185076361547
    },
    {
      "comment": "Evaluate opic on actual benchmark datasets",
      "code": "class RealBenchmarkEvaluator:\n    \"\"\"Evaluate opic on actual benchmark datasets\"\"\"\n    \n    def __init__(self, project_root: Path):\n        self.project_root = project_root\n        self.data_dir = project_root / \"data\" / \"benchmarks\"\n        self.results = {}\n        # Initialize opic executor with Field Spec 0.7\n        self.opic = OpicExecutor(project_root)\n        print(f\"  \u2713 Loaded {len(self.opic.voices)} opic voices (including Field Spec 0.7)\")\n        # Initialize code-output learner\n     ",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 47,
      "alignment": 0.5020522708941761,
      "coherence": 0.5020522708941761,
      "comment_phi_k": 10.732936507936508,
      "code_phi_k": 1312.8128363715925
    },
    {
      "comment": "Load MMLU dataset",
      "code": "    def load_mmlu(self) -> Dict:\n        \"\"\"Load MMLU dataset\"\"\"\n        mmlu_file = self.data_dir / \"mmlu.json\"\n        if not mmlu_file.exists():\n            print(f\"  \u26a0 MMLU dataset not found at {mmlu_file}\")\n            print(\"  Run: python3 scripts/download_benchmarks.py\")\n            return {}\n        \n        with open(mmlu_file) as f:\n            return json.load(f)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 63,
      "alignment": 0.5273572224051303,
      "coherence": 0.5273572224051303,
      "comment_phi_k": 4.379761904761905,
      "code_phi_k": 42.21369842827884
    },
    {
      "comment": "Load GPQA dataset",
      "code": "    def load_gpqa(self) -> List:\n        \"\"\"Load GPQA dataset\"\"\"\n        gpqa_file = self.data_dir / \"gpqa.json\"\n        if not gpqa_file.exists():\n            print(f\"  \u26a0 GPQA dataset not found at {gpqa_file}\")\n            print(\"  Run: python3 scripts/download_benchmarks.py\")\n            return []\n        \n        with open(gpqa_file) as f:\n            return json.load(f)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 74,
      "alignment": 0.5273572224051303,
      "coherence": 0.5273572224051303,
      "comment_phi_k": 4.379761904761905,
      "code_phi_k": 42.21369842827884
    },
    {
      "comment": "Load AIME problems",
      "code": "    def load_aime(self) -> Dict:\n        \"\"\"Load AIME problems\"\"\"\n        aime_file = self.data_dir / \"aime.json\"\n        if not aime_file.exists():\n            print(f\"  \u26a0 AIME dataset not found at {aime_file}\")\n            print(\"  Run: python3 scripts/download_benchmarks.py\")\n            return {}\n        \n        with open(aime_file) as f:\n            return json.load(f)",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 85,
      "alignment": 0.5284999437592125,
      "coherence": 0.5284999437592125,
      "comment_phi_k": 4.983928571428572,
      "code_phi_k": 46.21072223780265
    },
    {
      "comment": "Use opic's reasoning to answer a question\nExecutes opic voice chains - no direct composition",
      "code": "    def answer_question_with_opic(self, question: str, choices: List[str] = None) -> int:\n        \"\"\"\n        Use opic's reasoning to answer a question\n        Executes opic voice chains - no direct composition\n        \"\"\"\n        if not choices:\n            return 0\n        \n        # Execute opic voice - opic handles all composition internally\n        try:\n            answer_idx = self.opic.answer_question(question, choices)\n            if 0 <= answer_idx < len(choices):\n                return",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 96,
      "alignment": 0.5686606548243104,
      "coherence": 0.5686606548243104,
      "comment_phi_k": 22.85021645021645,
      "code_phi_k": 94.62492808076583
    },
    {
      "comment": "Evaluate on actual MMLU questions",
      "code": "    def evaluate_mmlu(self, sample_size: int = 100) -> float:\n        \"\"\"Evaluate on actual MMLU questions\"\"\"\n        print(\"\\n\" + \"=\" * 60)\n        print(\"MMLU Evaluation (Real Dataset)\")\n        print(\"=\" * 60)\n        \n        mmlu_data = self.load_mmlu()\n        if not mmlu_data:\n            return 0.0\n        \n        # Collect all questions\n        all_questions = []\n        for subject, questions in mmlu_data.items():\n            for q in questions:\n                all_questions.append((s",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 116,
      "alignment": 0.5085975718475513,
      "coherence": 0.5085975718475513,
      "comment_phi_k": 8.624007936507937,
      "code_phi_k": 255.0807119658566
    },
    {
      "comment": "Evaluate on actual GPQA questions",
      "code": "    def evaluate_gpqa(self, sample_size: int = 100) -> float:\n        \"\"\"Evaluate on actual GPQA questions\"\"\"\n        print(\"\\n\" + \"=\" * 60)\n        print(\"GPQA Diamond Evaluation (Real Dataset)\")\n        print(\"=\" * 60)\n        \n        gpqa_data = self.load_gpqa()\n        if not gpqa_data:\n            return 0.0\n        \n        # Sample questions\n        sample_questions = random.sample(gpqa_data, min(sample_size, len(gpqa_data)))\n        \n        correct = 0\n        total = len(sample_questi",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 182,
      "alignment": 0.5106359661308683,
      "coherence": 0.5106359661308683,
      "comment_phi_k": 8.624007936507937,
      "code_phi_k": 207.02062090054264
    },
    {
      "comment": "Evaluate on AIME 2024 problems",
      "code": "    def evaluate_aime_2024(self, sample_size: int = 15) -> float:\n        \"\"\"Evaluate on AIME 2024 problems\"\"\"\n        print(\"\\n\" + \"=\" * 60)\n        print(\"AIME 2024 Evaluation (Real Dataset)\")\n        print(\"=\" * 60)\n        \n        aime_data = self.load_aime()\n        if \"2024\" not in aime_data:\n            return 0.0\n        \n        problems = aime_data[\"2024\"]\n        sample_problems = random.sample(problems, min(sample_size, len(problems)))\n        \n        correct = 0\n        total = le",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 239,
      "alignment": 0.5104256105038557,
      "coherence": 0.5104256105038557,
      "comment_phi_k": 7.04702380952381,
      "code_phi_k": 172.50699270230345
    },
    {
      "comment": "Run all benchmarks with real datasets",
      "code": "    def run_all_benchmarks(self) -> Dict[str, float]:\n        \"\"\"Run all benchmarks with real datasets\"\"\"\n        print(\"=\" * 60)\n        print(\"opic Benchmark Evaluation (Real Datasets)\")\n        print(\"=\" * 60)\n        print(\"\\nDataset Status:\")\n        print(\"  \u2713 MMLU: Real dataset (752 questions from 5 subjects)\")\n        gpqa_data = self.load_gpqa()\n        gpqa_count = len(gpqa_data) if gpqa_data else 0\n        print(f\"  \u26a0 GPQA: {gpqa_count} question(s) (download needs fix - full dataset h",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 289,
      "alignment": 0.5089780122051332,
      "coherence": 0.5089780122051332,
      "comment_phi_k": 8.936507936507937,
      "code_phi_k": 253.31253409182392
    },
    {
      "comment": "Display comparison table",
      "code": "    def _display_comparison_table(self, opic_results: Dict[str, float]):\n        \"\"\"Display comparison table\"\"\"\n        print(\"\\n\" + \"=\" * 80)\n        print(\"Benchmark Comparison Table (Real Datasets)\")\n        print(\"=\" * 80)\n        print()\n        print(f\"{'Benchmark':<30} {'opic':<12} {'GPT-OSS-120B':<15} {'GPT-OSS-20B':<15} {'OpenAI o3':<15} {'OpenAI o4-mini':<15}\")\n        print(\"-\" * 80)\n        \n        benchmarks = [\n            \"MMLU\",\n            \"GPQA Diamond\",\n            \"Humanity'",
      "type": "docstring",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 338,
      "alignment": 0.5114229720324275,
      "coherence": 0.5114229720324275,
      "comment_phi_k": 5.062896825396825,
      "code_phi_k": 113.3366051403935
    },
    {
      "comment": "!/usr/bin/env python3",
      "code": "#!/usr/bin/env python3\n\"\"\"\nReal benchmark evaluation using actual datasets",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 1,
      "alignment": 0.5473053496177234,
      "coherence": 0.5473053496177234,
      "comment_phi_k": 2.306354756354756,
      "code_phi_k": 13.341834554334554
    },
    {
      "comment": "Import opic executor and code-output learner",
      "code": "import time\nimport random\n\n# Import opic executor and code-output learner\nsys.path.insert(0, str(Path(__file__).parent))\nfrom opic_executor import OpicExecutor",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 14,
      "alignment": 0.6166641393442417,
      "coherence": 0.6166641393442417,
      "comment_phi_k": 10.958152958152958,
      "code_phi_k": 28.961341508732815
    },
    {
      "comment": "Baseline model scores",
      "code": "from opic_executor import OpicExecutor\nfrom code_output_learner import CodeOutputLearner\n\n# Baseline model scores\nBASELINE_SCORES = {\n    \"gpt-oss-120b\": {",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 19,
      "alignment": 0.5574205639189517,
      "coherence": 0.5574205639189517,
      "comment_phi_k": 4.8880952380952385,
      "code_phi_k": 23.726036616032744
    },
    {
      "comment": "# Initialize opic executor with Field Spec 0.7",
      "code": "        self.project_root = project_root\n        self.data_dir = project_root / \"data\" / \"benchmarks\"\n        self.results = {}\n        # Initialize opic executor with Field Spec 0.7\n        self.opic = OpicExecutor(project_root)\n        print(f\"  \u2713 Loaded {len(self.opic.voices)} opic voices (including Field Spec 0.7)\")",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 54,
      "alignment": 0.5773584772617428,
      "coherence": 0.5773584772617428,
      "comment_phi_k": 10.390674603174604,
      "code_phi_k": 38.774962221095784
    },
    {
      "comment": "# Initialize code-output learner",
      "code": "        # Initialize opic executor with Field Spec 0.7\n        self.opic = OpicExecutor(project_root)\n        print(f\"  \u2713 Loaded {len(self.opic.voices)} opic voices (including Field Spec 0.7)\")\n        # Initialize code-output learner\n        self.learner = CodeOutputLearner(project_root)\n        # Try to load existing learning data",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 57,
      "alignment": 0.5355174407087111,
      "coherence": 0.5355174407087111,
      "comment_phi_k": 6.213113275613276,
      "code_phi_k": 46.83939008271077
    },
    {
      "comment": "# Try to load existing learning data",
      "code": "        print(f\"  \u2713 Loaded {len(self.opic.voices)} opic voices (including Field Spec 0.7)\")\n        # Initialize code-output learner\n        self.learner = CodeOutputLearner(project_root)\n        # Try to load existing learning data\n        learning_file = project_root / \"data\" / \"code_output_learning.json\"\n        self.learner.load_learning_data(learning_file)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 59,
      "alignment": 0.5594484918120248,
      "coherence": 0.5594484918120248,
      "comment_phi_k": 8.75952380952381,
      "code_phi_k": 41.216372651848936
    },
    {
      "comment": "# Execute opic voice - opic handles all composition internally",
      "code": "        if not choices:\n            return 0\n        \n        # Execute opic voice - opic handles all composition internally\n        try:\n            answer_idx = self.opic.answer_question(question, choices)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 104,
      "alignment": 0.6801904567215606,
      "coherence": 0.6801904567215606,
      "comment_phi_k": 14.453787878787878,
      "code_phi_k": 27.280380874501994
    },
    {
      "comment": "# Could log error for learning",
      "code": "            if 0 <= answer_idx < len(choices):\n                return answer_idx\n        except Exception as e:\n            # Could log error for learning\n            pass\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 110,
      "alignment": 0.5934811271111128,
      "coherence": 0.5934811271111128,
      "comment_phi_k": 7.517261904761906,
      "code_phi_k": 23.862319624819627
    },
    {
      "comment": "# Fallback: return first choice",
      "code": "            # Could log error for learning\n            pass\n        \n        # Fallback: return first choice\n        return 0\n    ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 113,
      "alignment": 0.6159320023720102,
      "coherence": 0.6159320023720102,
      "comment_phi_k": 6.2839285714285715,
      "code_phi_k": 16.692857142857143
    },
    {
      "comment": "# Collect all questions",
      "code": "        if not mmlu_data:\n            return 0.0\n        \n        # Collect all questions\n        all_questions = []\n        for subject, questions in mmlu_data.items():",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 126,
      "alignment": 0.5692899931234044,
      "coherence": 0.5692899931234044,
      "comment_phi_k": 5.0490079365079366,
      "code_phi_k": 20.741448828948826
    },
    {
      "comment": "# Sample questions",
      "code": "            for q in questions:\n                all_questions.append((subject, q))\n        \n        # Sample questions\n        sample_questions = random.sample(all_questions, min(sample_size, len(all_questions)))\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 132,
      "alignment": 0.5484204453677304,
      "coherence": 0.5484204453677304,
      "comment_phi_k": 3.544246031746032,
      "code_phi_k": 20.071448873107286
    },
    {
      "comment": "# Use opic to answer (captures code trace internally)",
      "code": "            choices = question_data[\"choices\"]\n            correct_answer = question_data[\"answer\"]\n            \n            # Use opic to answer (captures code trace internally)\n            predicted_answer = self.answer_question_with_opic(question, choices)\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 145,
      "alignment": 0.646966562738321,
      "coherence": 0.646966562738321,
      "comment_phi_k": 12.32956349206349,
      "code_phi_k": 27.13819784547592
    },
    {
      "comment": "# Code-output learning: learn from coupling code with output",
      "code": "            # Use opic to answer (captures code trace internally)\n            predicted_answer = self.answer_question_with_opic(question, choices)\n            \n            # Code-output learning: learn from coupling code with output\n            # Get code trace from opic (if available)\n            # For now, create a simplified trace for learning",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 148,
      "alignment": 0.5713881853962006,
      "coherence": 0.5713881853962006,
      "comment_phi_k": 13.257557720057719,
      "code_phi_k": 53.05648130994746
    },
    {
      "comment": "# Get code trace from opic (if available)",
      "code": "            predicted_answer = self.answer_question_with_opic(question, choices)\n            \n            # Code-output learning: learn from coupling code with output\n            # Get code trace from opic (if available)\n            # For now, create a simplified trace for learning\n            code_trace = {",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 149,
      "alignment": 0.5659246043996004,
      "coherence": 0.5659246043996004,
      "comment_phi_k": 9.920039682539683,
      "code_phi_k": 42.5789019448681
    },
    {
      "comment": "# For now, create a simplified trace for learning",
      "code": "            \n            # Code-output learning: learn from coupling code with output\n            # Get code trace from opic (if available)\n            # For now, create a simplified trace for learning\n            code_trace = {\n                \"question\": question,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 150,
      "alignment": 0.5831070113191564,
      "coherence": 0.5831070113191564,
      "comment_phi_k": 11.28313492063492,
      "code_phi_k": 39.58315295815295
    },
    {
      "comment": "# Record code-output pair for learning",
      "code": "                \"method\": \"answer_question_with_zero_interpretation\"\n            }\n            \n            # Record code-output pair for learning\n            evaluation = {\n                \"coherence\": 1.0 if predicted_answer == correct_answer else 0.0,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 157,
      "alignment": 0.6120697553699905,
      "coherence": 0.6120697553699905,
      "comment_phi_k": 8.073629148629148,
      "code_phi_k": 22.0470911247867
    },
    {
      "comment": "# Sample questions",
      "code": "        if not gpqa_data:\n            return 0.0\n        \n        # Sample questions\n        sample_questions = random.sample(gpqa_data, min(sample_size, len(gpqa_data)))\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 192,
      "alignment": 0.5572095322143622,
      "coherence": 0.5572095322143622,
      "comment_phi_k": 3.544246031746032,
      "code_phi_k": 17.26012778781321
    },
    {
      "comment": "# Use opic to answer",
      "code": "            choices = question_data[\"choices\"]\n            correct_answer = question_data[\"answer\"]\n            \n            # Use opic to answer\n            predicted_answer = self.answer_question_with_opic(question, choices)\n            ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 207,
      "alignment": 0.5855862445982397,
      "coherence": 0.5855862445982397,
      "comment_phi_k": 6.116666666666666,
      "code_phi_k": 20.925301020079097
    },
    {
      "comment": "# Code-output learning",
      "code": "            # Use opic to answer\n            predicted_answer = self.answer_question_with_opic(question, choices)\n            \n            # Code-output learning\n            code_trace = {\n                \"question\": question,",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 210,
      "alignment": 0.5495202120769421,
      "coherence": 0.5495202120769421,
      "comment_phi_k": 3.848629148629149,
      "code_phi_k": 21.353901944868102
    },
    {
      "comment": "# Use opic's math system - opic handles all composition",
      "code": "            problem = problem_data[\"problem\"]\n            correct_answer = problem_data.get(\"answer\", \"\")\n            \n            # Use opic's math system - opic handles all composition\n            try:\n                predicted_answer = self.opic.solve_math_problem(problem)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 261,
      "alignment": 0.6632344621939522,
      "coherence": 0.6632344621939522,
      "comment_phi_k": 12.78335137085137,
      "code_phi_k": 25.96988116825815
    },
    {
      "comment": "# Match answer (handle numeric strings)",
      "code": "            except:\n                predicted_answer = \"0\"\n            \n            # Match answer (handle numeric strings)\n            predicted_str = str(predicted_answer).strip()\n            correct_str = str(correct_answer).strip()",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 267,
      "alignment": 0.622303435913846,
      "coherence": 0.622303435913846,
      "comment_phi_k": 7.427380952380952,
      "code_phi_k": 18.895972349311794
    },
    {
      "comment": "# Try numeric comparison",
      "code": "            predicted_str = str(predicted_answer).strip()\n            correct_str = str(correct_answer).strip()\n            \n            # Try numeric comparison\n            try:\n                if float(predicted_str) == float(correct_str):",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 271,
      "alignment": 0.5714893403947556,
      "coherence": 0.5714893403947556,
      "comment_phi_k": 4.612896825396826,
      "code_phi_k": 18.437863249948826
    },
    {
      "comment": "# String matching",
      "code": "                if float(predicted_str) == float(correct_str):\n                    correct += 1\n            except:\n                # String matching\n                if predicted_str.lower() == correct_str.lower():\n                    correct += 1",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 276,
      "alignment": 0.5438090048101302,
      "coherence": 0.5438090048101302,
      "comment_phi_k": 3.042261904761905,
      "code_phi_k": 18.88207031831258
    },
    {
      "comment": "# Run each benchmark",
      "code": "        \n        results = {}\n        \n        # Run each benchmark\n        results[\"MMLU\"] = self.evaluate_mmlu(sample_size=100)\n        results[\"GPQA Diamond\"] = self.evaluate_gpqa(sample_size=100)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 308,
      "alignment": 0.580897455202445,
      "coherence": 0.580897455202445,
      "comment_phi_k": 4.694246031746032,
      "code_phi_k": 16.853902061019532
    },
    {
      "comment": "# Humanity's Last Exam - use estimated score for now",
      "code": "        results[\"GPQA Diamond\"] = self.evaluate_gpqa(sample_size=100)\n        results[\"AIME 2024\"] = self.evaluate_aime_2024(sample_size=15)\n        \n        # Humanity's Last Exam - use estimated score for now\n        results[\"Humanity's Last Exam\"] = 25.0  # Already competitive\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 313,
      "alignment": 0.6191846218083291,
      "coherence": 0.6191846218083291,
      "comment_phi_k": 12.377579365079363,
      "code_phi_k": 32.15182748322338
    },
    {
      "comment": "Already competitive",
      "code": "results[\"Humanity's Last Exam\"] = 25.0",
      "type": "inline",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 314,
      "alignment": 0.8276191451356713,
      "coherence": 0.8276191451356713,
      "comment_phi_k": 4.053805916305916,
      "code_phi_k": 5.120285912487924
    },
    {
      "comment": "# Learn from code-output coupling",
      "code": "        # Humanity's Last Exam - use estimated score for now\n        results[\"Humanity's Last Exam\"] = 25.0  # Already competitive\n        \n        # Learn from code-output coupling\n        print(\"\\n\" + \"=\" * 60)\n        print(\"Code-Output Learning\")",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 316,
      "alignment": 0.5551191487758977,
      "coherence": 0.5551191487758977,
      "comment_phi_k": 6.6152958152958155,
      "code_phi_k": 33.31217429371454
    },
    {
      "comment": "# Update field from learning",
      "code": "        print(f\"  Recorded {patterns.get('total_pairs', 0)} code-output pairs\")\n        print(f\"  Success rate: {patterns.get('correlations', {}).get('success_rate', 0.0):.1%}\")\n        \n        # Update field from learning\n        updates = self.learner.update_field_from_learning()\n        if updates:",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 324,
      "alignment": 0.5618121572593802,
      "coherence": 0.5618121572593802,
      "comment_phi_k": 6.558928571428572,
      "code_phi_k": 29.807128349862577
    },
    {
      "comment": "# Save learning data",
      "code": "        if updates:\n            print(f\"  Field updates: {len(updates.get('preferred_zero_patterns', []))} zero patterns\")\n        \n        # Save learning data\n        learning_file = self.project_root / \"data\" / \"code_output_learning.json\"\n        self.learner.save_learning_data(learning_file)",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 329,
      "alignment": 0.5466971060514662,
      "coherence": 0.5466971060514662,
      "comment_phi_k": 4.692261904761905,
      "code_phi_k": 27.466862736008128
    },
    {
      "comment": "# Display comparison table",
      "code": "        learning_file = self.project_root / \"data\" / \"code_output_learning.json\"\n        self.learner.save_learning_data(learning_file)\n        \n        # Display comparison table\n        self._display_comparison_table(results)\n        ",
      "type": "block",
      "file": "/Users/joelstover/gitpub/opic/scripts/benchmark_eval_real.py",
      "line": 333,
      "alignment": 0.5877035445260613,
      "coherence": 0.5877035445260613,
      "comment_phi_k": 5.062896825396825,
      "code_phi_k": 16.96329621530454
    }
  ],
  "analysis": {
    "total_pairs": 1854,
    "coherent_pairs": 1777,
    "coherence_rate": 0.9584681769147788,
    "successful_patterns": {
      "high_coherence_pairs": 1777,
      "avg_coherence": 0.5778822345483811,
      "avg_alignment": 0.5778822345483811,
      "comment_types": {
        "docstring": {
          "count": 425,
          "avg_coherence": 0.0
        },
        "block": {
          "count": 1207,
          "avg_coherence": 0.0
        },
        "inline": {
          "count": 222,
          "avg_coherence": 0.0
        }
      }
    }
  }
}