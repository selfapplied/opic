#include <metal_stdlib>
using namespace metal;

// Generated by Opic

struct Type {
    float placeholder;
};

struct Voice {
    float placeholder;
};

struct Target {
    float placeholder;
};

struct Flow {
    float placeholder;
};

kernel void opic_parse_ops_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {ops_text -> split_lines -> filter_lines -> parse_each -> parse_includes -> collect_defs_voices_includes -> defs + voices + includes}
    output[id] = input[id];
}

kernel void opic_split_lines_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {text -> split_by_newline -> lines}
    output[id] = input[id];
}

kernel void opic_filter_lines_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {lines -> remove_comments -> remove_empty -> valid_lines}
    output[id] = input[id];
}

kernel void opic_remove_comments_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {line -> check_starts_with ";" -> if_true_skip}
    output[id] = input[id];
}

kernel void opic_remove_empty_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {line -> check_whitespace -> if_empty_skip}
    output[id] = input[id];
}

kernel void opic_parse_each_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {valid_lines -> for_each -> parse_line -> def_or_voice}
    output[id] = input[id];
}

kernel void opic_parse_line_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {line -> check_type -> if_def_parse_def -> if_voice_parse_voice}
    output[id] = input[id];
}

kernel void opic_check_type_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {line -> starts_with "include " -> is_include}
    output[id] = input[id];
}

kernel void opic_parse_includes_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {valid_lines -> filter_include_lines -> extract_include_files -> includes}
    output[id] = input[id];
}

kernel void opic_filter_include_lines_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {lines -> for_each -> check_starts_with "include " -> include_lines}
    output[id] = input[id];
}

kernel void opic_extract_include_files_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {include_lines -> for_each -> remove_prefix "include " -> strip -> include_files}
    output[id] = input[id];
}

kernel void opic_parse_def_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {def_line -> extract_name -> extract_fields -> create_def}
    output[id] = input[id];
}

kernel void opic_extract_name_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {voice_line -> before_slash -> split_spaces -> get_index_1 -> name}
    output[id] = input[id];
}

kernel void opic_extract_fields_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {line -> find_braces -> extract_inside -> split_commas -> fields}
    output[id] = input[id];
}

kernel void opic_find_braces_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {line -> find "{ }" -> inside}
    output[id] = input[id];
}

kernel void opic_create_def_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {name + fields -> def_object}
    output[id] = input[id];
}

kernel void opic_parse_voice_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {voice_line -> extract_name -> extract_body -> create_voice}
    output[id] = input[id];
}

kernel void opic_extract_body_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {voice_line -> after_slash -> strip_quotes -> strip_whitespace -> body}
    output[id] = input[id];
}

kernel void opic_before_slash_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {line -> partition "/" -> before}
    output[id] = input[id];
}

kernel void opic_after_slash_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {line -> partition "/" -> after}
    output[id] = input[id];
}

kernel void opic_strip_quotes_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {text -> remove_leading_trailing_quotes -> cleaned}
    output[id] = input[id];
}

kernel void opic_create_voice_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {name + body -> voice_object}
    output[id] = input[id];
}

kernel void opic_collect_defs_voices_includes_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {parsed_items + includes -> separate_defs_voices -> defs + voices + includes}
    output[id] = input[id];
}

kernel void opic_separate_defs_voices_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {items -> filter_defs -> filter_voices -> defs + voices}
    output[id] = input[id];
}

kernel void opic_load_recursive_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {file_path + loaded_set + all_defs + all_voices + agent_realm + ca -> opic.check_loaded -> opic.load_if_new -> opic.load_with_verification -> opic.load_includes -> opic.load_attention -> opic.load_repo_extensions -> loaded}
    output[id] = input[id];
}

kernel void opic_load_repo_extensions_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {loaded + current_dir -> repo.check_repo -> if_repo_discover_ops -> if_repo_load -> extended}
    output[id] = input[id];
}

kernel void if_repo_discover_ops_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {is_repo -> repo.discover_ops -> ops_files}
    output[id] = input[id];
}

kernel void if_repo_load_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {ops_files -> repo.load_extension -> extended_voices}
    output[id] = input[id];
}

kernel void opic_check_loaded_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {file_path + loaded_set -> contains -> is_loaded}
    output[id] = input[id];
}

kernel void opic_load_if_new_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {file_path + is_loaded -> if_not_loaded -> opic.load_file}
    output[id] = input[id];
}

kernel void opic_load_file_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {file_path -> opic.check_file_permission -> opic.read_file -> opic.parse_ops -> defs + voices + includes}
    output[id] = input[id];
}

kernel void opic_check_file_permission_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {file_path + agent_realm + ca -> cert.check_file_read -> if_permitted -> if_denied_reject}
    output[id] = input[id];
}

kernel void opic_read_file_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {file_path -> file_read -> text}
    output[id] = input[id];
}

kernel void opic_load_with_verification_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {file_path + agent_realm + ca -> opic.check_signed -> if_signed_verify -> if_unsigned_load_normal}
    output[id] = input[id];
}

kernel void opic_check_signed_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {file_path -> file.read -> check_has_header -> is_signed}
    output[id] = input[id];
}

kernel void opic_if_signed_verify_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {is_signed + file_path + agent_realm + ca -> signed.verify_ops -> verified_voices}
    output[id] = input[id];
}

kernel void opic_if_unsigned_load_normal_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {not_signed + file_path -> opic.load_file -> voices}
    output[id] = input[id];
}

kernel void opic_load_includes_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {includes + file_dir + loaded_set -> for_each -> opic.resolve_include -> opic.load_recursive}
    output[id] = input[id];
}

kernel void opic_resolve_include_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {include_file + base_dir -> join_path -> absolute_include_path}
    output[id] = input[id];
}

kernel void opic_load_attention_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {voices + file_dir + loaded_set + namespace_map -> opic.detect_namespaces -> opic.map_namespaces -> opic.auto_load -> loaded}
    output[id] = input[id];
}

kernel void opic_detect_namespaces_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {voices -> opic.extract_references -> opic.find_namespaces -> namespaces}
    output[id] = input[id];
}

kernel void opic_extract_references_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {voice_body -> opic.parse_chain -> opic.extract_voice_names -> references}
    output[id] = input[id];
}

kernel void opic_parse_chain_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {chain -> remove_braces -> split_arrows -> steps}
    output[id] = input[id];
}

kernel void opic_extract_voice_names_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {steps -> for_each -> opic.split_plus -> opic.take_first -> opic.check_namespace -> namespaced_names}
    output[id] = input[id];
}

kernel void opic_find_namespaces_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {namespaced_names -> for_each -> opic.extract_prefix -> namespaces}
    output[id] = input[id];
}

kernel void opic_extract_prefix_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {name -> split_dot -> take_first -> add_dot -> namespace}
    output[id] = input[id];
}

kernel void opic_map_namespaces_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {namespaces + namespace_map -> for_each -> opic.lookup_file -> files_to_load}
    output[id] = input[id];
}

kernel void opic_lookup_file_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {namespace + namespace_map -> get -> filename}
    output[id] = input[id];
}

kernel void opic_auto_load_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {files_to_load + file_dir + loaded_set -> for_each -> opic.load_recursive -> loaded}
    output[id] = input[id];
}

kernel void opic_merge_voices_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {existing_voices + new_voices -> update_dict -> merged_voices}
    output[id] = input[id];
}

kernel void opic_merge_defs_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {existing_defs + new_defs -> update_dict -> merged_defs}
    output[id] = input[id];
}

kernel void opic_execute_chain_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {chain_string + voices + agent_realm + ca -> parse_chain -> resolve_steps -> execute_steps -> result}
    output[id] = input[id];
}

kernel void opic_remove_braces_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {chain -> strip "{ }" -> inner}
    output[id] = input[id];
}

kernel void opic_split_arrows_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {inner -> split "->" -> trim_each -> steps}
    output[id] = input[id];
}

kernel void opic_resolve_steps_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {steps + voices + agent_realm + ca -> for_each_step -> opic.check_voice_permission -> find_voice -> resolve_body}
    output[id] = input[id];
}

kernel void opic_check_voice_permission_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {voice_name + agent_realm + ca -> cert.check_voice_execute -> if_permitted -> if_denied_reject}
    output[id] = input[id];
}

kernel void opic_find_voice_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {step_name + voices -> lookup -> voice_body}
    output[id] = input[id];
}

kernel void opic_resolve_body_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {voice_body -> if_chain_recurse -> if_string_return}
    output[id] = input[id];
}

kernel void opic_execute_steps_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {resolved_steps + agent_realm + ca -> for_each -> execute_step -> collect_results}
    output[id] = input[id];
}

kernel void opic_bootstrap_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {main_file + agent_realm + ca -> opic.load_bootstrap -> opic.find_main -> opic.execute_main -> opic.create_witness -> output}
    output[id] = input[id];
}

kernel void opic_load_bootstrap_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {main_file + agent_realm + ca -> opic.load_recursive -> all_voices + all_defs}
    output[id] = input[id];
}

kernel void opic_find_main_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {voices -> get "main" -> main_voice}
    output[id] = input[id];
}

kernel void opic_execute_main_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {main_voice + voices + defs + project_root + agent_realm + ca -> opic.execute_runtime -> output}
    output[id] = input[id];
}

kernel void opic_create_witness_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {project_root + agent_realm + ca -> opic.write_witness_file -> witness_created}
    output[id] = input[id];
}

kernel void opic_write_witness_file_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {project_root + agent_realm + ca -> opic.find_witness_path -> opic.write_witness -> witness_file}
    output[id] = input[id];
}

kernel void opic_find_witness_path_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {project_root -> check_project_root -> check_home -> check_system -> witness_path}
    output[id] = input[id];
}

kernel void opic_check_project_root_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {project_root -> ".opicup" -> join_path -> if_writable_use}
    output[id] = input[id];
}

kernel void opic_check_home_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {"$HOME/.opicup" -> if_writable_use}
    output[id] = input[id];
}

kernel void opic_check_system_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {"/usr/local/share/opic/.opicup" -> if_writable_use}
    output[id] = input[id];
}

kernel void opic_write_witness_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {witness_path + agent_realm + ca -> format_witness_content -> write_file -> witness_file}
    output[id] = input[id];
}

kernel void opic_format_witness_content_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {agent_realm + ca -> "opicup\nrealm=" + agent_realm + "\nca=" + ca -> witness_content}
    output[id] = input[id];
}

kernel void opic_execute_runtime_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {main_voice + voices + defs + project_root + agent_realm + ca -> opic.detect_runtime_type -> opic.execute_specialized -> output}
    output[id] = input[id];
}

kernel void opic_detect_runtime_type_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {main_voice -> opic.check_patterns -> runtime_type}
    output[id] = input[id];
}

kernel void opic_check_patterns_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {main_voice -> check_interactive + check_evaluation + check_repos + check_compile + check_plan + check_help -> runtime_type}
    output[id] = input[id];
}

kernel void opic_check_interactive_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {main_voice -> contains "interactive" -> is_interactive}
    output[id] = input[id];
}

kernel void opic_check_evaluation_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {main_voice -> contains "evaluate" -> is_evaluation}
    output[id] = input[id];
}

kernel void opic_check_repos_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {main_voice -> contains "repos" -> is_repos}
    output[id] = input[id];
}

kernel void opic_check_compile_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {main_voice -> contains "compile" -> is_compile}
    output[id] = input[id];
}

kernel void opic_check_plan_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {main_voice -> contains "plan" + contains "suggest" -> is_plan}
    output[id] = input[id];
}

kernel void opic_check_help_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {main_voice -> contains "help" -> is_help}
    output[id] = input[id];
}

kernel void opic_execute_specialized_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {runtime_type + main_voice + voices + defs + project_root + agent_realm + ca -> if_interactive -> if_evaluation -> if_repos -> if_compile -> if_plan -> if_help -> if_generic -> output}
    output[id] = input[id];
}

kernel void opic_execute_interactive_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {voices + defs + project_root + agent_realm + ca -> cert.guard_execute -> execute_interactive_conversation -> output}
    output[id] = input[id];
}

kernel void opic_execute_evaluation_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {voices + defs + project_root + agent_realm + ca -> cert.guard_execute -> execute_evaluation -> output}
    output[id] = input[id];
}

kernel void opic_execute_repos_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {voices + defs + project_root + agent_realm + ca -> cert.guard_execute -> execute_repos -> output}
    output[id] = input[id];
}

kernel void opic_execute_compile_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {voices + defs + project_root + agent_realm + ca -> cert.guard_execute -> execute_compile -> output}
    output[id] = input[id];
}

kernel void opic_execute_plan_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {voices + defs + project_root + agent_realm + ca -> cert.guard_execute -> execute_plan -> output}
    output[id] = input[id];
}

kernel void opic_execute_help_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {voices + defs + project_root + agent_realm + ca -> cert.guard_execute -> execute_help -> output}
    output[id] = input[id];
}

kernel void opic_execute_generic_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {main_voice + voices + agent_realm + ca -> opic.execute_chain -> output}
    output[id] = input[id];
}

kernel void main_kernel(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    uint id [[thread_position_in_grid]]
) {
    // {opic.bootstrap -> bootstrap}
    output[id] = input[id];
}
