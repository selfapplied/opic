;;; test.ops â€” Tests for opic capabilities

;; Test structure
def test { name, input, expected, actual, passed }

;; Test: Planning capability
voice test.planning / "Test that opic can plan"
voice test.planning.goal / "Test goal: solve simple equation"
voice test.planning.plan / {goal -> step_1 -> step_2 -> step_3}
voice test.planning.step_1 / "Extract variables"
voice test.planning.step_2 / "Apply operations"
voice test.planning.step_3 / "Verify result"
voice test.planning.expected / "plan with 3 steps"
voice test.planning.actual / {plan.from_goal -> plan}
voice test.planning.passed / {expected == actual -> true}

;; Test: Execution capability
voice test.execution / "Test that opic can execute chains"
voice test.execution.chain / {input -> process -> output}
voice test.execution.input / "test_data"
voice test.execution.process / {input -> transform}
voice test.execution.transform / {data -> modified_data}
voice test.execution.output / "modified_data"
voice test.execution.expected / "output produced"
voice test.execution.actual / {execute.chain -> result}
voice test.execution.passed / {result == output -> true}

;; Test: Voice resolution
voice test.voice_resolution / "Test that voices resolve correctly"
voice test.voice_resolution.voice_a / "value_a"
voice test.voice_resolution.voice_b / {voice_a -> value_b}
voice test.voice_resolution.expected / "value_b"
voice test.voice_resolution.actual / {resolve voice_b}
voice test.voice_resolution.passed / {actual == expected -> true}

;; Test: Dependency checking
voice test.dependencies / "Test that dependencies are checked"
voice test.dependencies.step / {dep1 + dep2 -> result}
voice test.dependencies.dep1 / "available"
voice test.dependencies.dep2 / "available"
voice test.dependencies.expected / "all dependencies available"
voice test.dependencies.actual / {check_dependencies step}
voice test.dependencies.passed / {actual == expected -> true}

;; Test: LaTeX generation
voice test.latex / "Test that LaTeX equations are generated"
voice test.latex.equation / "x^2 + y^2 = z^2"
voice test.latex.latex_voice / "x^2 + y^2 = z^2"
voice test.latex.expected / "LaTeX string present"
voice test.latex.actual / {find_latex_voices -> latex_found}
voice test.latex.passed / {latex_found -> true}

;; Test: Chain parsing
voice test.chain_parsing / "Test that chains are parsed correctly"
voice test.chain_parsing.chain / {a -> b -> c}
voice test.chain_parsing.expected / ["a", "b", "c"]
voice test.chain_parsing.actual / {parse_chain chain}
voice test.chain_parsing.passed / {actual == expected -> true}

;; Test: Goal/Plan/Solve structure
voice test.goal_plan_solve / "Test goal-plan-solve structure"
voice test.goal_plan_solve.goal / "Test goal"
voice test.goal_plan_solve.plan / {goal -> plan_step_1 -> plan_step_2}
voice test.goal_plan_solve.solve / {plan -> solve_step_1 -> solve_step_2}
voice test.goal_plan_solve.expected / "goal -> plan -> solve chain"
voice test.goal_plan_solve.actual / {goal -> plan -> solve}
voice test.goal_plan_solve.passed / {structure_valid -> true}

;; Test: Generic execution
voice test.generic_execution / "Test generic execution engine"
voice test.generic_execution.any_chain / {start -> middle -> end}
voice test.generic_execution.start / "begin"
voice test.generic_execution.middle / {start -> process}
voice test.generic_execution.end / {middle -> finish}
voice test.generic_execution.expected / "chain executed"
voice test.generic_execution.actual / {execute.plan any_chain}
voice test.generic_execution.passed / {actual == expected -> true}

;; Test: Nested chains
voice test.nested_chains / "Test nested chain execution"
voice test.nested_chains.outer / {outer_start -> inner -> outer_end}
voice test.nested_chains.inner / {inner_start -> inner_end}
voice test.nested_chains.expected / "nested chain resolved"
voice test.nested_chains.actual / {execute_chain outer}
voice test.nested_chains.passed / {nested_resolved -> true}

;; Test: Data vs Voice detection
voice test.data_detection / "Test data vs voice detection"
voice test.data_detection.data / "data_value"
voice test.data_detection.voice / {input -> output}
voice test.data_detection.expected / "data and voice distinguished"
voice test.data_detection.actual / {detect_type data + detect_type voice}
voice test.data_detection.passed / {data_is_data + voice_is_voice -> true}

;; Test: Capability verification (in opic)
;; Checks reference actual voices that should exist
voice test.capability.planning / "Can opic plan?"
voice test.capability.planning.check / {"goal" + "plan" -> planning_works}
voice test.capability.execution / "Can opic execute?"
voice test.capability.execution.check / {"main" -> execution_works}
voice test.capability.latex / "Can opic generate LaTeX?"
voice test.capability.latex.check / {"test.latex.latex_voice" -> latex_works}
voice test.capability.voices / "Can opic resolve voices?"
voice test.capability.voices.check / {"test.planning" -> resolution_works}

;; Test suite: run all tests
voice test.suite / {test.planning -> test.execution -> test.voice_resolution -> test.dependencies -> test.latex -> test.chain_parsing -> test.goal_plan_solve -> test.generic_execution -> test.nested_chains -> test.data_detection}
voice test.run_all / {test.suite -> collect_results -> report}
voice test.collect_results / {all_tests -> passed_count + failed_count}
voice test.report / {results -> print_summary}

;; Capability tests
voice test.capabilities / {test.capability.planning -> test.capability.execution -> test.capability.latex -> test.capability.voices}

target test / "opic_capability_tests"
voice main / {test.run_all -> test.capabilities -> test}

