;;; vfs.ops â€” virtual filesystem in vmap: plan/execute in memory, flush after validation
;;; Integrated with witnessing and certificate system

include vmap.ops
include certificate.ops
include witness_summons.ops
include vfs_quorum.ops
include vfs_custody.ops
include vfs_ethics.ops
include vfs_nlp.ops
include nlp_capability.ops
include vfs_audit.ops
include bootstrap.ops

;; Virtual filesystem (with certificates and witnessing)
def vfs_transaction { vmap, changes, validation_state, flush_pending, certificates, witnesses }
def vfs_change { path, operation, data, virtual_offset, validated, certificate, witness }
def vfs_plan { changes, virtual_layout, validation_rules, certificates }
def vfs_execution { transaction, operations, results, certificates, witnesses }

;; Create virtual filesystem from vmap
voice vfs.create / {vmap -> vfs.create_layout -> vfs.create_transaction -> vfs}
voice vfs.create_layout / {vmap -> map_blocks_to_files -> file_layout}
voice map_blocks_to_files / {blocks -> assign_paths -> layout}
voice assign_paths / {blocks -> compute_paths -> paths}
voice vfs.create_transaction / {layout -> create_transaction -> transaction}

;; Plan changes in virtual memory (with certificate signing and NLP capability description)
;; vfs.capture_intent is defined in vfs_nlp.ops (included above)
voice vfs.plan / {vfs + changes + agent_realm + ca -> vfs.capture_intent -> vfs.create_plan -> vfs.sign_changes -> vfs_plan}
voice vfs.create_plan / {changes -> vfs.map_to_virtual -> vfs.layout_changes -> plan}
voice vfs.map_to_virtual / {changes -> assign_virtual_offsets -> virtual_changes}
voice assign_virtual_offsets / {changes -> compute_offsets -> offsets}
voice vfs.layout_changes / {virtual_changes -> organize_layout -> layout}
voice vfs.sign_changes / {plan + agent_realm + ca -> for_each_change -> vfs.sign_change -> signed_plan}
voice vfs.sign_change / {change + agent_realm + ca -> cert.create_certificate -> certificate}
voice cert.create_certificate / {change + agent_realm + ca -> cert.issue_certificate -> certificate}

;; Execute operations in virtual memory (no disk writes yet, with witnessing)
voice vfs.execute / {plan + agent_realm + ca -> vfs.execute_in_memory -> vfs.witness_execution -> vfs_execution}
voice vfs.execute_in_memory / {plan -> for_each_change -> vfs.apply_change -> results}
voice vfs.apply_change / {change + vmap -> vfs.read_virtual -> vfs.modify_virtual -> modified}
voice vfs.read_virtual / {vmap + offset -> vmap.read -> data}
voice vfs.modify_virtual / {data + change -> apply_modification -> modified_data}
voice vfs.witness_execution / {execution + agent_realm + ca -> for_each_change -> vfs.witness_change -> witnessed_execution}
voice vfs.witness_change / {change + agent_realm + ca -> witness.create_witness -> witness}
voice witness.create_witness / {change + agent_realm + ca -> witness.sign -> witness}

;; Validation before flush (includes certificate and witness verification)
voice vfs.validate / {execution + agent_realm + ca -> vfs.run_validation -> validation_state}
voice vfs.run_validation / {execution + agent_realm + ca -> vfs.verify_certificates + vfs.verify_witnesses + vfs.check_invariants + vfs.check_syntax + vfs.check_semantics -> validated}
voice vfs.verify_certificates / {execution + agent_realm + ca -> for_each_certificate -> cert.verify -> certificates_valid}
voice vfs.verify_witnesses / {execution + agent_realm + ca -> for_each_witness -> witness.verify -> witnesses_valid}
voice witness.verify / {witness + agent_realm + ca -> cert.verify -> witness_valid}
voice vfs.check_invariants / {execution -> verify_invariants -> invariant_check}
voice vfs.check_syntax / {execution -> verify_syntax -> syntax_check}
voice vfs.check_semantics / {execution -> verify_semantics -> semantic_check}

;; Flush validated changes to disk (only if certificates and witnesses are valid)
voice vfs.flush / {execution + validation + agent_realm + ca -> if_validated -> vfs.write_to_disk -> vfs.record_certificates -> vfs.compute_digest -> vfs.store_digest -> flushed}
voice if_validated / {validation -> check_valid -> if_true_flush}
voice check_valid / {validation -> is_valid + certificates_valid + witnesses_valid -> all_valid}
voice vfs.write_to_disk / {validated_changes -> for_each -> vfs.write_file -> written}
voice vfs.write_file / {change -> write_to_path -> file_written}
voice vfs.record_certificates / {execution + agent_realm + ca -> vfs.store_certificates -> certificates_stored}
voice vfs.store_certificates / {certificates -> store_in_ledger -> stored}

;; Transactional: rollback if validation fails
voice vfs.rollback / {transaction -> vfs.discard_changes -> rolled_back}
voice vfs.discard_changes / {transaction -> clear_virtual_changes -> cleared}

;; Complete workflow: plan -> execute -> validate -> flush (with certificates, witnessing, ethics, audit)
voice vfs.commit / {vfs + changes + agent_realm + ca -> vfs.plan -> vfs.execute -> vfs.validate -> vfs.commit_ethics -> audit.complete_audit -> if_validated_flush -> if_invalid_rollback -> result}
voice if_validated_flush / {validation -> if_valid + certificates_valid + witnesses_valid -> vfs.flush -> vfs.compute_digest -> audit.record_entry -> flushed}
voice if_invalid_rollback / {validation -> if_invalid -> audit.generate_rollback_proof -> vfs.rollback -> rolled_back}

;; File operations in virtual memory
voice vfs.create_file / {vfs + path + data -> vfs.plan_create -> vfs.execute_create -> change}
voice vfs.plan_create / {path + data -> create_change_plan -> plan}
voice vfs.execute_create / {plan + vfs -> allocate_virtual_space -> write_virtual -> change}

voice vfs.modify_file / {vfs + path + modifications -> vfs.plan_modify -> vfs.execute_modify -> change}
voice vfs.plan_modify / {path + modifications -> create_modify_plan -> plan}
voice vfs.execute_modify / {plan + vfs -> read_virtual -> modify_data -> write_virtual -> change}

voice vfs.delete_file / {vfs + path -> vfs.plan_delete -> vfs.execute_delete -> change}
voice vfs.plan_delete / {path -> create_delete_plan -> plan}
voice vfs.execute_delete / {plan + vfs -> mark_deleted -> change}

;; Directory operations in virtual memory
voice vfs.create_dir / {vfs + path -> vfs.plan_dir_create -> vfs.execute_dir_create -> change}
voice vfs.plan_dir_create / {path -> create_dir_plan -> plan}
voice vfs.execute_dir_create / {plan + vfs -> allocate_dir_space -> write_dir_entry -> change}

;; Read from virtual filesystem (no disk access)
voice vfs.read / {vfs + path -> vfs.find_virtual -> vfs.read_virtual_data -> data}
voice vfs.find_virtual / {vfs + path -> lookup_in_layout -> virtual_offset}
voice vfs.read_virtual_data / {vfs + offset -> vmap.read -> data}

;; List virtual filesystem (shows planned + existing)
voice vfs.list / {vfs -> vfs.list_virtual -> file_list}
voice vfs.list_virtual / {vfs -> get_layout -> list_paths -> paths}

;; Check virtual filesystem state
voice vfs.status / {vfs -> vfs.count_changes + vfs.count_validated + vfs.count_pending -> status}
voice vfs.count_changes / {vfs -> count_changes -> change_count}
voice vfs.count_validated / {vfs -> count_validated -> validated_count}
voice vfs.count_pending / {vfs -> count_pending -> pending_count}

target vfs / "virtual_filesystem"
voice main / {vfs.create -> vfs}

