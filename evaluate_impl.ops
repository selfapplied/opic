;;; evaluate_impl.ops â€” Evaluation implementation in opic (self-hosting)

;; Load test data (from evaluate.test_data)
voice evaluate.load_test_data / {voice_training_data.json -> json_read -> extract_pairs -> test_pairs}
voice evaluate.json_read / {filename -> read_file -> json_parse -> data}
voice evaluate.extract_pairs / {data -> get_pairs -> pairs}
voice evaluate.test_pairs / {pairs -> take_first_100 -> test_pairs}

;; Load embeddings (from topological_map.ops)
voice evaluate.load_embeddings / {opic_embeddings.json -> json_read -> extract_embeddings -> topological_map}
voice evaluate.extract_embeddings / {data -> get_embeddings -> embeddings_array}
voice topological.build_map / {embeddings_array -> create_points -> topological_map}

;; Load Metal shaders (from metal_tensors.ops)
voice evaluate.load_metal / {tensor_operations.metal -> metal.load_device -> metal.load_library -> metal_device + metal_library}
voice metal.load_device / {system -> create_device -> device}
voice metal.load_library / {metal_file + device -> compile -> library}

;; Generate predictions (from evaluate.generate_predictions)
voice evaluate.generate_predictions / {test_pairs + topological_map + metal_library -> for_each_pair -> generate_prediction -> predictions}
voice evaluate.for_each_pair / {pairs -> map -> predictions}
voice evaluate.generate_prediction / {pair + map + metal -> topological.predict -> prediction}
voice topological.predict / {input + map + metal -> metal.topological_explore -> prediction}

;; Topological exploration (from topological_map.ops + metal_tensors.ops)
voice topological.explore / {query + map + metal -> metal.execute_topological_explore -> prediction}
voice metal.topological_explore / {query_buffer + map_buffer + k + device + library -> execute_kernel -> result}
voice metal.execute_kernel / {kernel_name + buffers + device + library -> setup -> encode -> dispatch -> read -> result}

;; Compute metrics (from evaluate.metrics)
voice evaluate.compute_metrics / {predictions + references -> evaluate.f1 + evaluate.bleu -> f1_score + bleu_score}
voice evaluate.f1 / {predictions + references -> compute_f1 -> f1_score}
voice evaluate.bleu / {predictions + references -> compute_bleu -> bleu_score}

;; Main evaluation chain (from evaluate.run)
voice evaluate.run / {evaluate.load_test_data -> evaluate.load_embeddings -> evaluate.load_metal -> evaluate.generate_predictions -> evaluate.compute_metrics -> evaluate.display_results -> scores}

target evaluate_impl / "evaluation_implementation"
voice main / {evaluate.run -> evaluate_impl}

