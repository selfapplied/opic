;;; inflate_deflate.ops â€” inflate/deflate algorithms in opic

include bootstrap.ops

;; Compression geometry
def compressed_block { data, geometry, compressed_size, original_size }
def compression_geometry { huffman_tree, distance_codes, literal_codes, block_type }
def huffman_tree { codes, lengths, symbols }
def deflate_block { block_type, length, distance, literals }

;; Inflate (decompress) algorithm
voice inflate.decompress / {compressed_data -> inflate.parse_header -> inflate.process_blocks -> decompressed_data}
voice inflate.parse_header / {data -> check_zlib_header + check_gzip_header + check_raw -> header_info}
voice check_zlib_header / {data -> check_magic_bytes -> is_zlib}
voice check_gzip_header / {data -> check_magic_bytes -> is_gzip}
voice check_raw / {data -> if_no_header -> is_raw}

;; Process deflate blocks
voice inflate.process_blocks / {data + header -> inflate.read_block -> inflate.deflate_block -> inflate.process_blocks -> decompressed}
voice inflate.read_block / {data + offset -> read_bits_3 -> block_type -> read_block_header -> block_header}
voice read_bits_3 / {data + offset -> extract_bits_3 -> bits}
voice read_block_header / {block_type -> if_fixed -> if_dynamic -> if_stored -> header}

;; Deflate block types
voice inflate.deflate_block / {block_header + data -> if_fixed_huffman -> if_dynamic_huffman -> if_stored -> decompressed_block}
voice if_fixed_huffman / {block_type -> equals_1 -> use_fixed_codes -> decompress}
voice if_dynamic_huffman / {block_type -> equals_2 -> build_huffman_tree -> decompress}
voice if_stored / {block_type -> equals_0 -> copy_literals -> decompressed}

;; Build Huffman tree (geometry of compression)
voice inflate.build_huffman_tree / {code_lengths -> build_tree_geometry -> huffman_tree}
voice build_tree_geometry / {lengths -> compute_codes -> assign_symbols -> tree}
voice compute_codes / {lengths -> canonical_huffman -> codes}
voice canonical_huffman / {lengths -> sort_by_length -> assign_codes -> code_table}

;; Decompress using Huffman tree
voice inflate.decompress_with_tree / {compressed_data + huffman_tree -> decode_symbols -> decompressed}
voice decode_symbols / {data + tree -> read_bits -> match_code -> decode -> symbols}
voice read_bits / {data + offset -> extract_bits -> bits}
voice match_code / {bits + tree -> traverse_tree -> symbol}
voice traverse_tree / {bits + node -> if_leaf_symbol -> if_branch_traverse -> result}

;; Deflate (compress) algorithm
voice deflate.compress / {data -> deflate.find_matches -> deflate.encode -> deflate.write_blocks -> compressed_data}
voice deflate.find_matches / {data -> sliding_window -> find_longest_match -> matches}
voice sliding_window / {data + position -> lookback_window -> candidates}
voice find_longest_match / {candidates + current -> compare -> longest_match}
voice deflate.encode / {matches -> encode_literals + encode_distances -> encoded}
voice encode_literals / {literals -> huffman_encode -> encoded_literals}
voice encode_distances / {distances -> distance_codes -> encoded_distances}

;; LZ77 compression (foundation of deflate)
voice deflate.lz77 / {data -> find_repeated_sequences -> encode_references -> compressed}
voice find_repeated_sequences / {data -> sliding_window_match -> sequences}
voice encode_references / {sequences -> length_distance_pairs -> references}

target inflate_deflate / "compression_algorithms"
voice main / {inflate.decompress -> inflate_deflate}

