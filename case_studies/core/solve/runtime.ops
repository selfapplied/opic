;;; runtime.ops — Emit OPIC to target runtime
;;; Case Study: Solve semantically, then emit to runtime

include systems/solve/solve_simple.ops

;; ============================================================================
;; RUNTIME EMISSION
;; ============================================================================
;; Core Philosophy:
;;   1. OPIC solves semantically through its implicit system
;;   2. Then emits that meaning to a target runtime
;;   3. No complex constraint graphs - just emission
;;
;; This is the "solve → emit" pattern crystallized.

;; ============================================================================
;; EXAMPLE: Tiny OPIC Program
;; ============================================================================

;; Define a computation in OPIC terms
def point { x: int, y: int, mass: float }

voice add_points / {
  p1: point + p2: point ->
  point.create (p1.x + p2.x) (p1.y + p2.y) (p1.mass + p2.mass) ->
  result: point
}

voice increment / {
  p: point ->
  add_points p (point.create 1 1 0.0) ->
  result: point
}

;; ============================================================================
;; DECLARE TARGET RUNTIME
;; ============================================================================

;; Target runtime: Python 3.11
voice target_runtime / {
  "python.cp311"
}

;; ============================================================================
;; WHAT THE SOLVER DOES (Narrated)
;; ============================================================================

;; Step 1: Build semantic graph from OPIC program
;;   - OPIC's implicit system resolves: point, add_points, increment
;;   - Types inferred: point = {x: int, y: int, mass: float}
;;   - Dependencies: increment -> add_points -> point.create
;;
;; Step 2: Compare with target runtime capabilities
;;   - python.cp311: dynamic types, runtime checks, no static types
;;   - Capability match: ✓ Pure functions, ✓ Struct-like objects
;;
;; Step 3: Emit to runtime
;;   - point -> Python dataclass with type hints
;;   - add_points -> Python function with type annotations
;;   - increment -> Python function (uses add_points)
;;   - Emit Python code with docstrings / type hints

;; ============================================================================
;; SOLVE FOR TARGET RUNTIME
;; ============================================================================

voice solve_for_python / {
  "runtime.ops" + "python.cp311" ->
  solve ->
  python_code + report
}

;; ============================================================================
;; ALTERNATIVE RUNTIMES
;; ============================================================================

;; Solve for Rust (static types, compile-time checks)
voice solve_for_rust / {
  "runtime.ops" + "rust" ->
  solve ->
  rust_code + report
}

;; Solve for WASM (sandboxed, deterministic)
voice solve_for_wasm / {
  "runtime.ops" + "wasm" ->
  solve ->
  wasm_code + report
}

;; ============================================================================
;; KEY INSIGHT
;; ============================================================================
;; OPIC's semantic gravity already resolves meaning.
;; The solver just formats that meaning for different runtimes.
;; No complex constraint graphs. No distortion analysis.
;; Just: "here's your OPIC, here's your runtime, go."

target runtime / "emit_to_runtime"
voice main / {
  "runtime.ops" + "python.cp311" ->
  solve ->
  runtime
}

