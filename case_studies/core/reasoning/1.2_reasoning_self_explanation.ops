;;; self_explanation.ops — Tests showing OPIC explaining itself using natural language generation

;; Test: OPIC explains its philosophy
voice test.explain_philosophy / {
  "What is OPIC's philosophy? OPIC is a Turing compositor for dynamic fields. Voices are morphisms that compose behaviors. Computation is living, distributed conversation. Programs verify, sign, and evolve themselves." ->
  generate.coherent ->
  philosophy_explanation
}

;; Test: OPIC explains its execution model
voice test.explain_execution / {
  "How does OPIC execute? OPIC parses chains, discovers voices automatically, executes steps sequentially, preserves data flow. Each step receives previous result. Nested chains execute recursively." ->
  generate.coherent ->
  execution_explanation
}

;; Test: OPIC explains its architecture
voice test.explain_architecture / {
  "What is OPIC's architecture? Layer 0: Language Runtime. Layer 1: Core Systems. Layer 2: Domain Systems. Layer 3: Applications. Layer 4: Resources." ->
  generate.coherent ->
  architecture_explanation
}

;; Test: OPIC explains self-hosting
voice test.explain_self_hosting / {
  "How is OPIC self-hosting? OPIC defines itself. bootstrap.ops defines the kernel. opic_parse.ops parses OPIC code. opic_load.ops loads OPIC files. opic_execute.ops executes OPIC voices. All written in OPIC itself." ->
  generate.coherent ->
  self_hosting_explanation
}

;; Test: OPIC explains voices
voice test.explain_voices / {
  "What are voices? Voices are composable transformations. They are morphisms, not just functions. Each voice has invariant signature. Voices compose into chains. Syntax: voice name / {input -> transformation -> output}." ->
  generate.coherent ->
  voices_explanation
}

;; Test: OPIC explains chains
voice test.explain_chains / {
  "What are chains? Chains are sequential compositions. Data flows forward through chain. Each step receives previous result. Chains can contain nested chains. Syntax: {input -> voice1 -> voice2 -> output}." ->
  generate.coherent ->
  chains_explanation
}

;; Test: OPIC explains circular architecture
voice test.explain_circular / {
  "What is OPIC's circular architecture? Python ↔ OPIC boundary preserves information. Python provides file I/O and primitives. OPIC provides language definition and execution. Equilibrium: Python bootstraps, OPIC executes itself. Lossless: Information flows through circle S¹." ->
  generate.coherent ->
  circular_explanation
}

;; Test: OPIC explains field theory
voice test.explain_field_theory / {
  "What is OPIC's field theory? Field Specification 0.7: Pascal Mod 10, Tangent Symmetry, Bracket Algebra. Voice is dynamic actor carrying phase, potential, charge. Ion is minimal quantum of bias. Field is global continuum of meaning. Equilibrium is resonance point." ->
  generate.coherent ->
  field_explanation
}

;; Test: OPIC explains incremental expansion
voice test.explain_incremental / {
  "Should OPIC expand incrementally? OPIC composes two behaviors into a third. Self-hosting evolved incrementally: parser → loader → executor. expansion.incremental_expand expands only new symbols. Each addition preserves structural invariants. Incremental expansion aligns with compositional growth philosophy." ->
  generate.coherent ->
  incremental_explanation
}

;; Main test: Run all explanation tests
voice test.all_explanations / {
  test.explain_philosophy ->
  test.explain_execution ->
  test.explain_architecture ->
  test.explain_self_hosting ->
  test.explain_voices ->
  test.explain_chains ->
  test.explain_circular ->
  test.explain_field_theory ->
  test.explain_incremental ->
  "All self-explanation tests completed"
}

target self_explanation / "opic_explains_itself"
voice main / {test.all_explanations -> self_explanation}

